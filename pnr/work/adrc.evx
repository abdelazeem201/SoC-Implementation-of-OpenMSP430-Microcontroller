@ 1 "adrc/adrc.ev"
MACROS



@ 1 "adrc/adrc_variables.ev" 1
/*
@if __VERSION__ < "2003.3.0000"
@error  Hercules version must be later than 2003.3.0000
@endif
*/

VARIABLE string layer_name = "NULL";
VARIABLE double ignoreBlockage = 0;
VARIABLE double readCellView = 0;
VARIABLE double ignoreFRAM_Err = 0;
VARIABLE double ignoreContactCodeSpacing = 0;
VARIABLE double checkCrossHierShort = 0;
VARIABLE double ignoreChildCell = 0;
/* For Router special DRC option */
VARIABLE double router_ignoreSameNetAdjacentViaDRC=0;
VARIABLE double router_parallelLengthNetMode = 0;
/* Variables for metal layers*/
VARIABLE double fatTblSpacingMode = 0;
VARIABLE double fatTblMinEnclosedAreaMode = 0;
VARIABLE double fatWireExtensionMode = 0;
VARIABLE double minEdgeMode = 0;
VARIABLE double minLengthMode = 0;
VARIABLE double parallelLengthMode = 0;
VARIABLE double minWidth = 0;
VARIABLE double maxWidth = 0;
VARIABLE double minArea = 0;
VARIABLE double minEnclosedArea = 0;
VARIABLE double minEnclosedWidth = 0;
VARIABLE double windowSize = 0;
VARIABLE double maxDensity = 0;
VARIABLE double minDensity = 0;
VARIABLE double gradientWindowSize = 0;
VARIABLE double maxGradientDensity = 0;
VARIABLE string layer2_name = "NULL";
VARIABLE double numOfMultiLayer = 0;
VARIABLE double consecutiveWindowSize = 0;
VARIABLE double maxConsecutiveDensity = 0;
VARIABLE double maxNumMinEdge = 0;
VARIABLE double maxTotalMinEdgeLength = 0;
VARIABLE double minEdgeLength = 0;
VARIABLE double minEdgeLength2 = 0;
VARIABLE double minEdgeLength3 = 0;
VARIABLE double minSpacing = 0;
VARIABLE double sameNetMinSpacing = 0;
VARIABLE double sameNetWidthThreshold = 0;
VARIABLE double stub2StubSpacing = 0;
VARIABLE double stubSpacing = 0;
VARIABLE double sideStubExt = 0;
VARIABLE double sideStubThreshold = 0;
VARIABLE double stubThreshold = 0;
VARIABLE double stubRange = 0;
VARIABLE double stubMode = 0;
VARIABLE double fatWireThreshold = 0;
VARIABLE double fatThinMinSpacing = 0;
VARIABLE double fatFatMinSpacing = 0;
VARIABLE double fatTblDimension = 0;
VARIABLE double fatTblThreshold = 0;
VARIABLE double fatTblNextThreshold = 0;
VARIABLE double fatTblThreshold_Start = 0;
VARIABLE double fatTblThreshold_End = 0;
VARIABLE double fatTblThreshold_1 = 0;
VARIABLE double fatTblExtensionRange = 0;
VARIABLE double fatTblParallelLength = 0;
VARIABLE double fatTblSpacing = 0;
VARIABLE double fatTblSpacing_dg = 0;
VARIABLE double fatTblEnclosedArea = 0;
/* Variables for cut layers*/
VARIABLE double cornerSpacingMode = 0;
VARIABLE double cut_size = 0;
VARIABLE double metalLayer1_minSpacing = 0;
VARIABLE double metalLayer2_minSpacing = 0;
VARIABLE double cut_minSpacing = 0;
VARIABLE double cut_sameNetMinSpacing = 0;
VARIABLE double cut_cornerMinSpacing = 0;
VARIABLE double cutBlkg_minSpacing = 0;
VARIABLE double cut_maxNumAdjacentCut = 0;
VARIABLE double cut_adjacentCutRange = 0;
VARIABLE double cut_width = 0;
VARIABLE double cut_lineTblThreshold = 0;
VARIABLE double cut_lineTblNextThreshold = 0;
VARIABLE double cut_lineTblMinSpacing = 0;
VARIABLE double cut_matrixTblThreshold = 0;
VARIABLE double cut_matrixTblNextThreshold = 0;
VARIABLE double cut_matrixTblMinSpacing = 0;
VARIABLE double cut_enclosedCutNeighborRange = 0;
VARIABLE double cut_enclosedCutNumNeighbor = 0;
VARIABLE double cut_enclosedCutMinSpacing = 0;
VARIABLE double cut_enclosedCutToNeighborMinSpacing = 0;
VARIABLE double cut_enclosedCutDiagViaExcluded = 0;
VARIABLE double cut_defaultContactMinSpacing = 0;
VARIABLE double cut_fatContactThreshold1 = 0;
VARIABLE double cut_fatContactThreshold2 = 0;
VARIABLE double cut_fatContactMinSpacing = 0;
VARIABLE double cut_maxStackLevel = 0;
VARIABLE double cut_maxCutSpacing = 0;
VARIABLE double cut_fatTblDimension = 0;
VARIABLE double cut_fatTblThreshold_1 = 0;
VARIABLE double cut_fatTblThreshold_2 = 0;
VARIABLE double cut_fatTblNextThreshold_1 = 0;
VARIABLE double cut_fatTblNextThreshold_2 = 0;
VARIABLE double cut_fatMetalAndMode = 0;
VARIABLE double cut_fatTblExtensionRange = 0;
VARIABLE double cut_fatTblMinCuts = 0;
VARIABLE double cut_fatTblMinSpacing = 0;
VARIABLE double cut_fatTblExtensionMinCuts = 0;
VARIABLE double cut_fatTblExtensionMinSpacing = 0;
/* Variables for Via Farm, Enclosure rule */
VARIABLE double cut_ViaFarm_spacing = 0;
VARIABLE double cut_ViaFarm_maxNum = 0;
VARIABLE double cut_minEnclosure1 = -1;
VARIABLE double cut_minEnclosure2 = -1;
VARIABLE double cut_EOLEnclosure1 = 0;
VARIABLE double cut_EOLEnclosure2 = 0;
VARIABLE double cut_ExtViaFarm_spacing = 0;
VARIABLE double cut_ExtViaFarm_maxNum = 0;
VARIABLE double cut_ExtMinEnclosure1 = -1;
VARIABLE double cut_ExtMinEnclosure2 = -1;
VARIABLE double cut_ExtEOLEnclosure1 = 0;
VARIABLE double cut_ExtEOLEnclosure2 = 0;
/* Variables for diff layers */
VARIABLE double diff_minSpacing = 0;
VARIABLE double diff_netMinSpacing = 0;
VARIABLE double diff_cornerMinSpacing = 0;
VARIABLE double diff_minEnclosure = 0;
VARIABLE double diff_endOfLineMode = 0;
VARIABLE double diff_endOfLineEnclosure = 0;
VARIABLE double diff_not_stackable = 0;
VARIABLE double diff_fatTblViaKeepoutThreshold = 0;
VARIABLE double diff_fatTblViaKeepoutNextThreshold = 0;
VARIABLE double diff_fatTblViaKeepoutMinSize = 0;
VARIABLE double diff_fatTblViaKeepoutEnclosure = 0;
/* spacing to handle via array in stackLevel */
VARIABLE double cut_stackLevelSpacing = 0;
/* Variable for bound box length of polygon */
VARIABLE double minLength = 0;
VARIABLE double maxLength = 0;
/* Fat Poly Contact Rule */
VARIABLE double fatPolyContactRule = 0;
/* protrusion leng rule check */
VARIABLE double fatTblThresh_protru = 0;
VARIABLE double fatTblLength_protru = 0;
VARIABLE double fatTblWidth_protru = 0;
/* Contact code checking */
VARIABLE double viaFarm_maxNum=0;
VARIABLE double viaFarm_spacing=0;
VARIABLE double via_minEnclosure1=-1;
VARIABLE double via_EOLEnclosure1=0;
VARIABLE double via_minEnclosure2=-1;
VARIABLE double via_EOLEnclosure2=0;
/* For temporary usage */
VARIABLE double temporary_1 = 0;
VARIABLE double temporary_2 = 0;
VARIABLE double addEmptyMetalCheck = 1;
VARIABLE double addEmptyViaCheck = 1;
@ 5 "adrc/adrc.ev" 2


HEADER {
	INLIB = COUNT
	OUTLIB = hercules_out
	LAYOUT_PATH = /net/plato.ee.Virginia.EDU/users/amk5vx/synopsys/msp430/icc/work
	BLOCK = openMSP430
	FORMAT = MILKYWAY
	GROUP_DIR = run_details/group
	OUTPUT_FORMAT = MILKYWAY
	MILKYWAY_VIEW_NAME = trash
	OUTPUT_LAYOUT_PATH = run_details
}

DATABASE_OPTIONS {
	USE_REF_CONTROL_FILE = TRUE
	HIER_REF_LIB_MODE = TRUE
	DB_MODE = DRC_BLACK_BOX
	IGNORE_MISSING_CELL = TRUE
	DB_CELL_LIST = {*}
}

OPTIONS {
	MAXIMUM_CELLNAME_LENGTH = 127
}

EXPLODE_OPTIONS {
	EXPLODE_ALL = {*}
}

DRC_OPTIONS {
	DRC_ERROR_BOX = 0.01
}

ERROR_PROPERTY {
	comment_property (51)
}


ASSIGN {
	metal1_pin       (11) {VIEW = FRAM, OBJECT_TYPE = PIN }
	metal1_top       (11) {VIEW = { CEL}}
	metal1_rbkg      (11) {VIEW = FRAM, OBJECT_TYPE = {*,!PIN}}
	metal2_pin       (12) {VIEW = FRAM, OBJECT_TYPE = PIN }
	metal2_top       (12) {VIEW = { CEL}}
	metal2_rbkg      (12) {VIEW = FRAM, OBJECT_TYPE = {*,!PIN}}
	metal3_pin       (13) {VIEW = FRAM, OBJECT_TYPE = PIN }
	metal3_top       (13) {VIEW = { CEL}}
	metal3_rbkg      (13) {VIEW = FRAM, OBJECT_TYPE = {*,!PIN}}
	metal4_pin       (14) {VIEW = FRAM, OBJECT_TYPE = PIN }
	metal4_top       (14) {VIEW = { CEL}}
	metal4_rbkg      (14) {VIEW = FRAM, OBJECT_TYPE = {*,!PIN}}
	metal5_pin       (15) {VIEW = FRAM, OBJECT_TYPE = PIN }
	metal5_top       (15) {VIEW = { CEL}}
	metal5_rbkg      (15) {VIEW = FRAM, OBJECT_TYPE = {*,!PIN}}
	metal6_pin       (16) {VIEW = FRAM, OBJECT_TYPE = PIN }
	metal6_top       (16) {VIEW = { CEL}}
	metal6_rbkg      (16) {VIEW = FRAM, OBJECT_TYPE = {*,!PIN}}
	metal7_pin       (17) {VIEW = FRAM, OBJECT_TYPE = PIN }
	metal7_top       (17) {VIEW = { CEL}}
	metal7_rbkg      (17) {VIEW = FRAM, OBJECT_TYPE = {*,!PIN}}
	metal8_pin       (18) {VIEW = FRAM, OBJECT_TYPE = PIN }
	metal8_top       (18) {VIEW = { CEL}}
	metal8_rbkg      (18) {VIEW = FRAM, OBJECT_TYPE = {*,!PIN}}
	metal9_pin       (19) {VIEW = FRAM, OBJECT_TYPE = PIN }
	metal9_top       (19) {VIEW = { CEL}}
	metal9_rbkg      (19) {VIEW = FRAM, OBJECT_TYPE = {*,!PIN}}

	metal1_blockage  (218)
	metal2_blockage  (219)
	metal3_blockage  (220)
	metal4_blockage  (216)
	metal5_blockage  (239)
	metal6_blockage  (240)
	metal7_blockage  (208)
	metal8_blockage  (210)
	metal9_blockage  (214)

	via1_top         (21)  {VIEW = CEL}
	via1_fram        (21)  {VIEW = FRAM}
	via2_top         (22)  {VIEW = CEL}
	via2_fram        (22)  {VIEW = FRAM}
	via3_top         (23)  {VIEW = CEL}
	via3_fram        (23)  {VIEW = FRAM}
	via4_top         (24)  {VIEW = CEL}
	via4_fram        (24)  {VIEW = FRAM}
	via5_top         (25)  {VIEW = CEL}
	via5_fram        (25)  {VIEW = FRAM}
	via6_top         (26)  {VIEW = CEL}
	via6_fram        (26)  {VIEW = FRAM}
	via7_top         (27)  {VIEW = CEL}
	via7_fram        (27)  {VIEW = FRAM}
	via8_top         (28)  {VIEW = CEL}
	via8_fram        (28)  {VIEW = FRAM}

	via1_blockage    (224)
	via2_blockage    (225)
	via3_blockage    (217)
	via4_blockage    (241)
	via5_blockage    (242)
	via6_blockage    (243)
	via7_blockage    (209)
	via8_blockage    (211)

	PR_BNDY  	         (255)

	empty  	         (255;255)
}

/*Data preparation*/
BOOLEAN metal1_top OR metal1_pin  {  } TEMP=metal1_top
BOOLEAN metal1_top OR metal1_rbkg {  } TEMP=metal1
BOOLEAN metal2_top OR metal2_pin  {  } TEMP=metal2_top
BOOLEAN metal2_top OR metal2_rbkg {  } TEMP=metal2
BOOLEAN metal3_top OR metal3_pin  {  } TEMP=metal3_top
BOOLEAN metal3_top OR metal3_rbkg {  } TEMP=metal3
BOOLEAN metal4_top OR metal4_pin  {  } TEMP=metal4_top
BOOLEAN metal4_top OR metal4_rbkg {  } TEMP=metal4
BOOLEAN metal5_top OR metal5_pin  {  } TEMP=metal5_top
BOOLEAN metal5_top OR metal5_rbkg {  } TEMP=metal5
BOOLEAN metal6_top OR metal6_pin  {  } TEMP=metal6_top
BOOLEAN metal6_top OR metal6_rbkg {  } TEMP=metal6
BOOLEAN metal7_top OR metal7_pin  {  } TEMP=metal7_top
BOOLEAN metal7_top OR metal7_rbkg {  } TEMP=metal7
BOOLEAN metal8_top OR metal8_pin  {  } TEMP=metal8_top
BOOLEAN metal8_top OR metal8_rbkg {  } TEMP=metal8
BOOLEAN metal9_top OR metal9_pin  {  } TEMP=metal9_top
BOOLEAN metal9_top OR metal9_rbkg {  } TEMP=metal9

BOOLEAN via1_top OR via1_fram { } TEMP=via1
BOOLEAN via2_top OR via2_fram { } TEMP=via2
BOOLEAN via3_top OR via3_fram { } TEMP=via3
BOOLEAN via4_top OR via4_fram { } TEMP=via4
BOOLEAN via5_top OR via5_fram { } TEMP=via5
BOOLEAN via6_top OR via6_fram { } TEMP=via6
BOOLEAN via7_top OR via7_fram { } TEMP=via7
BOOLEAN via8_top OR via8_fram { } TEMP=via8

CONNECT {
   metal1 metal2 BY via1
   metal2 metal3 BY via2
   metal3 metal4 BY via3
   metal4 metal5 BY via4
   metal5 metal6 BY via5
   metal6 metal7 BY via6
   metal7 metal8 BY via7
   metal8 metal9 BY via8
} CONNECT_DB = all_layer

SET ignoreBlockage = 1;
SET readCellView = 0;



/*Metal rules*/
SET minEdgeMode = 0;
SET stubMode = 0;

/*metal 1*/
SET layer_name = "Met1";










SET minWidth = 0.14;
SET maxWidth = 1000;
SET minArea = 0.06;
SET minSpacing = 0.14;
SET stub2StubSpacing = 0;

SET fatTblDimension = 0;
@ 1 "adrc/adrc_check_metal.ev" 1
/* Data Preparation */
if (fatTblDimension > 1 || fatWireThreshold > 0 || maxWidth > 0) {
  if (ignoreBlockage) {
      /* Let the real blockage be treated as thin */
      BOOLEAN metal1  NOT metal1_rbkg  {} TEMP=fat_candidate
  } else {
      COPY metal1  {} TEMP=fat_candidate
  }
  COPY fat_candidate {} TEMP=fat_target
}
/*Check width*/
if (minWidth > 0) {
    INTERNAL metal1  { 
        COMMENT = "$layer_name MinWidth  : minimum width = minWidth um" 
        SPACING < minWidth
        POINT_TOUCH = FALSE
    } (11 )
}
 
if (maxWidth > 0) {
    SIZE  fat_candidate {
        COMMENT = "$layer_name MaxWidth  : maximum width = maxWidth um"
 	UNDER_OVER = maxWidth / 2 
    } (11 ) 
}
 
/*Check area*/
if (minArea > 0) {
    AREA metal1  { 
	COMMENT = "$layer_name MinArea   : minimum area = minArea um*um"
	RANGE = [0.0005 * 0.0005 , minArea - 0.0005 * 0.0005 ]
    } (11 )
}
/* check min length of bounding box on polygon */
if (minLength > 0) {
  if (minLengthMode == 1) {
    INTERNAL metal1  {
        SPACING < minLength
        VERTICAL_ONLY = TRUE
        SET_CORNERS_TO_SPACING = FALSE
    } TEMP = ver_short
    BOOLEAN metal1  NOT ver_short { } TEMP = ver_long
    INTERNAL metal1  {
        SPACING < minLength
        HORIZONTAL_ONLY = TRUE
        SET_CORNERS_TO_SPACING = FALSE
    } TEMP = hor_short
    BOOLEAN metal1  NOT hor_short { } TEMP = hor_long
    SELECT CUT_LAYER1 INSIDE ver_long { } TEMP = good_cut
    BOOLEAN CUT_LAYER1 NOT good_cut { } TEMP = fail_cut_1
    SELECT fail_cut_1 INSIDE hor_long { } TEMP = good_cut
    BOOLEAN fail_cut_1 NOT good_cut { } TEMP = fail_cut_1
    SELECT CUT_LAYER2 INSIDE ver_long { } TEMP = good_cut
    BOOLEAN CUT_LAYER2 NOT good_cut { } TEMP = fail_cut_2
    SELECT fail_cut_2 INSIDE hor_long { } TEMP = good_cut
    BOOLEAN fail_cut_2 NOT good_cut { } TEMP = fail_cut_2
    BOOLEAN fail_cut_1 OR fail_cut_2 { } TEMP = fail_cut
    BOOLEAN hor_short NOT ver_long { } TEMP = hor_short
    BOOLEAN ver_short NOT hor_long { } TEMP = ver_short
    SELECT ver_short INTERACT fail_cut { } TEMP = ver_fail
    SELECT hor_short INTERACT fail_cut { } TEMP = hor_fail
    BOOLEAN ver_fail OR hor_fail { } TEMP = all_fail
    INTERNAL all_fail {
        COMMENT = "$layer_name MinLength : minimum length = minLength um"
        SPACING < minLength
        VERTICAL_ONLY = TRUE
        SET_CORNERS_TO_SPACING = FALSE
    } (11 )
  } else {
    POLYGON_FEATURES metal1  {
      COMMENT = "$layer_name MinLength : minimum length = minLength um"
      EQUATIONS {
        vnum = EV_VNUM_IN;
        if ( vnum > 0) {
	  bdLeft = EV_VXCOORD_IN[0];
	  bdRight = EV_VXCOORD_IN[0];
	  bdBottom = EV_VYCOORD_IN[0];
	  bdTop = EV_VYCOORD_IN[0];
          FOR (i = 1; i < vnum; i++) {
	    if (bdLeft > EV_VXCOORD_IN[i]) bdLeft = EV_VXCOORD_IN[i];
            else if (bdRight < EV_VXCOORD_IN[i]) bdRight = EV_VXCOORD_IN[i];
	    if (bdBottom > EV_VYCOORD_IN[i]) bdBottom = EV_VYCOORD_IN[i];
            else if (bdTop < EV_VYCOORD_IN[i]) bdTop = EV_VYCOORD_IN[i];
          }
	  if ( (bdRight - bdLeft) < minLength &&
	       (bdTop - bdBottom) < minLength) {
	    FOR (i = 0; i < vnum; i++) {
              EV_VXCOORD_OUT[i] = EV_VXCOORD_IN[i];
	      EV_VYCOORD_OUT[i] = EV_VYCOORD_IN[i];
            }
	    EV_VNUM_OUT = vnum;
	    EV_SAVE_POLYGON();
          }
        }
      }
    } (11 ) 
  }
  SET minLength = 0;
}
/* check max length of bounding box on polygon */
if (maxLength > 0) {
  POLYGON_FEATURES metal1  {
    COMMENT = "$layer_name MaxLength : maximum length = maxLength um"
    EQUATIONS {
      vnum = EV_VNUM_IN;
      if ( vnum > 0) {
	bdLeft = EV_VXCOORD_IN[0];
	bdRight = EV_VXCOORD_IN[0];
	bdBottom = EV_VYCOORD_IN[0];
	bdTop = EV_VYCOORD_IN[0];
        FOR (i = 1; i < vnum; i++) {
	  if (bdLeft > EV_VXCOORD_IN[i]) bdLeft = EV_VXCOORD_IN[i];
          else if (bdRight < EV_VXCOORD_IN[i]) bdRight = EV_VXCOORD_IN[i];
	  if (bdBottom > EV_VYCOORD_IN[i]) bdBottom = EV_VYCOORD_IN[i];
          else if (bdTop < EV_VYCOORD_IN[i]) bdTop = EV_VYCOORD_IN[i];
        }
	if ( (bdRight - bdLeft + bdTop - bdBottom) > maxLength ) {
          EV_VXCOORD_OUT[0] = bdLeft;
	  EV_VYCOORD_OUT[0] = bdBottom;
          EV_VXCOORD_OUT[1] = bdLeft;
	  EV_VYCOORD_OUT[1] = bdTop;
          EV_VXCOORD_OUT[2] = bdRight;
	  EV_VYCOORD_OUT[2] = bdTop;
          EV_VXCOORD_OUT[3] = bdRight;
	  EV_VYCOORD_OUT[3] = bdBottom;
          EV_VXCOORD_OUT[4] = bdLeft;
	  EV_VYCOORD_OUT[4] = bdBottom;
	  EV_VNUM_OUT = 5;
	  EV_SAVE_POLYGON();
        }
      }
    }
  } (11 ) 
  SET maxLength = 0;
}
 
/*Check enclosed area*/
if (minEnclosedArea > 0) {
    SELECT metal1  INSIDE_HOLE {
        INNER_HOLE_ONLY
    } TEMP = holes
    BOOLEAN holes NOT metal1  { } TEMP = holes
 
    AREA holes {
        COMMENT = "$layer_name EnclsArea : minimum enclosed area = minEnclosedArea um*um"
        RANGE = [0.0005 * 0.0005 , minEnclosedArea - 0.0005 * 0.0005 ]
    } (11 )
    /* check min length of bounding box on polygon */
    if (minEnclosedWidth > 0) {
      POLYGON_FEATURES holes {
        COMMENT = "$layer_name EnclsWidth: minimum enclosed Width = minEnclosedWidth um"
        EQUATIONS {
          vnum = EV_VNUM_IN;
          if ( vnum > 0) {
            bdLeft = EV_VXCOORD_IN[0];
            bdRight = EV_VXCOORD_IN[0];
            bdBottom = EV_VYCOORD_IN[0];
            bdTop = EV_VYCOORD_IN[0];
            FOR (i = 1; i < vnum; i++) {
              if (bdLeft > EV_VXCOORD_IN[i]) bdLeft = EV_VXCOORD_IN[i];
              else if (bdRight < EV_VXCOORD_IN[i]) bdRight = EV_VXCOORD_IN[i];
              if (bdBottom > EV_VYCOORD_IN[i]) bdBottom = EV_VYCOORD_IN[i];
              else if (bdTop < EV_VYCOORD_IN[i]) bdTop = EV_VYCOORD_IN[i];
            }
            if ( (bdRight - bdLeft) < minEnclosedWidth &&
                 (bdTop - bdBottom) < minEnclosedWidth) {
              FOR (i = 0; i < vnum; i++) {
                EV_VXCOORD_OUT[i] = EV_VXCOORD_IN[i];
                EV_VYCOORD_OUT[i] = EV_VYCOORD_IN[i];
              }
              EV_VNUM_OUT = vnum;
              EV_SAVE_POLYGON();
            }
          }
        }
      } (11 ) 
    }
}
 
/*check special notch rule*/
if ((minEdgeLength2 > 0.0005  && minEdgeLength3 > 0.0005 ) || minEdgeMode==2) {
  if (minEdgeMode==2) {
    SET minEdgeLength3 = minEdgeLength ;
  }
  NOTCH metal1  {
     SPACING < minEdgeLength3
     SET_CORNERS_TO_SPACING=FALSE
     PARALLEL = TRUE
     OUTPUT_EDGES = TRUE
  } TEMP = notch_vectors
  SELECT_VECTOR notch_vectors {
     LENGTH_RANGE = [0.0005 , minEdgeLength2 - 0.0005 ]
  } TEMP = short_edges
  EXTERNAL short_edges metal1  {
     SPACING < minEdgeLength3
     SET_CORNERS_TO_SPACING=FALSE
     PARALLEL = TRUE
  } TEMP = notch_err
  /* Choose the real U-shaped notch */
  SIZE notch_err { OVERSIZE = 0.001 *10 } TEMP = neighbors 
  BOOLEAN neighbors AND metal1  { } TEMP = neighbors
  VERTEX neighbors { 
     CONCAVE = TRUE
     CONVEX = TRUE
     SIZE = 0.001 
  } TEMP = corners
  SELECT_EDGE neighbors INTERACT notch_err { } TEMP = target_edges
  BOOLEAN target_edges NOT corners { } TEMP = target_edges
  VERTEX neighbors { 
     CONCAVE = TRUE
     SIZE = 2* 0.001 
  } TEMP = corners
  SELECT target_edges INTERACT corners { RANGE = [2, 2] } TEMP=target_edges
  SELECT notch_err INTERACT target_edges {
     COMMENT = "$layer_name SpeclNotch: sameNetSp = minEdgeLength3 um (sideLen minEdgeLength2 um)" 
  } (11 )
}
/*check consecutive short edges*/
if (minEdgeLength > 0.0005  && minEdgeMode != 2) { 
  INTERNAL metal1_top  {
     SEGMENT < minEdgeLength
     FLAG_ACUTE_ANGLE = FALSE
     FLAG_ACUTE_EDGE = FALSE
     OUTPUT_EDGES = TRUE
  } TEMP = short_edges
  if ((minEdgeMode == 0 && maxTotalMinEdgeLength>0) || maxNumMinEdge > 0) {
    SET temporary_1 = 0.001 *2;
    SET temporary_2 = 2*temporary_1+ 0.0005 ;
    SELECT metal1_top  INTERACT short_edges { } TEMP = target_top
    CLASSIFY_EDGES target_top {
       LENGTH = temporary_1
       DMIN   = temporary_2
       INSIDE_CORNER  TEMP = inside_corner_edges
       OUTSIDE_CORNER TEMP = outside_corner_edges
       REMAINDER      TEMP = remainder_edges
    }
    if (minEdgeMode == 0 && (maxNumMinEdge>0 || maxTotalMinEdgeLength > 0)) {
       SELECT short_edges ENCLOSING inside_corner_edges { } TEMP = short_edges
    }
  }
  if (maxTotalMinEdgeLength > 0) {
    LENGTH short_edges {
       RANGE = [maxTotalMinEdgeLength + 0.0005 , 9999999999 ]
    } TEMP = max_length_err
    /* Work around: translate polygons into dimensional check output */
    SIZE max_length_err { OVERSIZE = 2* 0.001  } TEMP = max_length_err
    INTERNAL max_length_err {
       SPACING < 3* 0.001 
       SET_CORNERS_TO_SPACING=FALSE
       COMMENT = "$layer_name MinEdgeLen: maximum total length ( minEdgeLength um)= maxTotalMinEdgeLength um"
    } (11 )
  }
  if (maxTotalMinEdgeLength == 0 || maxNumMinEdge > 0) {
    if (maxNumMinEdge==0)  {
       COPY short_edges {} TEMP=max_edge_err
    } else {
       SIZE short_edges {
         VSIZE_HEAD = - 0.001 
        VSIZE_TAIL = - 0.001 
       } TEMP = short_edges
       SIZE short_edges {
          OVERSIZE = 5* 0.001 
          SIZE_ENDPOINTS = FALSE
       } TEMP = short_contours
       SELECT short_contours ENCLOSING remainder_edges {
          RANGE = [maxNumMinEdge + 1, 9999999999 ]
       } TEMP = short_contours
       SELECT short_edges INSIDE short_contours { } TEMP=max_edge_err
    }
    /* Work around: translate polygons into dimensional check output */
    SIZE max_edge_err { OVERSIZE = 2* 0.001  } TEMP = max_edge_error
    INTERNAL max_edge_error {
       SPACING < 3* 0.001 
       SET_CORNERS_TO_SPACING=FALSE
       COMMENT = "$layer_name MinEdgeLen: maximum number of consecutive short edges ( minEdgeLength um)= maxNumMinEdge"
    } (11 ) 
  }
}
 
/*check basic spacing*/
if (sameNetMinSpacing > 0 && sameNetMinSpacing != minSpacing) {
  if (sameNetMinSpacing > minSpacing) {
    /* Special condition for U-shaped Metal spacing rule */
    NOTCH metal1_pin  {
        SPACING < sameNetMinSpacing
        BOX_CORNER = FALSE 
        SET_CORNERS_TO_SPACING=FALSE
        NON_PARALLEL = TRUE
        OUTPUT_EDGES = TRUE
    } TEMP = errs_to_be_waived
    NOTCH metal1_top  {
	SPACING < sameNetMinSpacing
	BOX_CORNER = FALSE 
        SET_CORNERS_TO_SPACING=FALSE
	NON_PARALLEL = TRUE
        OUTPUT_EDGES = TRUE
    } TEMP = all_errs
    BOOLEAN all_errs NOT errs_to_be_waived { } TEMP=err_edge
    EXTERNAL err_edge metal1_top  {
	SPACING < sameNetMinSpacing
	BOX_CORNER = FALSE 
        SET_CORNERS_TO_SPACING=FALSE
	NON_PARALLEL = TRUE
    } TEMP = notch_err
    SIZE notch_err { OVERSIZE = 0.001 *10 } TEMP = neighbors
    BOOLEAN neighbors AND metal1_top  { } TEMP = neighbors
    VERTEX neighbors { 
       CONCAVE = TRUE
       CONVEX = TRUE
       SIZE = 0.001 
    } TEMP = corners
    SELECT_EDGE neighbors INTERACT notch_err { } TEMP = target_edges
    BOOLEAN target_edges AND notch_err { } TEMP = target_edges
    BOOLEAN target_edges NOT corners { } TEMP = target_edges
    VERTEX neighbors {
       CONCAVE = TRUE
       SIZE = 2* 0.001 
    } TEMP = corners
    SELECT target_edges INTERACT corners { RANGE = [2, 2] } TEMP = target_edges
    SELECT notch_err TOUCHING target_edges {
      COMMENT = "$layer_name U-ShpNotch: U-shape notch minimum spacing = sameNetMinSpacing um" 
    } (11 )
  } else {
    NOTCH metal1  {
        COMMENT = "$layer_name SameNetSpc: same-net minimum spacing = sameNetMinSpacing um" 
	SPACING < sameNetMinSpacing
	BOX_CORNER = FALSE 
	NON_PARALLEL = TRUE
    } (11 )
  }
  if (minSpacing > 0) {
    if (stubMode == 0 && stubSpacing > 0 && stubSpacing < minSpacing) {
	EXTERNAL metal1  {
	    COMMENT = "$layer_name Spacing   : minimum spacing = minSpacing um"
            LONGEDGE > stubThreshold + 0.0005 
	    LONGEDGE_TO_EDGE < minSpacing
	    SPACING <= 0
	    BOX_CORNER = FALSE 
	    NON_PARALLEL = TRUE
            POINT_TOUCH = TRUE
            CHECK_SAME_POLYGON = TRUE 
	} (11 )
    } else {
        EXTERNAL metal1  {
	    COMMENT = "$layer_name Spacing   : minimum spacing = minSpacing um" 
	    SPACING < minSpacing
	    BOX_CORNER = FALSE 
	    NON_PARALLEL = TRUE
            POINT_TOUCH = TRUE
	    CHECK_SAME_POLYGON = FALSE
        } (11 )
    }
  }
} else {
  if (minSpacing > 0) {
    if (stubMode == 0 && stubSpacing > 0 && stubSpacing < minSpacing) {
        EXTERNAL metal1  {
            COMMENT = "$layer_name Spacing   : minimum spacing = minSpacing um"
            LONGEDGE > stubThreshold + 0.0005  
            LONGEDGE_TO_EDGE < minSpacing
            SPACING <= 0 
            BOX_CORNER = FALSE 
            NON_PARALLEL = TRUE
            POINT_TOUCH = TRUE
            CHECK_SAME_POLYGON = TRUE 
        } (11 )
    } else {
        EXTERNAL metal1  {
	    COMMENT = "$layer_name Spacing   : minimum spacing = minSpacing um" 
            SPACING < minSpacing
	    BOX_CORNER = FALSE 
	    NON_PARALLEL = TRUE
	    POINT_TOUCH = TRUE
	    CHECK_SAME_POLYGON = TRUE 
        } (11 )
    }
  }
}
 
/*check dogbone */
if (sameNetMinSpacing > 0 && sameNetWidthThreshold) {
  NOTCH metal1  {
    SPACING < sameNetMinSpacing
    BOX_CORNER = FALSE 
    NON_PARALLEL = TRUE
  } TEMP = dog_bone
 
  if (!layer_empty(dog_bone)) {
    SIZE dog_bone {EDGESIZE = sameNetWidthThreshold} TEMP = dog_ext
    BOOLEAN dog_ext NOT dog_bone {} TEMP = dog_ext
    BOOLEAN dog_ext AND metal1  {} TEMP = dog_ext
    if (!layer_empty(dog_ext)) {
      SELECT dog_ext EDGE_TOUCH dog_bone { OUTSIDE RANGE = [1, 9999999999 ] } TEMP = dog_ext
      NOTCH metal1  {
        SPACING < sameNetMinSpacing
        BOX_CORNER = FALSE 
        NON_PARALLEL = TRUE
	OUTPUT_EDGES = TRUE
      } TEMP = dog_bone
      SELECT dog_ext OUTSIDE dog_bone {} TEMP = dog_ext
      INTERNAL dog_ext {
	COMMENT = "$layer_name dogBone   : notch spacing = sameNetMinSpacing um width sameNetWidthThreshold um" 
	SPACING < sameNetWidthThreshold
      } (11 )
    }
  }
}
/*check basic fat spacing*/
if (fatWireThreshold > 0 && fatTblDimension == 0) {
    SIZE fat_candidate { UNDER_OVER = fatWireThreshold / 2.0 - 0.0005  } TEMP = m_fat
    BOOLEAN m_fat AND metal1  {  } TEMP = m_fat
    BOOLEAN metal1  NOT m_fat {  } TEMP = m_thin
    if (ignoreBlockage == 0) {
        /* the blockages on the metal_blockage layer are treated as thin blockages */
        BOOLEAN m_thin OR metal1_blockage  {  } TEMP = m_thin
    }
 
    if (fatFatMinSpacing > 0) {
	EXTERNAL m_fat {
	    COMMENT = "$layer_name FatWireSpc: fat & fat ( fatWireThreshold um) minimum spacing = fatFatMinSpacing um"
	    SPACING < fatFatMinSpacing
	    BOX_CORNER = FALSE 
	    NON_PARALLEL = TRUE
	    POINT_TOUCH = FALSE
	    CHECK_SAME_POLYGON = TRUE 
       } (11 )
    }
 
    if (fatThinMinSpacing > 0) {
	EXTERNAL m_fat m_thin {
	    COMMENT = "$layer_name FatWireSpc: fat & thin ( fatWireThreshold um) minimum spacing fatThinMinSpacing um"
	    SPACING < fatThinMinSpacing
 	    BOX_CORNER = FALSE 
	    NON_PARALLEL = TRUE
	    POINT_TOUCH = FALSE
        } (11 )
    }
}
 
/*check thin blockage spacing*/
if (minSpacing > 0 && ignoreBlockage == 0) {
    if (!layer_empty (metal1_blockage )) {
	EXTERNAL metal1_blockage  metal1  {
	    COMMENT = "$layer_name Spacing   : metal & thin blockage minimum spacing = minSpacing um"
	    SPACING < minSpacing
	    BOX_CORNER = FALSE 
	    NON_PARALLEL = TRUE
	    POINT_TOUCH = TRUE
            TOUCH = TRUE
        } (11 )
    }
}
/*check blockage overlap*/
/*check shorts between top_level routing and fram_blockages*/
if (minSpacing>0 || checkCrossHierShort>0) {
   if (ignoreBlockage == 0) {
      BOOLEAN metal1_blockage  or metal1_rbkg  {} TEMP=all_blockage
   } else {
      COPY metal1_rbkg  {} TEMP=all_blockage
   }
   BOOLEAN all_blockage AND metal1_top  {} TEMP = overlap_shape1
   EXTERNAL all_blockage metal1_top  {
      SPACING <= 0
      TOUCH = TRUE
   } TEMP = overlap_shape2
   if (checkCrossHierShort>0) {
      BOOLEAN overlap_shape1 OR overlap_shape2 {
         COMMENT = "$layer_name Short Cross Hierarchy"
      } (11 )
   } else {
      BOOLEAN overlap_shape1 OR overlap_shape2 {
         COMMENT = "$layer_name Overlap   : metal & blockage overlap"
      } (11 )
   }
}
 
if (fatPolyContactRule > 0) {
  /* Fat Poly Contact Rule: not new fat wire formed */
  if (readCellView > 0) {
     SIZE metal1 { UNDER_OVER = fatPolyContactRule / 2.0 - 0.0005  } TEMP = fat
     BOOLEAN fat AND metal1 {  } TEMP = fat 
  } else {
     SIZE metal1_top { UNDER_OVER = fatPolyContactRule / 2.0 - 0.0005  } TEMP = fat
     BOOLEAN fat AND metal1_top {  } TEMP = fat 
  }
  SIZE metal1_pin { UNDER_OVER = fatPolyContactRule / 2.0 - 0.0005  } TEMP = fat_pin
  BOOLEAN fat_pin AND metal1_pin {  } TEMP = fat_pin
  BOOLEAN fat NOT fat_pin {
    COMMENT = "$layer_name FatPolyContactRule: fatPolyContactRule um" 
  } (11 )
}
/* Special End-of-Line Spacing Rule */
if (stubMode == 0 && stubSpacing > 0 && stubSpacing < minSpacing) {
  EXTERNAL metal1  {
     COMMENT = "$layer_name specEoLSpc: spacing= stubSpacing um (mode = 0)"
     LONGEDGE > stubThreshold + 0.0005 
     LONGEDGE_TO_EDGE <= 0 
     SPACING < stubSpacing 
     SET_CORNERS_TO_SPACING = FALSE
     PARALLEL_POINT_PROJECTION = FALSE
  } (11 )
} else if (stubMode > 0 && stubSpacing > minSpacing) {
  if (stubMode == 4) {
     INTERNAL metal1  {
        SEGMENT[90,90] < stubThreshold
        OUTPUT_EDGES = TRUE
     } TEMP = end_of_line
  } else {
     INTERNAL metal1  {
        SEGMENT[90,90] <= stubThreshold
        OUTPUT_EDGES = TRUE
     } TEMP = end_of_line
  }
  /* Quick filter to reduce the size of possible end of line */
  if (sideStubExt > 0) {
    SIZE end_of_line {
       VSIZE_HEAD = sideStubExt
       VSIZE_TAIL = sideStubExt
       OUTPUT_EDGES = TRUE
    } TEMP = eol_ext
  } else {
    COPY end_of_line { } TEMP=eol_ext
  }
  if (stub2StubSpacing > stubSpacing) {
     SET temporary_1 = stub2StubSpacing;
  } else {
     SET temporary_1 = stubSpacing; 
  }
  EXTERNAL eol_ext metal1  {
     SPACING < temporary_1
     TOUCH = TRUE
     OVERLAP = TRUE 
     SET_CORNERS_TO_SPACING = FALSE
     PARALLEL_POINT_PROJECTION = FALSE
     OUTPUT_EDGES = TRUE
  } TEMP=err_edge
  SELECT eol_ext INTERACT err_edge { } TEMP=eol_ext
  SELECT end_of_line INTERACT eol_ext { } TEMP=end_of_line 
  /* Reduce the size of METAL_LAYER */
  if (stubMode==3) {
     SIZE end_of_line {
        VSIZE_HEAD = stubSpacing 
        VSIZE_TAIL = stubSpacing 
        VSIZE_INSIDE = sideStubThreshold
        VSIZE_OUTSIDE = stubSpacing
     } TEMP = eol_filter 
  } else {
     if (stubMode == 1 && stubRange > 0) {
        SIZE end_of_line {
           VSIZE_HEAD = stubSpacing- 0.0005 
           VSIZE_TAIL = stubSpacing- 0.0005 
           VSIZE_OUTSIDE = stubSpacing- 0.0005 
        } TEMP = eol_filter
     } else {
        SIZE end_of_line {
           VSIZE_HEAD = stubSpacing- 0.0005 
           VSIZE_TAIL = stubSpacing- 0.0005 
           VSIZE_INSIDE = sideStubThreshold- 0.0005 
           VSIZE_OUTSIDE = stubSpacing- 0.0005 
        } TEMP = eol_filter
     }
  }
  SELECT metal1  INTERACT eol_filter { } TEMP=target_top
  /* Get the side edges and the whole eol of line set */
  SELECT_EDGE target_top INTERACT end_of_line { 
    POINT_TOUCH = TRUE
  } TEMP = eol_set
  VERTEX target_top { 
     CONCAVE = TRUE 
     CONVEX = TRUE
     SIZE = 0.001 
  } TEMP = corners
  SELECT corners OUTSIDE end_of_line {} TEMP =corners 
  BOOLEAN eol_set NOT corners { } TEMP=eol_set
  BOOLEAN eol_set NOT end_of_line { } TEMP=side_edge
  /* find out the real end of line */
  if (stubRange > 0) {
     if (stubMode == 1) {
         COPY side_edge { } TEMP = all_side_edge
         LENGTH side_edge { SPACING <= stubRange- 0.0005  } TEMP=side_edge
     } else {
         LENGTH side_edge { SPACING < stubRange- 0.001  } TEMP=eol_filter
         BOOLEAN side_edge NOT eol_filter { } TEMP=side_edge
     }
     SELECT end_of_line INTERACT side_edge { RANGE = [1,2] } TEMP = end_of_line
  } 
  if (stubMode == 1) {
    if (stub2StubSpacing > 0) {
       if (sideStubExt < 0) {
          SIZE end_of_line {
            VSIZE_HEAD = sideStubExt / 2
            VSIZE_TAIL = sideStubExt / 2
            OUTPUT_EDGES = TRUE
          } TEMP = eol_ext_tip
	 
          EXTERNAL eol_ext_tip {
            COMMENT = "$layer_name specEoLSpc: stub2Stubspacing= stub2StubSpacing um (mode = 1)"
            SPACING < stub2StubSpacing
            SET_CORNERS_TO_SPACING = FALSE
            PARALLEL_POINT_PROJECTION = TRUE
          } (11 )
       } else {
          EXTERNAL end_of_line {
            COMMENT = "$layer_name specEoLSpc: stub2Stubspacing= stub2StubSpacing um (mode = 1)"
            SPACING < stub2StubSpacing
            SET_CORNERS_TO_SPACING = FALSE
            PARALLEL_POINT_PROJECTION = FALSE
          } (11 )
       }
    }
    if (stubRange > 0) {
       SIZE end_of_line {
         VSIZE_INSIDE = 0.001 
       } TEMP = eol_poly
       SELECT_EDGE eol_poly TOUCHING target_top { } TEMP=eol_edge
       EXTERNAL eol_edge target_top {
         COMMENT = "$layer_name specEoLSpc: spacing= stubSpacing um (mode = 1)"
         CONVEX_TO_CONVEX < stubSpacing
         CONVEX_TO_CONVEX [POINT_PROJECTION] < stubSpacing
         CONVEX_TO_EDGE < stubSpacing
         CONCAVE_TO_CONVEX < stubSpacing
         LONGEDGE > 0.001 
         LONGEDGE_TO_EDGE < stubSpacing
         SPACING <= 0
         SET_CORNERS_TO_SPACING = TRUE
         PARALLEL_POINT_PROJECTION = TRUE
       } (11 )
       SELECT all_side_edge INTERACT end_of_line { } TEMP = side_edge
       SIZE side_edge {
         VSIZE_HEAD = 0.001 
         VSIZE_TAIL = 0.001 
       } TEMP = side_edge_ext
       BOOLEAN side_edge_ext NOT side_edge { } TEMP = side_edge_ext
       SELECT side_edge_ext INTERACT end_of_line { } TEMP = side_edge_ext
       EXTERNAL side_edge_ext target_top {
         COMMENT = "$layer_name specEoLSpc: spacing= stubSpacing um (mode = 1)"
         SPACING < stubSpacing
         SET_CORNERS_TO_SPACING = FALSE
         PARALLEL_POINT_PROJECTION = FALSE
       } (11 )
    } else {
       if (stub2StubSpacing > 0) {
         VECTORIZE target_top {
            DIRECTED=TRUE
         } TEMP=target_edges
         BOOLEAN target_edges NOT end_of_line { } TEMP = target_edges
         EXTERNAL end_of_line target_edges {
            COMMENT = "$layer_name specEoLSpc: spacing= stubSpacing um (mode = 1)"
            SPACING < stubSpacing
            TOUCH=TRUE
            OVERLAP=TRUE
            SET_CORNERS_TO_SPACING=FALSE
            PARALLEL_POINT_PROJECTION=FALSE
         } (11 )
       } else {
         if (sideStubExt > 0) {
            SIZE end_of_line {
               VSIZE_HEAD = sideStubExt
               VSIZE_TAIL = sideStubExt
               OUTPUT_EDGES = TRUE
            } TEMP = end_of_line
            EXTERNAL end_of_line target_top {
               COMMENT = "$layer_name specEoLSpc: spacing= stubSpacing ,crnKeepOut= sideStubExt um (mode = 1)"
               SPACING < stubSpacing
               TOUCH=TRUE
               OVERLAP=TRUE
               SET_CORNERS_TO_SPACING=FALSE
               PARALLEL_POINT_PROJECTION=FALSE
            } (11 )
         } else {
            EXTERNAL end_of_line target_top {
               COMMENT = "$layer_name specEoLSpc: spacing= stubSpacing um (mode = 1)"
               SPACING < stubSpacing
               TOUCH=TRUE
               OVERLAP=TRUE
               SET_CORNERS_TO_SPACING=FALSE
               PARALLEL_POINT_PROJECTION=FALSE
            } (11 )
         }
       }
    }
  } else { /* stubMode == 2,3,4 */
    /* stubMode 2 eol classify and reduction */
    if (stubMode !=3 && sideStubExt > 0) {
      if (stubMode == 4) {
        SIZE end_of_line {
           VSIZE_HEAD = sideStubExt
           VSIZE_TAIL = sideStubExt
           OUTPUT_EDGES = TRUE
        } TEMP = eol_ext
        EXTERNAL eol_ext target_top {
           SPACING < stubSpacing
           SET_CORNERS_TO_SPACING=FALSE
           PARALLEL_POINT_PROJECTION=FALSE
           OUTPUT_EDGES = TRUE
        } TEMP=err_edge
        SELECT eol_ext INTERACT err_edge { } TEMP=eol_ext
      } else {
        EXTERNAL end_of_line target_top {
           SPACING < stubSpacing
           SET_CORNERS_TO_SPACING=FALSE
           PARALLEL_POINT_PROJECTION=FALSE
           OUTPUT_EDGES = TRUE
        } TEMP=err_edge
        SELECT end_of_line INTERACT err_edge { } TEMP=eol_body
        SIZE end_of_line {
           VSIZE_HEAD = sideStubExt
           VSIZE_TAIL = sideStubExt
           OUTPUT_EDGES = TRUE
        } TEMP = eol_ext
        BOOLEAN eol_ext NOT end_of_line {} TEMP=eol_ext
        EXTERNAL eol_ext target_top {
           SPACING < stubSpacing
           SET_CORNERS_TO_SPACING=FALSE
           PARALLEL_POINT_PROJECTION=FALSE
           OUTPUT_EDGES = TRUE
        } TEMP=err_edge
        SELECT eol_ext INTERACT err_edge { } TEMP=eol_ext
        BOOLEAN eol_body OR eol_ext { } TEMP=eol_ext
      } 
    } else {
      COPY end_of_line { } TEMP=eol_ext
    }
    SELECT side_edge INTERACT eol_ext { } TEMP=side_edge
    SIZE eol_ext {
       VSIZE_INSIDE = sideStubThreshold 
       VSIZE_OUTSIDE = sideStubExt
    } TEMP = eol_range
    if (sideStubExt > 0) {
       SIZE side_edge {
          VSIZE_HEAD = sideStubExt
          VSIZE_TAIL = sideStubExt
          OUTPUT_EDGES = TRUE
       } TEMP = check_edge
    } else {
       COPY side_edge { } TEMP = check_edge
    }
    BOOLEAN check_edge AND eol_range { } TEMP=check_edge
    EXTERNAL check_edge target_top {
       SPACING < temporary_1
       SET_CORNERS_TO_SPACING = FALSE
       SHADOW_OTHER_LAYER = TRUE
       PARALLEL_POINT_PROJECTION = FALSE
       OUTPUT_EDGES = TRUE
    } TEMP=err_edge
    if (0 && stubMode!=4) { /* Temporarily do not check mode 2,3 side edge length */
       LENGTH side_edge { SPACING < stubSpacing- 0.0005 *2 } TEMP=err_edge_1
       BOOLEAN err_edge OR err_edge_1 { } TEMP=err_edge
    }
    SELECT check_edge INTERACT err_edge { } TEMP=side_edge
    if (stubMode!=3) {
       SELECT eol_ext INTERACT side_edge {} TEMP=err_eol
       EXTERNAL err_eol target_top {
          COMMENT = "$layer_name specEoLSpc: spacing= stubSpacing ,crnKeepOut= sideStubExt um (mode = stubMode )"
          SPACING < temporary_1
          PARALLEL_POINT_PROJECTION=FALSE
          SET_CORNERS_TO_SPACING=FALSE
       } (11 )
    } else { /* stubMode == 3 */
       SELECT eol_ext INTERACT side_edge { RANGE = [2, 2] } TEMP=err_eol
       EXTERNAL err_eol target_top {
          COMMENT = "$layer_name specEoLSpc: spacing= stubSpacing um (mode = 3)"
          SPACING < temporary_1
          PARALLEL_POINT_PROJECTION=FALSE
          SET_CORNERS_TO_SPACING=FALSE
       } (11 )
    }
  }
} /* stubMode > 0, not aligned */
/* Avoid empty optimization result parsing error */
if (addEmptyMetalCheck) {
   BOOLEAN empty OR empty {
      COMMENT = "$layer_name Empty: Dummy Output"
   } (11 )
   SET addEmptyMetalCheck=0;
}
/* reset variables */


 
SET minWidth = 0;
SET maxWidth = 0;
SET minArea = 0;
SET minEnclosedArea = 0;
SET minSpacing = 0;
SET sameNetMinSpacing = 0;
SET maxNumMinEdge = 0;
SET maxTotalMinEdgeLength = 0;
SET minEdgeLength = 0;
SET minEdgeLength2 = 0;
SET minEdgeLength3 = 0;
SET stubRange = 0;
SET stubSpacing = 0;
SET stub2StubSpacing = 0;
SET sideStubExt = 0;
SET sideStubThreshold = 0;
SET stubThreshold = 0;
SET fatPolyContactRule = 0;
SET fatWireThreshold = 0;
SET fatThinMinSpacing = 0;
SET fatFatMinSpacing = 0;
SET fatTblDimension = 0;
@ 182 "adrc/adrc.ev" 2









/*metal 2*/
SET layer_name = "Met2";










SET minWidth = 0.16;
SET maxWidth = 1000;
SET minArea = 0.07;
SET minSpacing = 0.16;
SET stub2StubSpacing = 0;

SET fatTblDimension = 0;
@ 1 "adrc/adrc_check_metal.ev" 1
/* Data Preparation */
if (fatTblDimension > 1 || fatWireThreshold > 0 || maxWidth > 0) {
  if (ignoreBlockage) {
      /* Let the real blockage be treated as thin */
      BOOLEAN metal2  NOT metal2_rbkg  {} TEMP=fat_candidate
  } else {
      COPY metal2  {} TEMP=fat_candidate
  }
  COPY fat_candidate {} TEMP=fat_target
}
/*Check width*/
if (minWidth > 0) {
    INTERNAL metal2  { 
        COMMENT = "$layer_name MinWidth  : minimum width = minWidth um" 
        SPACING < minWidth
        POINT_TOUCH = FALSE
    } (12 )
}
 
if (maxWidth > 0) {
    SIZE  fat_candidate {
        COMMENT = "$layer_name MaxWidth  : maximum width = maxWidth um"
 	UNDER_OVER = maxWidth / 2 
    } (12 ) 
}
 
/*Check area*/
if (minArea > 0) {
    AREA metal2  { 
	COMMENT = "$layer_name MinArea   : minimum area = minArea um*um"
	RANGE = [0.0005 * 0.0005 , minArea - 0.0005 * 0.0005 ]
    } (12 )
}
/* check min length of bounding box on polygon */
if (minLength > 0) {
  if (minLengthMode == 1) {
    INTERNAL metal2  {
        SPACING < minLength
        VERTICAL_ONLY = TRUE
        SET_CORNERS_TO_SPACING = FALSE
    } TEMP = ver_short
    BOOLEAN metal2  NOT ver_short { } TEMP = ver_long
    INTERNAL metal2  {
        SPACING < minLength
        HORIZONTAL_ONLY = TRUE
        SET_CORNERS_TO_SPACING = FALSE
    } TEMP = hor_short
    BOOLEAN metal2  NOT hor_short { } TEMP = hor_long
    SELECT CUT_LAYER1 INSIDE ver_long { } TEMP = good_cut
    BOOLEAN CUT_LAYER1 NOT good_cut { } TEMP = fail_cut_1
    SELECT fail_cut_1 INSIDE hor_long { } TEMP = good_cut
    BOOLEAN fail_cut_1 NOT good_cut { } TEMP = fail_cut_1
    SELECT CUT_LAYER2 INSIDE ver_long { } TEMP = good_cut
    BOOLEAN CUT_LAYER2 NOT good_cut { } TEMP = fail_cut_2
    SELECT fail_cut_2 INSIDE hor_long { } TEMP = good_cut
    BOOLEAN fail_cut_2 NOT good_cut { } TEMP = fail_cut_2
    BOOLEAN fail_cut_1 OR fail_cut_2 { } TEMP = fail_cut
    BOOLEAN hor_short NOT ver_long { } TEMP = hor_short
    BOOLEAN ver_short NOT hor_long { } TEMP = ver_short
    SELECT ver_short INTERACT fail_cut { } TEMP = ver_fail
    SELECT hor_short INTERACT fail_cut { } TEMP = hor_fail
    BOOLEAN ver_fail OR hor_fail { } TEMP = all_fail
    INTERNAL all_fail {
        COMMENT = "$layer_name MinLength : minimum length = minLength um"
        SPACING < minLength
        VERTICAL_ONLY = TRUE
        SET_CORNERS_TO_SPACING = FALSE
    } (12 )
  } else {
    POLYGON_FEATURES metal2  {
      COMMENT = "$layer_name MinLength : minimum length = minLength um"
      EQUATIONS {
        vnum = EV_VNUM_IN;
        if ( vnum > 0) {
	  bdLeft = EV_VXCOORD_IN[0];
	  bdRight = EV_VXCOORD_IN[0];
	  bdBottom = EV_VYCOORD_IN[0];
	  bdTop = EV_VYCOORD_IN[0];
          FOR (i = 1; i < vnum; i++) {
	    if (bdLeft > EV_VXCOORD_IN[i]) bdLeft = EV_VXCOORD_IN[i];
            else if (bdRight < EV_VXCOORD_IN[i]) bdRight = EV_VXCOORD_IN[i];
	    if (bdBottom > EV_VYCOORD_IN[i]) bdBottom = EV_VYCOORD_IN[i];
            else if (bdTop < EV_VYCOORD_IN[i]) bdTop = EV_VYCOORD_IN[i];
          }
	  if ( (bdRight - bdLeft) < minLength &&
	       (bdTop - bdBottom) < minLength) {
	    FOR (i = 0; i < vnum; i++) {
              EV_VXCOORD_OUT[i] = EV_VXCOORD_IN[i];
	      EV_VYCOORD_OUT[i] = EV_VYCOORD_IN[i];
            }
	    EV_VNUM_OUT = vnum;
	    EV_SAVE_POLYGON();
          }
        }
      }
    } (12 ) 
  }
  SET minLength = 0;
}
/* check max length of bounding box on polygon */
if (maxLength > 0) {
  POLYGON_FEATURES metal2  {
    COMMENT = "$layer_name MaxLength : maximum length = maxLength um"
    EQUATIONS {
      vnum = EV_VNUM_IN;
      if ( vnum > 0) {
	bdLeft = EV_VXCOORD_IN[0];
	bdRight = EV_VXCOORD_IN[0];
	bdBottom = EV_VYCOORD_IN[0];
	bdTop = EV_VYCOORD_IN[0];
        FOR (i = 1; i < vnum; i++) {
	  if (bdLeft > EV_VXCOORD_IN[i]) bdLeft = EV_VXCOORD_IN[i];
          else if (bdRight < EV_VXCOORD_IN[i]) bdRight = EV_VXCOORD_IN[i];
	  if (bdBottom > EV_VYCOORD_IN[i]) bdBottom = EV_VYCOORD_IN[i];
          else if (bdTop < EV_VYCOORD_IN[i]) bdTop = EV_VYCOORD_IN[i];
        }
	if ( (bdRight - bdLeft + bdTop - bdBottom) > maxLength ) {
          EV_VXCOORD_OUT[0] = bdLeft;
	  EV_VYCOORD_OUT[0] = bdBottom;
          EV_VXCOORD_OUT[1] = bdLeft;
	  EV_VYCOORD_OUT[1] = bdTop;
          EV_VXCOORD_OUT[2] = bdRight;
	  EV_VYCOORD_OUT[2] = bdTop;
          EV_VXCOORD_OUT[3] = bdRight;
	  EV_VYCOORD_OUT[3] = bdBottom;
          EV_VXCOORD_OUT[4] = bdLeft;
	  EV_VYCOORD_OUT[4] = bdBottom;
	  EV_VNUM_OUT = 5;
	  EV_SAVE_POLYGON();
        }
      }
    }
  } (12 ) 
  SET maxLength = 0;
}
 
/*Check enclosed area*/
if (minEnclosedArea > 0) {
    SELECT metal2  INSIDE_HOLE {
        INNER_HOLE_ONLY
    } TEMP = holes
    BOOLEAN holes NOT metal2  { } TEMP = holes
 
    AREA holes {
        COMMENT = "$layer_name EnclsArea : minimum enclosed area = minEnclosedArea um*um"
        RANGE = [0.0005 * 0.0005 , minEnclosedArea - 0.0005 * 0.0005 ]
    } (12 )
    /* check min length of bounding box on polygon */
    if (minEnclosedWidth > 0) {
      POLYGON_FEATURES holes {
        COMMENT = "$layer_name EnclsWidth: minimum enclosed Width = minEnclosedWidth um"
        EQUATIONS {
          vnum = EV_VNUM_IN;
          if ( vnum > 0) {
            bdLeft = EV_VXCOORD_IN[0];
            bdRight = EV_VXCOORD_IN[0];
            bdBottom = EV_VYCOORD_IN[0];
            bdTop = EV_VYCOORD_IN[0];
            FOR (i = 1; i < vnum; i++) {
              if (bdLeft > EV_VXCOORD_IN[i]) bdLeft = EV_VXCOORD_IN[i];
              else if (bdRight < EV_VXCOORD_IN[i]) bdRight = EV_VXCOORD_IN[i];
              if (bdBottom > EV_VYCOORD_IN[i]) bdBottom = EV_VYCOORD_IN[i];
              else if (bdTop < EV_VYCOORD_IN[i]) bdTop = EV_VYCOORD_IN[i];
            }
            if ( (bdRight - bdLeft) < minEnclosedWidth &&
                 (bdTop - bdBottom) < minEnclosedWidth) {
              FOR (i = 0; i < vnum; i++) {
                EV_VXCOORD_OUT[i] = EV_VXCOORD_IN[i];
                EV_VYCOORD_OUT[i] = EV_VYCOORD_IN[i];
              }
              EV_VNUM_OUT = vnum;
              EV_SAVE_POLYGON();
            }
          }
        }
      } (12 ) 
    }
}
 
/*check special notch rule*/
if ((minEdgeLength2 > 0.0005  && minEdgeLength3 > 0.0005 ) || minEdgeMode==2) {
  if (minEdgeMode==2) {
    SET minEdgeLength3 = minEdgeLength ;
  }
  NOTCH metal2  {
     SPACING < minEdgeLength3
     SET_CORNERS_TO_SPACING=FALSE
     PARALLEL = TRUE
     OUTPUT_EDGES = TRUE
  } TEMP = notch_vectors
  SELECT_VECTOR notch_vectors {
     LENGTH_RANGE = [0.0005 , minEdgeLength2 - 0.0005 ]
  } TEMP = short_edges
  EXTERNAL short_edges metal2  {
     SPACING < minEdgeLength3
     SET_CORNERS_TO_SPACING=FALSE
     PARALLEL = TRUE
  } TEMP = notch_err
  /* Choose the real U-shaped notch */
  SIZE notch_err { OVERSIZE = 0.001 *10 } TEMP = neighbors 
  BOOLEAN neighbors AND metal2  { } TEMP = neighbors
  VERTEX neighbors { 
     CONCAVE = TRUE
     CONVEX = TRUE
     SIZE = 0.001 
  } TEMP = corners
  SELECT_EDGE neighbors INTERACT notch_err { } TEMP = target_edges
  BOOLEAN target_edges NOT corners { } TEMP = target_edges
  VERTEX neighbors { 
     CONCAVE = TRUE
     SIZE = 2* 0.001 
  } TEMP = corners
  SELECT target_edges INTERACT corners { RANGE = [2, 2] } TEMP=target_edges
  SELECT notch_err INTERACT target_edges {
     COMMENT = "$layer_name SpeclNotch: sameNetSp = minEdgeLength3 um (sideLen minEdgeLength2 um)" 
  } (12 )
}
/*check consecutive short edges*/
if (minEdgeLength > 0.0005  && minEdgeMode != 2) { 
  INTERNAL metal2_top  {
     SEGMENT < minEdgeLength
     FLAG_ACUTE_ANGLE = FALSE
     FLAG_ACUTE_EDGE = FALSE
     OUTPUT_EDGES = TRUE
  } TEMP = short_edges
  if ((minEdgeMode == 0 && maxTotalMinEdgeLength>0) || maxNumMinEdge > 0) {
    SET temporary_1 = 0.001 *2;
    SET temporary_2 = 2*temporary_1+ 0.0005 ;
    SELECT metal2_top  INTERACT short_edges { } TEMP = target_top
    CLASSIFY_EDGES target_top {
       LENGTH = temporary_1
       DMIN   = temporary_2
       INSIDE_CORNER  TEMP = inside_corner_edges
       OUTSIDE_CORNER TEMP = outside_corner_edges
       REMAINDER      TEMP = remainder_edges
    }
    if (minEdgeMode == 0 && (maxNumMinEdge>0 || maxTotalMinEdgeLength > 0)) {
       SELECT short_edges ENCLOSING inside_corner_edges { } TEMP = short_edges
    }
  }
  if (maxTotalMinEdgeLength > 0) {
    LENGTH short_edges {
       RANGE = [maxTotalMinEdgeLength + 0.0005 , 9999999999 ]
    } TEMP = max_length_err
    /* Work around: translate polygons into dimensional check output */
    SIZE max_length_err { OVERSIZE = 2* 0.001  } TEMP = max_length_err
    INTERNAL max_length_err {
       SPACING < 3* 0.001 
       SET_CORNERS_TO_SPACING=FALSE
       COMMENT = "$layer_name MinEdgeLen: maximum total length ( minEdgeLength um)= maxTotalMinEdgeLength um"
    } (12 )
  }
  if (maxTotalMinEdgeLength == 0 || maxNumMinEdge > 0) {
    if (maxNumMinEdge==0)  {
       COPY short_edges {} TEMP=max_edge_err
    } else {
       SIZE short_edges {
         VSIZE_HEAD = - 0.001 
        VSIZE_TAIL = - 0.001 
       } TEMP = short_edges
       SIZE short_edges {
          OVERSIZE = 5* 0.001 
          SIZE_ENDPOINTS = FALSE
       } TEMP = short_contours
       SELECT short_contours ENCLOSING remainder_edges {
          RANGE = [maxNumMinEdge + 1, 9999999999 ]
       } TEMP = short_contours
       SELECT short_edges INSIDE short_contours { } TEMP=max_edge_err
    }
    /* Work around: translate polygons into dimensional check output */
    SIZE max_edge_err { OVERSIZE = 2* 0.001  } TEMP = max_edge_error
    INTERNAL max_edge_error {
       SPACING < 3* 0.001 
       SET_CORNERS_TO_SPACING=FALSE
       COMMENT = "$layer_name MinEdgeLen: maximum number of consecutive short edges ( minEdgeLength um)= maxNumMinEdge"
    } (12 ) 
  }
}
 
/*check basic spacing*/
if (sameNetMinSpacing > 0 && sameNetMinSpacing != minSpacing) {
  if (sameNetMinSpacing > minSpacing) {
    /* Special condition for U-shaped Metal spacing rule */
    NOTCH metal2_pin  {
        SPACING < sameNetMinSpacing
        BOX_CORNER = FALSE 
        SET_CORNERS_TO_SPACING=FALSE
        NON_PARALLEL = TRUE
        OUTPUT_EDGES = TRUE
    } TEMP = errs_to_be_waived
    NOTCH metal2_top  {
	SPACING < sameNetMinSpacing
	BOX_CORNER = FALSE 
        SET_CORNERS_TO_SPACING=FALSE
	NON_PARALLEL = TRUE
        OUTPUT_EDGES = TRUE
    } TEMP = all_errs
    BOOLEAN all_errs NOT errs_to_be_waived { } TEMP=err_edge
    EXTERNAL err_edge metal2_top  {
	SPACING < sameNetMinSpacing
	BOX_CORNER = FALSE 
        SET_CORNERS_TO_SPACING=FALSE
	NON_PARALLEL = TRUE
    } TEMP = notch_err
    SIZE notch_err { OVERSIZE = 0.001 *10 } TEMP = neighbors
    BOOLEAN neighbors AND metal2_top  { } TEMP = neighbors
    VERTEX neighbors { 
       CONCAVE = TRUE
       CONVEX = TRUE
       SIZE = 0.001 
    } TEMP = corners
    SELECT_EDGE neighbors INTERACT notch_err { } TEMP = target_edges
    BOOLEAN target_edges AND notch_err { } TEMP = target_edges
    BOOLEAN target_edges NOT corners { } TEMP = target_edges
    VERTEX neighbors {
       CONCAVE = TRUE
       SIZE = 2* 0.001 
    } TEMP = corners
    SELECT target_edges INTERACT corners { RANGE = [2, 2] } TEMP = target_edges
    SELECT notch_err TOUCHING target_edges {
      COMMENT = "$layer_name U-ShpNotch: U-shape notch minimum spacing = sameNetMinSpacing um" 
    } (12 )
  } else {
    NOTCH metal2  {
        COMMENT = "$layer_name SameNetSpc: same-net minimum spacing = sameNetMinSpacing um" 
	SPACING < sameNetMinSpacing
	BOX_CORNER = FALSE 
	NON_PARALLEL = TRUE
    } (12 )
  }
  if (minSpacing > 0) {
    if (stubMode == 0 && stubSpacing > 0 && stubSpacing < minSpacing) {
	EXTERNAL metal2  {
	    COMMENT = "$layer_name Spacing   : minimum spacing = minSpacing um"
            LONGEDGE > stubThreshold + 0.0005 
	    LONGEDGE_TO_EDGE < minSpacing
	    SPACING <= 0
	    BOX_CORNER = FALSE 
	    NON_PARALLEL = TRUE
            POINT_TOUCH = TRUE
            CHECK_SAME_POLYGON = TRUE 
	} (12 )
    } else {
        EXTERNAL metal2  {
	    COMMENT = "$layer_name Spacing   : minimum spacing = minSpacing um" 
	    SPACING < minSpacing
	    BOX_CORNER = FALSE 
	    NON_PARALLEL = TRUE
            POINT_TOUCH = TRUE
	    CHECK_SAME_POLYGON = FALSE
        } (12 )
    }
  }
} else {
  if (minSpacing > 0) {
    if (stubMode == 0 && stubSpacing > 0 && stubSpacing < minSpacing) {
        EXTERNAL metal2  {
            COMMENT = "$layer_name Spacing   : minimum spacing = minSpacing um"
            LONGEDGE > stubThreshold + 0.0005  
            LONGEDGE_TO_EDGE < minSpacing
            SPACING <= 0 
            BOX_CORNER = FALSE 
            NON_PARALLEL = TRUE
            POINT_TOUCH = TRUE
            CHECK_SAME_POLYGON = TRUE 
        } (12 )
    } else {
        EXTERNAL metal2  {
	    COMMENT = "$layer_name Spacing   : minimum spacing = minSpacing um" 
            SPACING < minSpacing
	    BOX_CORNER = FALSE 
	    NON_PARALLEL = TRUE
	    POINT_TOUCH = TRUE
	    CHECK_SAME_POLYGON = TRUE 
        } (12 )
    }
  }
}
 
/*check dogbone */
if (sameNetMinSpacing > 0 && sameNetWidthThreshold) {
  NOTCH metal2  {
    SPACING < sameNetMinSpacing
    BOX_CORNER = FALSE 
    NON_PARALLEL = TRUE
  } TEMP = dog_bone
 
  if (!layer_empty(dog_bone)) {
    SIZE dog_bone {EDGESIZE = sameNetWidthThreshold} TEMP = dog_ext
    BOOLEAN dog_ext NOT dog_bone {} TEMP = dog_ext
    BOOLEAN dog_ext AND metal2  {} TEMP = dog_ext
    if (!layer_empty(dog_ext)) {
      SELECT dog_ext EDGE_TOUCH dog_bone { OUTSIDE RANGE = [1, 9999999999 ] } TEMP = dog_ext
      NOTCH metal2  {
        SPACING < sameNetMinSpacing
        BOX_CORNER = FALSE 
        NON_PARALLEL = TRUE
	OUTPUT_EDGES = TRUE
      } TEMP = dog_bone
      SELECT dog_ext OUTSIDE dog_bone {} TEMP = dog_ext
      INTERNAL dog_ext {
	COMMENT = "$layer_name dogBone   : notch spacing = sameNetMinSpacing um width sameNetWidthThreshold um" 
	SPACING < sameNetWidthThreshold
      } (12 )
    }
  }
}
/*check basic fat spacing*/
if (fatWireThreshold > 0 && fatTblDimension == 0) {
    SIZE fat_candidate { UNDER_OVER = fatWireThreshold / 2.0 - 0.0005  } TEMP = m_fat
    BOOLEAN m_fat AND metal2  {  } TEMP = m_fat
    BOOLEAN metal2  NOT m_fat {  } TEMP = m_thin
    if (ignoreBlockage == 0) {
        /* the blockages on the metal_blockage layer are treated as thin blockages */
        BOOLEAN m_thin OR metal2_blockage  {  } TEMP = m_thin
    }
 
    if (fatFatMinSpacing > 0) {
	EXTERNAL m_fat {
	    COMMENT = "$layer_name FatWireSpc: fat & fat ( fatWireThreshold um) minimum spacing = fatFatMinSpacing um"
	    SPACING < fatFatMinSpacing
	    BOX_CORNER = FALSE 
	    NON_PARALLEL = TRUE
	    POINT_TOUCH = FALSE
	    CHECK_SAME_POLYGON = TRUE 
       } (12 )
    }
 
    if (fatThinMinSpacing > 0) {
	EXTERNAL m_fat m_thin {
	    COMMENT = "$layer_name FatWireSpc: fat & thin ( fatWireThreshold um) minimum spacing fatThinMinSpacing um"
	    SPACING < fatThinMinSpacing
 	    BOX_CORNER = FALSE 
	    NON_PARALLEL = TRUE
	    POINT_TOUCH = FALSE
        } (12 )
    }
}
 
/*check thin blockage spacing*/
if (minSpacing > 0 && ignoreBlockage == 0) {
    if (!layer_empty (metal2_blockage )) {
	EXTERNAL metal2_blockage  metal2  {
	    COMMENT = "$layer_name Spacing   : metal & thin blockage minimum spacing = minSpacing um"
	    SPACING < minSpacing
	    BOX_CORNER = FALSE 
	    NON_PARALLEL = TRUE
	    POINT_TOUCH = TRUE
            TOUCH = TRUE
        } (12 )
    }
}
/*check blockage overlap*/
/*check shorts between top_level routing and fram_blockages*/
if (minSpacing>0 || checkCrossHierShort>0) {
   if (ignoreBlockage == 0) {
      BOOLEAN metal2_blockage  or metal2_rbkg  {} TEMP=all_blockage
   } else {
      COPY metal2_rbkg  {} TEMP=all_blockage
   }
   BOOLEAN all_blockage AND metal2_top  {} TEMP = overlap_shape1
   EXTERNAL all_blockage metal2_top  {
      SPACING <= 0
      TOUCH = TRUE
   } TEMP = overlap_shape2
   if (checkCrossHierShort>0) {
      BOOLEAN overlap_shape1 OR overlap_shape2 {
         COMMENT = "$layer_name Short Cross Hierarchy"
      } (12 )
   } else {
      BOOLEAN overlap_shape1 OR overlap_shape2 {
         COMMENT = "$layer_name Overlap   : metal & blockage overlap"
      } (12 )
   }
}
 
if (fatPolyContactRule > 0) {
  /* Fat Poly Contact Rule: not new fat wire formed */
  if (readCellView > 0) {
     SIZE metal1 { UNDER_OVER = fatPolyContactRule / 2.0 - 0.0005  } TEMP = fat
     BOOLEAN fat AND metal1 {  } TEMP = fat 
  } else {
     SIZE metal1_top { UNDER_OVER = fatPolyContactRule / 2.0 - 0.0005  } TEMP = fat
     BOOLEAN fat AND metal1_top {  } TEMP = fat 
  }
  SIZE metal1_pin { UNDER_OVER = fatPolyContactRule / 2.0 - 0.0005  } TEMP = fat_pin
  BOOLEAN fat_pin AND metal1_pin {  } TEMP = fat_pin
  BOOLEAN fat NOT fat_pin {
    COMMENT = "$layer_name FatPolyContactRule: fatPolyContactRule um" 
  } (12 )
}
/* Special End-of-Line Spacing Rule */
if (stubMode == 0 && stubSpacing > 0 && stubSpacing < minSpacing) {
  EXTERNAL metal2  {
     COMMENT = "$layer_name specEoLSpc: spacing= stubSpacing um (mode = 0)"
     LONGEDGE > stubThreshold + 0.0005 
     LONGEDGE_TO_EDGE <= 0 
     SPACING < stubSpacing 
     SET_CORNERS_TO_SPACING = FALSE
     PARALLEL_POINT_PROJECTION = FALSE
  } (12 )
} else if (stubMode > 0 && stubSpacing > minSpacing) {
  if (stubMode == 4) {
     INTERNAL metal2  {
        SEGMENT[90,90] < stubThreshold
        OUTPUT_EDGES = TRUE
     } TEMP = end_of_line
  } else {
     INTERNAL metal2  {
        SEGMENT[90,90] <= stubThreshold
        OUTPUT_EDGES = TRUE
     } TEMP = end_of_line
  }
  /* Quick filter to reduce the size of possible end of line */
  if (sideStubExt > 0) {
    SIZE end_of_line {
       VSIZE_HEAD = sideStubExt
       VSIZE_TAIL = sideStubExt
       OUTPUT_EDGES = TRUE
    } TEMP = eol_ext
  } else {
    COPY end_of_line { } TEMP=eol_ext
  }
  if (stub2StubSpacing > stubSpacing) {
     SET temporary_1 = stub2StubSpacing;
  } else {
     SET temporary_1 = stubSpacing; 
  }
  EXTERNAL eol_ext metal2  {
     SPACING < temporary_1
     TOUCH = TRUE
     OVERLAP = TRUE 
     SET_CORNERS_TO_SPACING = FALSE
     PARALLEL_POINT_PROJECTION = FALSE
     OUTPUT_EDGES = TRUE
  } TEMP=err_edge
  SELECT eol_ext INTERACT err_edge { } TEMP=eol_ext
  SELECT end_of_line INTERACT eol_ext { } TEMP=end_of_line 
  /* Reduce the size of METAL_LAYER */
  if (stubMode==3) {
     SIZE end_of_line {
        VSIZE_HEAD = stubSpacing 
        VSIZE_TAIL = stubSpacing 
        VSIZE_INSIDE = sideStubThreshold
        VSIZE_OUTSIDE = stubSpacing
     } TEMP = eol_filter 
  } else {
     if (stubMode == 1 && stubRange > 0) {
        SIZE end_of_line {
           VSIZE_HEAD = stubSpacing- 0.0005 
           VSIZE_TAIL = stubSpacing- 0.0005 
           VSIZE_OUTSIDE = stubSpacing- 0.0005 
        } TEMP = eol_filter
     } else {
        SIZE end_of_line {
           VSIZE_HEAD = stubSpacing- 0.0005 
           VSIZE_TAIL = stubSpacing- 0.0005 
           VSIZE_INSIDE = sideStubThreshold- 0.0005 
           VSIZE_OUTSIDE = stubSpacing- 0.0005 
        } TEMP = eol_filter
     }
  }
  SELECT metal2  INTERACT eol_filter { } TEMP=target_top
  /* Get the side edges and the whole eol of line set */
  SELECT_EDGE target_top INTERACT end_of_line { 
    POINT_TOUCH = TRUE
  } TEMP = eol_set
  VERTEX target_top { 
     CONCAVE = TRUE 
     CONVEX = TRUE
     SIZE = 0.001 
  } TEMP = corners
  SELECT corners OUTSIDE end_of_line {} TEMP =corners 
  BOOLEAN eol_set NOT corners { } TEMP=eol_set
  BOOLEAN eol_set NOT end_of_line { } TEMP=side_edge
  /* find out the real end of line */
  if (stubRange > 0) {
     if (stubMode == 1) {
         COPY side_edge { } TEMP = all_side_edge
         LENGTH side_edge { SPACING <= stubRange- 0.0005  } TEMP=side_edge
     } else {
         LENGTH side_edge { SPACING < stubRange- 0.001  } TEMP=eol_filter
         BOOLEAN side_edge NOT eol_filter { } TEMP=side_edge
     }
     SELECT end_of_line INTERACT side_edge { RANGE = [1,2] } TEMP = end_of_line
  } 
  if (stubMode == 1) {
    if (stub2StubSpacing > 0) {
       if (sideStubExt < 0) {
          SIZE end_of_line {
            VSIZE_HEAD = sideStubExt / 2
            VSIZE_TAIL = sideStubExt / 2
            OUTPUT_EDGES = TRUE
          } TEMP = eol_ext_tip
	 
          EXTERNAL eol_ext_tip {
            COMMENT = "$layer_name specEoLSpc: stub2Stubspacing= stub2StubSpacing um (mode = 1)"
            SPACING < stub2StubSpacing
            SET_CORNERS_TO_SPACING = FALSE
            PARALLEL_POINT_PROJECTION = TRUE
          } (12 )
       } else {
          EXTERNAL end_of_line {
            COMMENT = "$layer_name specEoLSpc: stub2Stubspacing= stub2StubSpacing um (mode = 1)"
            SPACING < stub2StubSpacing
            SET_CORNERS_TO_SPACING = FALSE
            PARALLEL_POINT_PROJECTION = FALSE
          } (12 )
       }
    }
    if (stubRange > 0) {
       SIZE end_of_line {
         VSIZE_INSIDE = 0.001 
       } TEMP = eol_poly
       SELECT_EDGE eol_poly TOUCHING target_top { } TEMP=eol_edge
       EXTERNAL eol_edge target_top {
         COMMENT = "$layer_name specEoLSpc: spacing= stubSpacing um (mode = 1)"
         CONVEX_TO_CONVEX < stubSpacing
         CONVEX_TO_CONVEX [POINT_PROJECTION] < stubSpacing
         CONVEX_TO_EDGE < stubSpacing
         CONCAVE_TO_CONVEX < stubSpacing
         LONGEDGE > 0.001 
         LONGEDGE_TO_EDGE < stubSpacing
         SPACING <= 0
         SET_CORNERS_TO_SPACING = TRUE
         PARALLEL_POINT_PROJECTION = TRUE
       } (12 )
       SELECT all_side_edge INTERACT end_of_line { } TEMP = side_edge
       SIZE side_edge {
         VSIZE_HEAD = 0.001 
         VSIZE_TAIL = 0.001 
       } TEMP = side_edge_ext
       BOOLEAN side_edge_ext NOT side_edge { } TEMP = side_edge_ext
       SELECT side_edge_ext INTERACT end_of_line { } TEMP = side_edge_ext
       EXTERNAL side_edge_ext target_top {
         COMMENT = "$layer_name specEoLSpc: spacing= stubSpacing um (mode = 1)"
         SPACING < stubSpacing
         SET_CORNERS_TO_SPACING = FALSE
         PARALLEL_POINT_PROJECTION = FALSE
       } (12 )
    } else {
       if (stub2StubSpacing > 0) {
         VECTORIZE target_top {
            DIRECTED=TRUE
         } TEMP=target_edges
         BOOLEAN target_edges NOT end_of_line { } TEMP = target_edges
         EXTERNAL end_of_line target_edges {
            COMMENT = "$layer_name specEoLSpc: spacing= stubSpacing um (mode = 1)"
            SPACING < stubSpacing
            TOUCH=TRUE
            OVERLAP=TRUE
            SET_CORNERS_TO_SPACING=FALSE
            PARALLEL_POINT_PROJECTION=FALSE
         } (12 )
       } else {
         if (sideStubExt > 0) {
            SIZE end_of_line {
               VSIZE_HEAD = sideStubExt
               VSIZE_TAIL = sideStubExt
               OUTPUT_EDGES = TRUE
            } TEMP = end_of_line
            EXTERNAL end_of_line target_top {
               COMMENT = "$layer_name specEoLSpc: spacing= stubSpacing ,crnKeepOut= sideStubExt um (mode = 1)"
               SPACING < stubSpacing
               TOUCH=TRUE
               OVERLAP=TRUE
               SET_CORNERS_TO_SPACING=FALSE
               PARALLEL_POINT_PROJECTION=FALSE
            } (12 )
         } else {
            EXTERNAL end_of_line target_top {
               COMMENT = "$layer_name specEoLSpc: spacing= stubSpacing um (mode = 1)"
               SPACING < stubSpacing
               TOUCH=TRUE
               OVERLAP=TRUE
               SET_CORNERS_TO_SPACING=FALSE
               PARALLEL_POINT_PROJECTION=FALSE
            } (12 )
         }
       }
    }
  } else { /* stubMode == 2,3,4 */
    /* stubMode 2 eol classify and reduction */
    if (stubMode !=3 && sideStubExt > 0) {
      if (stubMode == 4) {
        SIZE end_of_line {
           VSIZE_HEAD = sideStubExt
           VSIZE_TAIL = sideStubExt
           OUTPUT_EDGES = TRUE
        } TEMP = eol_ext
        EXTERNAL eol_ext target_top {
           SPACING < stubSpacing
           SET_CORNERS_TO_SPACING=FALSE
           PARALLEL_POINT_PROJECTION=FALSE
           OUTPUT_EDGES = TRUE
        } TEMP=err_edge
        SELECT eol_ext INTERACT err_edge { } TEMP=eol_ext
      } else {
        EXTERNAL end_of_line target_top {
           SPACING < stubSpacing
           SET_CORNERS_TO_SPACING=FALSE
           PARALLEL_POINT_PROJECTION=FALSE
           OUTPUT_EDGES = TRUE
        } TEMP=err_edge
        SELECT end_of_line INTERACT err_edge { } TEMP=eol_body
        SIZE end_of_line {
           VSIZE_HEAD = sideStubExt
           VSIZE_TAIL = sideStubExt
           OUTPUT_EDGES = TRUE
        } TEMP = eol_ext
        BOOLEAN eol_ext NOT end_of_line {} TEMP=eol_ext
        EXTERNAL eol_ext target_top {
           SPACING < stubSpacing
           SET_CORNERS_TO_SPACING=FALSE
           PARALLEL_POINT_PROJECTION=FALSE
           OUTPUT_EDGES = TRUE
        } TEMP=err_edge
        SELECT eol_ext INTERACT err_edge { } TEMP=eol_ext
        BOOLEAN eol_body OR eol_ext { } TEMP=eol_ext
      } 
    } else {
      COPY end_of_line { } TEMP=eol_ext
    }
    SELECT side_edge INTERACT eol_ext { } TEMP=side_edge
    SIZE eol_ext {
       VSIZE_INSIDE = sideStubThreshold 
       VSIZE_OUTSIDE = sideStubExt
    } TEMP = eol_range
    if (sideStubExt > 0) {
       SIZE side_edge {
          VSIZE_HEAD = sideStubExt
          VSIZE_TAIL = sideStubExt
          OUTPUT_EDGES = TRUE
       } TEMP = check_edge
    } else {
       COPY side_edge { } TEMP = check_edge
    }
    BOOLEAN check_edge AND eol_range { } TEMP=check_edge
    EXTERNAL check_edge target_top {
       SPACING < temporary_1
       SET_CORNERS_TO_SPACING = FALSE
       SHADOW_OTHER_LAYER = TRUE
       PARALLEL_POINT_PROJECTION = FALSE
       OUTPUT_EDGES = TRUE
    } TEMP=err_edge
    if (0 && stubMode!=4) { /* Temporarily do not check mode 2,3 side edge length */
       LENGTH side_edge { SPACING < stubSpacing- 0.0005 *2 } TEMP=err_edge_1
       BOOLEAN err_edge OR err_edge_1 { } TEMP=err_edge
    }
    SELECT check_edge INTERACT err_edge { } TEMP=side_edge
    if (stubMode!=3) {
       SELECT eol_ext INTERACT side_edge {} TEMP=err_eol
       EXTERNAL err_eol target_top {
          COMMENT = "$layer_name specEoLSpc: spacing= stubSpacing ,crnKeepOut= sideStubExt um (mode = stubMode )"
          SPACING < temporary_1
          PARALLEL_POINT_PROJECTION=FALSE
          SET_CORNERS_TO_SPACING=FALSE
       } (12 )
    } else { /* stubMode == 3 */
       SELECT eol_ext INTERACT side_edge { RANGE = [2, 2] } TEMP=err_eol
       EXTERNAL err_eol target_top {
          COMMENT = "$layer_name specEoLSpc: spacing= stubSpacing um (mode = 3)"
          SPACING < temporary_1
          PARALLEL_POINT_PROJECTION=FALSE
          SET_CORNERS_TO_SPACING=FALSE
       } (12 )
    }
  }
} /* stubMode > 0, not aligned */
/* Avoid empty optimization result parsing error */
if (addEmptyMetalCheck) {
   BOOLEAN empty OR empty {
      COMMENT = "$layer_name Empty: Dummy Output"
   } (12 )
   SET addEmptyMetalCheck=0;
}
/* reset variables */


 
SET minWidth = 0;
SET maxWidth = 0;
SET minArea = 0;
SET minEnclosedArea = 0;
SET minSpacing = 0;
SET sameNetMinSpacing = 0;
SET maxNumMinEdge = 0;
SET maxTotalMinEdgeLength = 0;
SET minEdgeLength = 0;
SET minEdgeLength2 = 0;
SET minEdgeLength3 = 0;
SET stubRange = 0;
SET stubSpacing = 0;
SET stub2StubSpacing = 0;
SET sideStubExt = 0;
SET sideStubThreshold = 0;
SET stubThreshold = 0;
SET fatPolyContactRule = 0;
SET fatWireThreshold = 0;
SET fatThinMinSpacing = 0;
SET fatFatMinSpacing = 0;
SET fatTblDimension = 0;
@ 210 "adrc/adrc.ev" 2









/*metal 3*/
SET layer_name = "Met3";










SET minWidth = 0.16;
SET maxWidth = 1000;
SET minArea = 0.07;
SET minSpacing = 0.16;
SET stub2StubSpacing = 0;

SET fatTblDimension = 0;
@ 1 "adrc/adrc_check_metal.ev" 1
/* Data Preparation */
if (fatTblDimension > 1 || fatWireThreshold > 0 || maxWidth > 0) {
  if (ignoreBlockage) {
      /* Let the real blockage be treated as thin */
      BOOLEAN metal3  NOT metal3_rbkg  {} TEMP=fat_candidate
  } else {
      COPY metal3  {} TEMP=fat_candidate
  }
  COPY fat_candidate {} TEMP=fat_target
}
/*Check width*/
if (minWidth > 0) {
    INTERNAL metal3  { 
        COMMENT = "$layer_name MinWidth  : minimum width = minWidth um" 
        SPACING < minWidth
        POINT_TOUCH = FALSE
    } (13 )
}
 
if (maxWidth > 0) {
    SIZE  fat_candidate {
        COMMENT = "$layer_name MaxWidth  : maximum width = maxWidth um"
 	UNDER_OVER = maxWidth / 2 
    } (13 ) 
}
 
/*Check area*/
if (minArea > 0) {
    AREA metal3  { 
	COMMENT = "$layer_name MinArea   : minimum area = minArea um*um"
	RANGE = [0.0005 * 0.0005 , minArea - 0.0005 * 0.0005 ]
    } (13 )
}
/* check min length of bounding box on polygon */
if (minLength > 0) {
  if (minLengthMode == 1) {
    INTERNAL metal3  {
        SPACING < minLength
        VERTICAL_ONLY = TRUE
        SET_CORNERS_TO_SPACING = FALSE
    } TEMP = ver_short
    BOOLEAN metal3  NOT ver_short { } TEMP = ver_long
    INTERNAL metal3  {
        SPACING < minLength
        HORIZONTAL_ONLY = TRUE
        SET_CORNERS_TO_SPACING = FALSE
    } TEMP = hor_short
    BOOLEAN metal3  NOT hor_short { } TEMP = hor_long
    SELECT CUT_LAYER1 INSIDE ver_long { } TEMP = good_cut
    BOOLEAN CUT_LAYER1 NOT good_cut { } TEMP = fail_cut_1
    SELECT fail_cut_1 INSIDE hor_long { } TEMP = good_cut
    BOOLEAN fail_cut_1 NOT good_cut { } TEMP = fail_cut_1
    SELECT CUT_LAYER2 INSIDE ver_long { } TEMP = good_cut
    BOOLEAN CUT_LAYER2 NOT good_cut { } TEMP = fail_cut_2
    SELECT fail_cut_2 INSIDE hor_long { } TEMP = good_cut
    BOOLEAN fail_cut_2 NOT good_cut { } TEMP = fail_cut_2
    BOOLEAN fail_cut_1 OR fail_cut_2 { } TEMP = fail_cut
    BOOLEAN hor_short NOT ver_long { } TEMP = hor_short
    BOOLEAN ver_short NOT hor_long { } TEMP = ver_short
    SELECT ver_short INTERACT fail_cut { } TEMP = ver_fail
    SELECT hor_short INTERACT fail_cut { } TEMP = hor_fail
    BOOLEAN ver_fail OR hor_fail { } TEMP = all_fail
    INTERNAL all_fail {
        COMMENT = "$layer_name MinLength : minimum length = minLength um"
        SPACING < minLength
        VERTICAL_ONLY = TRUE
        SET_CORNERS_TO_SPACING = FALSE
    } (13 )
  } else {
    POLYGON_FEATURES metal3  {
      COMMENT = "$layer_name MinLength : minimum length = minLength um"
      EQUATIONS {
        vnum = EV_VNUM_IN;
        if ( vnum > 0) {
	  bdLeft = EV_VXCOORD_IN[0];
	  bdRight = EV_VXCOORD_IN[0];
	  bdBottom = EV_VYCOORD_IN[0];
	  bdTop = EV_VYCOORD_IN[0];
          FOR (i = 1; i < vnum; i++) {
	    if (bdLeft > EV_VXCOORD_IN[i]) bdLeft = EV_VXCOORD_IN[i];
            else if (bdRight < EV_VXCOORD_IN[i]) bdRight = EV_VXCOORD_IN[i];
	    if (bdBottom > EV_VYCOORD_IN[i]) bdBottom = EV_VYCOORD_IN[i];
            else if (bdTop < EV_VYCOORD_IN[i]) bdTop = EV_VYCOORD_IN[i];
          }
	  if ( (bdRight - bdLeft) < minLength &&
	       (bdTop - bdBottom) < minLength) {
	    FOR (i = 0; i < vnum; i++) {
              EV_VXCOORD_OUT[i] = EV_VXCOORD_IN[i];
	      EV_VYCOORD_OUT[i] = EV_VYCOORD_IN[i];
            }
	    EV_VNUM_OUT = vnum;
	    EV_SAVE_POLYGON();
          }
        }
      }
    } (13 ) 
  }
  SET minLength = 0;
}
/* check max length of bounding box on polygon */
if (maxLength > 0) {
  POLYGON_FEATURES metal3  {
    COMMENT = "$layer_name MaxLength : maximum length = maxLength um"
    EQUATIONS {
      vnum = EV_VNUM_IN;
      if ( vnum > 0) {
	bdLeft = EV_VXCOORD_IN[0];
	bdRight = EV_VXCOORD_IN[0];
	bdBottom = EV_VYCOORD_IN[0];
	bdTop = EV_VYCOORD_IN[0];
        FOR (i = 1; i < vnum; i++) {
	  if (bdLeft > EV_VXCOORD_IN[i]) bdLeft = EV_VXCOORD_IN[i];
          else if (bdRight < EV_VXCOORD_IN[i]) bdRight = EV_VXCOORD_IN[i];
	  if (bdBottom > EV_VYCOORD_IN[i]) bdBottom = EV_VYCOORD_IN[i];
          else if (bdTop < EV_VYCOORD_IN[i]) bdTop = EV_VYCOORD_IN[i];
        }
	if ( (bdRight - bdLeft + bdTop - bdBottom) > maxLength ) {
          EV_VXCOORD_OUT[0] = bdLeft;
	  EV_VYCOORD_OUT[0] = bdBottom;
          EV_VXCOORD_OUT[1] = bdLeft;
	  EV_VYCOORD_OUT[1] = bdTop;
          EV_VXCOORD_OUT[2] = bdRight;
	  EV_VYCOORD_OUT[2] = bdTop;
          EV_VXCOORD_OUT[3] = bdRight;
	  EV_VYCOORD_OUT[3] = bdBottom;
          EV_VXCOORD_OUT[4] = bdLeft;
	  EV_VYCOORD_OUT[4] = bdBottom;
	  EV_VNUM_OUT = 5;
	  EV_SAVE_POLYGON();
        }
      }
    }
  } (13 ) 
  SET maxLength = 0;
}
 
/*Check enclosed area*/
if (minEnclosedArea > 0) {
    SELECT metal3  INSIDE_HOLE {
        INNER_HOLE_ONLY
    } TEMP = holes
    BOOLEAN holes NOT metal3  { } TEMP = holes
 
    AREA holes {
        COMMENT = "$layer_name EnclsArea : minimum enclosed area = minEnclosedArea um*um"
        RANGE = [0.0005 * 0.0005 , minEnclosedArea - 0.0005 * 0.0005 ]
    } (13 )
    /* check min length of bounding box on polygon */
    if (minEnclosedWidth > 0) {
      POLYGON_FEATURES holes {
        COMMENT = "$layer_name EnclsWidth: minimum enclosed Width = minEnclosedWidth um"
        EQUATIONS {
          vnum = EV_VNUM_IN;
          if ( vnum > 0) {
            bdLeft = EV_VXCOORD_IN[0];
            bdRight = EV_VXCOORD_IN[0];
            bdBottom = EV_VYCOORD_IN[0];
            bdTop = EV_VYCOORD_IN[0];
            FOR (i = 1; i < vnum; i++) {
              if (bdLeft > EV_VXCOORD_IN[i]) bdLeft = EV_VXCOORD_IN[i];
              else if (bdRight < EV_VXCOORD_IN[i]) bdRight = EV_VXCOORD_IN[i];
              if (bdBottom > EV_VYCOORD_IN[i]) bdBottom = EV_VYCOORD_IN[i];
              else if (bdTop < EV_VYCOORD_IN[i]) bdTop = EV_VYCOORD_IN[i];
            }
            if ( (bdRight - bdLeft) < minEnclosedWidth &&
                 (bdTop - bdBottom) < minEnclosedWidth) {
              FOR (i = 0; i < vnum; i++) {
                EV_VXCOORD_OUT[i] = EV_VXCOORD_IN[i];
                EV_VYCOORD_OUT[i] = EV_VYCOORD_IN[i];
              }
              EV_VNUM_OUT = vnum;
              EV_SAVE_POLYGON();
            }
          }
        }
      } (13 ) 
    }
}
 
/*check special notch rule*/
if ((minEdgeLength2 > 0.0005  && minEdgeLength3 > 0.0005 ) || minEdgeMode==2) {
  if (minEdgeMode==2) {
    SET minEdgeLength3 = minEdgeLength ;
  }
  NOTCH metal3  {
     SPACING < minEdgeLength3
     SET_CORNERS_TO_SPACING=FALSE
     PARALLEL = TRUE
     OUTPUT_EDGES = TRUE
  } TEMP = notch_vectors
  SELECT_VECTOR notch_vectors {
     LENGTH_RANGE = [0.0005 , minEdgeLength2 - 0.0005 ]
  } TEMP = short_edges
  EXTERNAL short_edges metal3  {
     SPACING < minEdgeLength3
     SET_CORNERS_TO_SPACING=FALSE
     PARALLEL = TRUE
  } TEMP = notch_err
  /* Choose the real U-shaped notch */
  SIZE notch_err { OVERSIZE = 0.001 *10 } TEMP = neighbors 
  BOOLEAN neighbors AND metal3  { } TEMP = neighbors
  VERTEX neighbors { 
     CONCAVE = TRUE
     CONVEX = TRUE
     SIZE = 0.001 
  } TEMP = corners
  SELECT_EDGE neighbors INTERACT notch_err { } TEMP = target_edges
  BOOLEAN target_edges NOT corners { } TEMP = target_edges
  VERTEX neighbors { 
     CONCAVE = TRUE
     SIZE = 2* 0.001 
  } TEMP = corners
  SELECT target_edges INTERACT corners { RANGE = [2, 2] } TEMP=target_edges
  SELECT notch_err INTERACT target_edges {
     COMMENT = "$layer_name SpeclNotch: sameNetSp = minEdgeLength3 um (sideLen minEdgeLength2 um)" 
  } (13 )
}
/*check consecutive short edges*/
if (minEdgeLength > 0.0005  && minEdgeMode != 2) { 
  INTERNAL metal3_top  {
     SEGMENT < minEdgeLength
     FLAG_ACUTE_ANGLE = FALSE
     FLAG_ACUTE_EDGE = FALSE
     OUTPUT_EDGES = TRUE
  } TEMP = short_edges
  if ((minEdgeMode == 0 && maxTotalMinEdgeLength>0) || maxNumMinEdge > 0) {
    SET temporary_1 = 0.001 *2;
    SET temporary_2 = 2*temporary_1+ 0.0005 ;
    SELECT metal3_top  INTERACT short_edges { } TEMP = target_top
    CLASSIFY_EDGES target_top {
       LENGTH = temporary_1
       DMIN   = temporary_2
       INSIDE_CORNER  TEMP = inside_corner_edges
       OUTSIDE_CORNER TEMP = outside_corner_edges
       REMAINDER      TEMP = remainder_edges
    }
    if (minEdgeMode == 0 && (maxNumMinEdge>0 || maxTotalMinEdgeLength > 0)) {
       SELECT short_edges ENCLOSING inside_corner_edges { } TEMP = short_edges
    }
  }
  if (maxTotalMinEdgeLength > 0) {
    LENGTH short_edges {
       RANGE = [maxTotalMinEdgeLength + 0.0005 , 9999999999 ]
    } TEMP = max_length_err
    /* Work around: translate polygons into dimensional check output */
    SIZE max_length_err { OVERSIZE = 2* 0.001  } TEMP = max_length_err
    INTERNAL max_length_err {
       SPACING < 3* 0.001 
       SET_CORNERS_TO_SPACING=FALSE
       COMMENT = "$layer_name MinEdgeLen: maximum total length ( minEdgeLength um)= maxTotalMinEdgeLength um"
    } (13 )
  }
  if (maxTotalMinEdgeLength == 0 || maxNumMinEdge > 0) {
    if (maxNumMinEdge==0)  {
       COPY short_edges {} TEMP=max_edge_err
    } else {
       SIZE short_edges {
         VSIZE_HEAD = - 0.001 
        VSIZE_TAIL = - 0.001 
       } TEMP = short_edges
       SIZE short_edges {
          OVERSIZE = 5* 0.001 
          SIZE_ENDPOINTS = FALSE
       } TEMP = short_contours
       SELECT short_contours ENCLOSING remainder_edges {
          RANGE = [maxNumMinEdge + 1, 9999999999 ]
       } TEMP = short_contours
       SELECT short_edges INSIDE short_contours { } TEMP=max_edge_err
    }
    /* Work around: translate polygons into dimensional check output */
    SIZE max_edge_err { OVERSIZE = 2* 0.001  } TEMP = max_edge_error
    INTERNAL max_edge_error {
       SPACING < 3* 0.001 
       SET_CORNERS_TO_SPACING=FALSE
       COMMENT = "$layer_name MinEdgeLen: maximum number of consecutive short edges ( minEdgeLength um)= maxNumMinEdge"
    } (13 ) 
  }
}
 
/*check basic spacing*/
if (sameNetMinSpacing > 0 && sameNetMinSpacing != minSpacing) {
  if (sameNetMinSpacing > minSpacing) {
    /* Special condition for U-shaped Metal spacing rule */
    NOTCH metal3_pin  {
        SPACING < sameNetMinSpacing
        BOX_CORNER = FALSE 
        SET_CORNERS_TO_SPACING=FALSE
        NON_PARALLEL = TRUE
        OUTPUT_EDGES = TRUE
    } TEMP = errs_to_be_waived
    NOTCH metal3_top  {
	SPACING < sameNetMinSpacing
	BOX_CORNER = FALSE 
        SET_CORNERS_TO_SPACING=FALSE
	NON_PARALLEL = TRUE
        OUTPUT_EDGES = TRUE
    } TEMP = all_errs
    BOOLEAN all_errs NOT errs_to_be_waived { } TEMP=err_edge
    EXTERNAL err_edge metal3_top  {
	SPACING < sameNetMinSpacing
	BOX_CORNER = FALSE 
        SET_CORNERS_TO_SPACING=FALSE
	NON_PARALLEL = TRUE
    } TEMP = notch_err
    SIZE notch_err { OVERSIZE = 0.001 *10 } TEMP = neighbors
    BOOLEAN neighbors AND metal3_top  { } TEMP = neighbors
    VERTEX neighbors { 
       CONCAVE = TRUE
       CONVEX = TRUE
       SIZE = 0.001 
    } TEMP = corners
    SELECT_EDGE neighbors INTERACT notch_err { } TEMP = target_edges
    BOOLEAN target_edges AND notch_err { } TEMP = target_edges
    BOOLEAN target_edges NOT corners { } TEMP = target_edges
    VERTEX neighbors {
       CONCAVE = TRUE
       SIZE = 2* 0.001 
    } TEMP = corners
    SELECT target_edges INTERACT corners { RANGE = [2, 2] } TEMP = target_edges
    SELECT notch_err TOUCHING target_edges {
      COMMENT = "$layer_name U-ShpNotch: U-shape notch minimum spacing = sameNetMinSpacing um" 
    } (13 )
  } else {
    NOTCH metal3  {
        COMMENT = "$layer_name SameNetSpc: same-net minimum spacing = sameNetMinSpacing um" 
	SPACING < sameNetMinSpacing
	BOX_CORNER = FALSE 
	NON_PARALLEL = TRUE
    } (13 )
  }
  if (minSpacing > 0) {
    if (stubMode == 0 && stubSpacing > 0 && stubSpacing < minSpacing) {
	EXTERNAL metal3  {
	    COMMENT = "$layer_name Spacing   : minimum spacing = minSpacing um"
            LONGEDGE > stubThreshold + 0.0005 
	    LONGEDGE_TO_EDGE < minSpacing
	    SPACING <= 0
	    BOX_CORNER = FALSE 
	    NON_PARALLEL = TRUE
            POINT_TOUCH = TRUE
            CHECK_SAME_POLYGON = TRUE 
	} (13 )
    } else {
        EXTERNAL metal3  {
	    COMMENT = "$layer_name Spacing   : minimum spacing = minSpacing um" 
	    SPACING < minSpacing
	    BOX_CORNER = FALSE 
	    NON_PARALLEL = TRUE
            POINT_TOUCH = TRUE
	    CHECK_SAME_POLYGON = FALSE
        } (13 )
    }
  }
} else {
  if (minSpacing > 0) {
    if (stubMode == 0 && stubSpacing > 0 && stubSpacing < minSpacing) {
        EXTERNAL metal3  {
            COMMENT = "$layer_name Spacing   : minimum spacing = minSpacing um"
            LONGEDGE > stubThreshold + 0.0005  
            LONGEDGE_TO_EDGE < minSpacing
            SPACING <= 0 
            BOX_CORNER = FALSE 
            NON_PARALLEL = TRUE
            POINT_TOUCH = TRUE
            CHECK_SAME_POLYGON = TRUE 
        } (13 )
    } else {
        EXTERNAL metal3  {
	    COMMENT = "$layer_name Spacing   : minimum spacing = minSpacing um" 
            SPACING < minSpacing
	    BOX_CORNER = FALSE 
	    NON_PARALLEL = TRUE
	    POINT_TOUCH = TRUE
	    CHECK_SAME_POLYGON = TRUE 
        } (13 )
    }
  }
}
 
/*check dogbone */
if (sameNetMinSpacing > 0 && sameNetWidthThreshold) {
  NOTCH metal3  {
    SPACING < sameNetMinSpacing
    BOX_CORNER = FALSE 
    NON_PARALLEL = TRUE
  } TEMP = dog_bone
 
  if (!layer_empty(dog_bone)) {
    SIZE dog_bone {EDGESIZE = sameNetWidthThreshold} TEMP = dog_ext
    BOOLEAN dog_ext NOT dog_bone {} TEMP = dog_ext
    BOOLEAN dog_ext AND metal3  {} TEMP = dog_ext
    if (!layer_empty(dog_ext)) {
      SELECT dog_ext EDGE_TOUCH dog_bone { OUTSIDE RANGE = [1, 9999999999 ] } TEMP = dog_ext
      NOTCH metal3  {
        SPACING < sameNetMinSpacing
        BOX_CORNER = FALSE 
        NON_PARALLEL = TRUE
	OUTPUT_EDGES = TRUE
      } TEMP = dog_bone
      SELECT dog_ext OUTSIDE dog_bone {} TEMP = dog_ext
      INTERNAL dog_ext {
	COMMENT = "$layer_name dogBone   : notch spacing = sameNetMinSpacing um width sameNetWidthThreshold um" 
	SPACING < sameNetWidthThreshold
      } (13 )
    }
  }
}
/*check basic fat spacing*/
if (fatWireThreshold > 0 && fatTblDimension == 0) {
    SIZE fat_candidate { UNDER_OVER = fatWireThreshold / 2.0 - 0.0005  } TEMP = m_fat
    BOOLEAN m_fat AND metal3  {  } TEMP = m_fat
    BOOLEAN metal3  NOT m_fat {  } TEMP = m_thin
    if (ignoreBlockage == 0) {
        /* the blockages on the metal_blockage layer are treated as thin blockages */
        BOOLEAN m_thin OR metal3_blockage  {  } TEMP = m_thin
    }
 
    if (fatFatMinSpacing > 0) {
	EXTERNAL m_fat {
	    COMMENT = "$layer_name FatWireSpc: fat & fat ( fatWireThreshold um) minimum spacing = fatFatMinSpacing um"
	    SPACING < fatFatMinSpacing
	    BOX_CORNER = FALSE 
	    NON_PARALLEL = TRUE
	    POINT_TOUCH = FALSE
	    CHECK_SAME_POLYGON = TRUE 
       } (13 )
    }
 
    if (fatThinMinSpacing > 0) {
	EXTERNAL m_fat m_thin {
	    COMMENT = "$layer_name FatWireSpc: fat & thin ( fatWireThreshold um) minimum spacing fatThinMinSpacing um"
	    SPACING < fatThinMinSpacing
 	    BOX_CORNER = FALSE 
	    NON_PARALLEL = TRUE
	    POINT_TOUCH = FALSE
        } (13 )
    }
}
 
/*check thin blockage spacing*/
if (minSpacing > 0 && ignoreBlockage == 0) {
    if (!layer_empty (metal3_blockage )) {
	EXTERNAL metal3_blockage  metal3  {
	    COMMENT = "$layer_name Spacing   : metal & thin blockage minimum spacing = minSpacing um"
	    SPACING < minSpacing
	    BOX_CORNER = FALSE 
	    NON_PARALLEL = TRUE
	    POINT_TOUCH = TRUE
            TOUCH = TRUE
        } (13 )
    }
}
/*check blockage overlap*/
/*check shorts between top_level routing and fram_blockages*/
if (minSpacing>0 || checkCrossHierShort>0) {
   if (ignoreBlockage == 0) {
      BOOLEAN metal3_blockage  or metal3_rbkg  {} TEMP=all_blockage
   } else {
      COPY metal3_rbkg  {} TEMP=all_blockage
   }
   BOOLEAN all_blockage AND metal3_top  {} TEMP = overlap_shape1
   EXTERNAL all_blockage metal3_top  {
      SPACING <= 0
      TOUCH = TRUE
   } TEMP = overlap_shape2
   if (checkCrossHierShort>0) {
      BOOLEAN overlap_shape1 OR overlap_shape2 {
         COMMENT = "$layer_name Short Cross Hierarchy"
      } (13 )
   } else {
      BOOLEAN overlap_shape1 OR overlap_shape2 {
         COMMENT = "$layer_name Overlap   : metal & blockage overlap"
      } (13 )
   }
}
 
if (fatPolyContactRule > 0) {
  /* Fat Poly Contact Rule: not new fat wire formed */
  if (readCellView > 0) {
     SIZE metal1 { UNDER_OVER = fatPolyContactRule / 2.0 - 0.0005  } TEMP = fat
     BOOLEAN fat AND metal1 {  } TEMP = fat 
  } else {
     SIZE metal1_top { UNDER_OVER = fatPolyContactRule / 2.0 - 0.0005  } TEMP = fat
     BOOLEAN fat AND metal1_top {  } TEMP = fat 
  }
  SIZE metal1_pin { UNDER_OVER = fatPolyContactRule / 2.0 - 0.0005  } TEMP = fat_pin
  BOOLEAN fat_pin AND metal1_pin {  } TEMP = fat_pin
  BOOLEAN fat NOT fat_pin {
    COMMENT = "$layer_name FatPolyContactRule: fatPolyContactRule um" 
  } (13 )
}
/* Special End-of-Line Spacing Rule */
if (stubMode == 0 && stubSpacing > 0 && stubSpacing < minSpacing) {
  EXTERNAL metal3  {
     COMMENT = "$layer_name specEoLSpc: spacing= stubSpacing um (mode = 0)"
     LONGEDGE > stubThreshold + 0.0005 
     LONGEDGE_TO_EDGE <= 0 
     SPACING < stubSpacing 
     SET_CORNERS_TO_SPACING = FALSE
     PARALLEL_POINT_PROJECTION = FALSE
  } (13 )
} else if (stubMode > 0 && stubSpacing > minSpacing) {
  if (stubMode == 4) {
     INTERNAL metal3  {
        SEGMENT[90,90] < stubThreshold
        OUTPUT_EDGES = TRUE
     } TEMP = end_of_line
  } else {
     INTERNAL metal3  {
        SEGMENT[90,90] <= stubThreshold
        OUTPUT_EDGES = TRUE
     } TEMP = end_of_line
  }
  /* Quick filter to reduce the size of possible end of line */
  if (sideStubExt > 0) {
    SIZE end_of_line {
       VSIZE_HEAD = sideStubExt
       VSIZE_TAIL = sideStubExt
       OUTPUT_EDGES = TRUE
    } TEMP = eol_ext
  } else {
    COPY end_of_line { } TEMP=eol_ext
  }
  if (stub2StubSpacing > stubSpacing) {
     SET temporary_1 = stub2StubSpacing;
  } else {
     SET temporary_1 = stubSpacing; 
  }
  EXTERNAL eol_ext metal3  {
     SPACING < temporary_1
     TOUCH = TRUE
     OVERLAP = TRUE 
     SET_CORNERS_TO_SPACING = FALSE
     PARALLEL_POINT_PROJECTION = FALSE
     OUTPUT_EDGES = TRUE
  } TEMP=err_edge
  SELECT eol_ext INTERACT err_edge { } TEMP=eol_ext
  SELECT end_of_line INTERACT eol_ext { } TEMP=end_of_line 
  /* Reduce the size of METAL_LAYER */
  if (stubMode==3) {
     SIZE end_of_line {
        VSIZE_HEAD = stubSpacing 
        VSIZE_TAIL = stubSpacing 
        VSIZE_INSIDE = sideStubThreshold
        VSIZE_OUTSIDE = stubSpacing
     } TEMP = eol_filter 
  } else {
     if (stubMode == 1 && stubRange > 0) {
        SIZE end_of_line {
           VSIZE_HEAD = stubSpacing- 0.0005 
           VSIZE_TAIL = stubSpacing- 0.0005 
           VSIZE_OUTSIDE = stubSpacing- 0.0005 
        } TEMP = eol_filter
     } else {
        SIZE end_of_line {
           VSIZE_HEAD = stubSpacing- 0.0005 
           VSIZE_TAIL = stubSpacing- 0.0005 
           VSIZE_INSIDE = sideStubThreshold- 0.0005 
           VSIZE_OUTSIDE = stubSpacing- 0.0005 
        } TEMP = eol_filter
     }
  }
  SELECT metal3  INTERACT eol_filter { } TEMP=target_top
  /* Get the side edges and the whole eol of line set */
  SELECT_EDGE target_top INTERACT end_of_line { 
    POINT_TOUCH = TRUE
  } TEMP = eol_set
  VERTEX target_top { 
     CONCAVE = TRUE 
     CONVEX = TRUE
     SIZE = 0.001 
  } TEMP = corners
  SELECT corners OUTSIDE end_of_line {} TEMP =corners 
  BOOLEAN eol_set NOT corners { } TEMP=eol_set
  BOOLEAN eol_set NOT end_of_line { } TEMP=side_edge
  /* find out the real end of line */
  if (stubRange > 0) {
     if (stubMode == 1) {
         COPY side_edge { } TEMP = all_side_edge
         LENGTH side_edge { SPACING <= stubRange- 0.0005  } TEMP=side_edge
     } else {
         LENGTH side_edge { SPACING < stubRange- 0.001  } TEMP=eol_filter
         BOOLEAN side_edge NOT eol_filter { } TEMP=side_edge
     }
     SELECT end_of_line INTERACT side_edge { RANGE = [1,2] } TEMP = end_of_line
  } 
  if (stubMode == 1) {
    if (stub2StubSpacing > 0) {
       if (sideStubExt < 0) {
          SIZE end_of_line {
            VSIZE_HEAD = sideStubExt / 2
            VSIZE_TAIL = sideStubExt / 2
            OUTPUT_EDGES = TRUE
          } TEMP = eol_ext_tip
	 
          EXTERNAL eol_ext_tip {
            COMMENT = "$layer_name specEoLSpc: stub2Stubspacing= stub2StubSpacing um (mode = 1)"
            SPACING < stub2StubSpacing
            SET_CORNERS_TO_SPACING = FALSE
            PARALLEL_POINT_PROJECTION = TRUE
          } (13 )
       } else {
          EXTERNAL end_of_line {
            COMMENT = "$layer_name specEoLSpc: stub2Stubspacing= stub2StubSpacing um (mode = 1)"
            SPACING < stub2StubSpacing
            SET_CORNERS_TO_SPACING = FALSE
            PARALLEL_POINT_PROJECTION = FALSE
          } (13 )
       }
    }
    if (stubRange > 0) {
       SIZE end_of_line {
         VSIZE_INSIDE = 0.001 
       } TEMP = eol_poly
       SELECT_EDGE eol_poly TOUCHING target_top { } TEMP=eol_edge
       EXTERNAL eol_edge target_top {
         COMMENT = "$layer_name specEoLSpc: spacing= stubSpacing um (mode = 1)"
         CONVEX_TO_CONVEX < stubSpacing
         CONVEX_TO_CONVEX [POINT_PROJECTION] < stubSpacing
         CONVEX_TO_EDGE < stubSpacing
         CONCAVE_TO_CONVEX < stubSpacing
         LONGEDGE > 0.001 
         LONGEDGE_TO_EDGE < stubSpacing
         SPACING <= 0
         SET_CORNERS_TO_SPACING = TRUE
         PARALLEL_POINT_PROJECTION = TRUE
       } (13 )
       SELECT all_side_edge INTERACT end_of_line { } TEMP = side_edge
       SIZE side_edge {
         VSIZE_HEAD = 0.001 
         VSIZE_TAIL = 0.001 
       } TEMP = side_edge_ext
       BOOLEAN side_edge_ext NOT side_edge { } TEMP = side_edge_ext
       SELECT side_edge_ext INTERACT end_of_line { } TEMP = side_edge_ext
       EXTERNAL side_edge_ext target_top {
         COMMENT = "$layer_name specEoLSpc: spacing= stubSpacing um (mode = 1)"
         SPACING < stubSpacing
         SET_CORNERS_TO_SPACING = FALSE
         PARALLEL_POINT_PROJECTION = FALSE
       } (13 )
    } else {
       if (stub2StubSpacing > 0) {
         VECTORIZE target_top {
            DIRECTED=TRUE
         } TEMP=target_edges
         BOOLEAN target_edges NOT end_of_line { } TEMP = target_edges
         EXTERNAL end_of_line target_edges {
            COMMENT = "$layer_name specEoLSpc: spacing= stubSpacing um (mode = 1)"
            SPACING < stubSpacing
            TOUCH=TRUE
            OVERLAP=TRUE
            SET_CORNERS_TO_SPACING=FALSE
            PARALLEL_POINT_PROJECTION=FALSE
         } (13 )
       } else {
         if (sideStubExt > 0) {
            SIZE end_of_line {
               VSIZE_HEAD = sideStubExt
               VSIZE_TAIL = sideStubExt
               OUTPUT_EDGES = TRUE
            } TEMP = end_of_line
            EXTERNAL end_of_line target_top {
               COMMENT = "$layer_name specEoLSpc: spacing= stubSpacing ,crnKeepOut= sideStubExt um (mode = 1)"
               SPACING < stubSpacing
               TOUCH=TRUE
               OVERLAP=TRUE
               SET_CORNERS_TO_SPACING=FALSE
               PARALLEL_POINT_PROJECTION=FALSE
            } (13 )
         } else {
            EXTERNAL end_of_line target_top {
               COMMENT = "$layer_name specEoLSpc: spacing= stubSpacing um (mode = 1)"
               SPACING < stubSpacing
               TOUCH=TRUE
               OVERLAP=TRUE
               SET_CORNERS_TO_SPACING=FALSE
               PARALLEL_POINT_PROJECTION=FALSE
            } (13 )
         }
       }
    }
  } else { /* stubMode == 2,3,4 */
    /* stubMode 2 eol classify and reduction */
    if (stubMode !=3 && sideStubExt > 0) {
      if (stubMode == 4) {
        SIZE end_of_line {
           VSIZE_HEAD = sideStubExt
           VSIZE_TAIL = sideStubExt
           OUTPUT_EDGES = TRUE
        } TEMP = eol_ext
        EXTERNAL eol_ext target_top {
           SPACING < stubSpacing
           SET_CORNERS_TO_SPACING=FALSE
           PARALLEL_POINT_PROJECTION=FALSE
           OUTPUT_EDGES = TRUE
        } TEMP=err_edge
        SELECT eol_ext INTERACT err_edge { } TEMP=eol_ext
      } else {
        EXTERNAL end_of_line target_top {
           SPACING < stubSpacing
           SET_CORNERS_TO_SPACING=FALSE
           PARALLEL_POINT_PROJECTION=FALSE
           OUTPUT_EDGES = TRUE
        } TEMP=err_edge
        SELECT end_of_line INTERACT err_edge { } TEMP=eol_body
        SIZE end_of_line {
           VSIZE_HEAD = sideStubExt
           VSIZE_TAIL = sideStubExt
           OUTPUT_EDGES = TRUE
        } TEMP = eol_ext
        BOOLEAN eol_ext NOT end_of_line {} TEMP=eol_ext
        EXTERNAL eol_ext target_top {
           SPACING < stubSpacing
           SET_CORNERS_TO_SPACING=FALSE
           PARALLEL_POINT_PROJECTION=FALSE
           OUTPUT_EDGES = TRUE
        } TEMP=err_edge
        SELECT eol_ext INTERACT err_edge { } TEMP=eol_ext
        BOOLEAN eol_body OR eol_ext { } TEMP=eol_ext
      } 
    } else {
      COPY end_of_line { } TEMP=eol_ext
    }
    SELECT side_edge INTERACT eol_ext { } TEMP=side_edge
    SIZE eol_ext {
       VSIZE_INSIDE = sideStubThreshold 
       VSIZE_OUTSIDE = sideStubExt
    } TEMP = eol_range
    if (sideStubExt > 0) {
       SIZE side_edge {
          VSIZE_HEAD = sideStubExt
          VSIZE_TAIL = sideStubExt
          OUTPUT_EDGES = TRUE
       } TEMP = check_edge
    } else {
       COPY side_edge { } TEMP = check_edge
    }
    BOOLEAN check_edge AND eol_range { } TEMP=check_edge
    EXTERNAL check_edge target_top {
       SPACING < temporary_1
       SET_CORNERS_TO_SPACING = FALSE
       SHADOW_OTHER_LAYER = TRUE
       PARALLEL_POINT_PROJECTION = FALSE
       OUTPUT_EDGES = TRUE
    } TEMP=err_edge
    if (0 && stubMode!=4) { /* Temporarily do not check mode 2,3 side edge length */
       LENGTH side_edge { SPACING < stubSpacing- 0.0005 *2 } TEMP=err_edge_1
       BOOLEAN err_edge OR err_edge_1 { } TEMP=err_edge
    }
    SELECT check_edge INTERACT err_edge { } TEMP=side_edge
    if (stubMode!=3) {
       SELECT eol_ext INTERACT side_edge {} TEMP=err_eol
       EXTERNAL err_eol target_top {
          COMMENT = "$layer_name specEoLSpc: spacing= stubSpacing ,crnKeepOut= sideStubExt um (mode = stubMode )"
          SPACING < temporary_1
          PARALLEL_POINT_PROJECTION=FALSE
          SET_CORNERS_TO_SPACING=FALSE
       } (13 )
    } else { /* stubMode == 3 */
       SELECT eol_ext INTERACT side_edge { RANGE = [2, 2] } TEMP=err_eol
       EXTERNAL err_eol target_top {
          COMMENT = "$layer_name specEoLSpc: spacing= stubSpacing um (mode = 3)"
          SPACING < temporary_1
          PARALLEL_POINT_PROJECTION=FALSE
          SET_CORNERS_TO_SPACING=FALSE
       } (13 )
    }
  }
} /* stubMode > 0, not aligned */
/* Avoid empty optimization result parsing error */
if (addEmptyMetalCheck) {
   BOOLEAN empty OR empty {
      COMMENT = "$layer_name Empty: Dummy Output"
   } (13 )
   SET addEmptyMetalCheck=0;
}
/* reset variables */


 
SET minWidth = 0;
SET maxWidth = 0;
SET minArea = 0;
SET minEnclosedArea = 0;
SET minSpacing = 0;
SET sameNetMinSpacing = 0;
SET maxNumMinEdge = 0;
SET maxTotalMinEdgeLength = 0;
SET minEdgeLength = 0;
SET minEdgeLength2 = 0;
SET minEdgeLength3 = 0;
SET stubRange = 0;
SET stubSpacing = 0;
SET stub2StubSpacing = 0;
SET sideStubExt = 0;
SET sideStubThreshold = 0;
SET stubThreshold = 0;
SET fatPolyContactRule = 0;
SET fatWireThreshold = 0;
SET fatThinMinSpacing = 0;
SET fatFatMinSpacing = 0;
SET fatTblDimension = 0;
@ 238 "adrc/adrc.ev" 2









/*metal 4*/
SET layer_name = "Met4";










SET minWidth = 0.16;
SET maxWidth = 1000;
SET minArea = 0.07;
SET minSpacing = 0.16;
SET stub2StubSpacing = 0;

SET fatTblDimension = 0;
@ 1 "adrc/adrc_check_metal.ev" 1
/* Data Preparation */
if (fatTblDimension > 1 || fatWireThreshold > 0 || maxWidth > 0) {
  if (ignoreBlockage) {
      /* Let the real blockage be treated as thin */
      BOOLEAN metal4  NOT metal4_rbkg  {} TEMP=fat_candidate
  } else {
      COPY metal4  {} TEMP=fat_candidate
  }
  COPY fat_candidate {} TEMP=fat_target
}
/*Check width*/
if (minWidth > 0) {
    INTERNAL metal4  { 
        COMMENT = "$layer_name MinWidth  : minimum width = minWidth um" 
        SPACING < minWidth
        POINT_TOUCH = FALSE
    } (14 )
}
 
if (maxWidth > 0) {
    SIZE  fat_candidate {
        COMMENT = "$layer_name MaxWidth  : maximum width = maxWidth um"
 	UNDER_OVER = maxWidth / 2 
    } (14 ) 
}
 
/*Check area*/
if (minArea > 0) {
    AREA metal4  { 
	COMMENT = "$layer_name MinArea   : minimum area = minArea um*um"
	RANGE = [0.0005 * 0.0005 , minArea - 0.0005 * 0.0005 ]
    } (14 )
}
/* check min length of bounding box on polygon */
if (minLength > 0) {
  if (minLengthMode == 1) {
    INTERNAL metal4  {
        SPACING < minLength
        VERTICAL_ONLY = TRUE
        SET_CORNERS_TO_SPACING = FALSE
    } TEMP = ver_short
    BOOLEAN metal4  NOT ver_short { } TEMP = ver_long
    INTERNAL metal4  {
        SPACING < minLength
        HORIZONTAL_ONLY = TRUE
        SET_CORNERS_TO_SPACING = FALSE
    } TEMP = hor_short
    BOOLEAN metal4  NOT hor_short { } TEMP = hor_long
    SELECT CUT_LAYER1 INSIDE ver_long { } TEMP = good_cut
    BOOLEAN CUT_LAYER1 NOT good_cut { } TEMP = fail_cut_1
    SELECT fail_cut_1 INSIDE hor_long { } TEMP = good_cut
    BOOLEAN fail_cut_1 NOT good_cut { } TEMP = fail_cut_1
    SELECT CUT_LAYER2 INSIDE ver_long { } TEMP = good_cut
    BOOLEAN CUT_LAYER2 NOT good_cut { } TEMP = fail_cut_2
    SELECT fail_cut_2 INSIDE hor_long { } TEMP = good_cut
    BOOLEAN fail_cut_2 NOT good_cut { } TEMP = fail_cut_2
    BOOLEAN fail_cut_1 OR fail_cut_2 { } TEMP = fail_cut
    BOOLEAN hor_short NOT ver_long { } TEMP = hor_short
    BOOLEAN ver_short NOT hor_long { } TEMP = ver_short
    SELECT ver_short INTERACT fail_cut { } TEMP = ver_fail
    SELECT hor_short INTERACT fail_cut { } TEMP = hor_fail
    BOOLEAN ver_fail OR hor_fail { } TEMP = all_fail
    INTERNAL all_fail {
        COMMENT = "$layer_name MinLength : minimum length = minLength um"
        SPACING < minLength
        VERTICAL_ONLY = TRUE
        SET_CORNERS_TO_SPACING = FALSE
    } (14 )
  } else {
    POLYGON_FEATURES metal4  {
      COMMENT = "$layer_name MinLength : minimum length = minLength um"
      EQUATIONS {
        vnum = EV_VNUM_IN;
        if ( vnum > 0) {
	  bdLeft = EV_VXCOORD_IN[0];
	  bdRight = EV_VXCOORD_IN[0];
	  bdBottom = EV_VYCOORD_IN[0];
	  bdTop = EV_VYCOORD_IN[0];
          FOR (i = 1; i < vnum; i++) {
	    if (bdLeft > EV_VXCOORD_IN[i]) bdLeft = EV_VXCOORD_IN[i];
            else if (bdRight < EV_VXCOORD_IN[i]) bdRight = EV_VXCOORD_IN[i];
	    if (bdBottom > EV_VYCOORD_IN[i]) bdBottom = EV_VYCOORD_IN[i];
            else if (bdTop < EV_VYCOORD_IN[i]) bdTop = EV_VYCOORD_IN[i];
          }
	  if ( (bdRight - bdLeft) < minLength &&
	       (bdTop - bdBottom) < minLength) {
	    FOR (i = 0; i < vnum; i++) {
              EV_VXCOORD_OUT[i] = EV_VXCOORD_IN[i];
	      EV_VYCOORD_OUT[i] = EV_VYCOORD_IN[i];
            }
	    EV_VNUM_OUT = vnum;
	    EV_SAVE_POLYGON();
          }
        }
      }
    } (14 ) 
  }
  SET minLength = 0;
}
/* check max length of bounding box on polygon */
if (maxLength > 0) {
  POLYGON_FEATURES metal4  {
    COMMENT = "$layer_name MaxLength : maximum length = maxLength um"
    EQUATIONS {
      vnum = EV_VNUM_IN;
      if ( vnum > 0) {
	bdLeft = EV_VXCOORD_IN[0];
	bdRight = EV_VXCOORD_IN[0];
	bdBottom = EV_VYCOORD_IN[0];
	bdTop = EV_VYCOORD_IN[0];
        FOR (i = 1; i < vnum; i++) {
	  if (bdLeft > EV_VXCOORD_IN[i]) bdLeft = EV_VXCOORD_IN[i];
          else if (bdRight < EV_VXCOORD_IN[i]) bdRight = EV_VXCOORD_IN[i];
	  if (bdBottom > EV_VYCOORD_IN[i]) bdBottom = EV_VYCOORD_IN[i];
          else if (bdTop < EV_VYCOORD_IN[i]) bdTop = EV_VYCOORD_IN[i];
        }
	if ( (bdRight - bdLeft + bdTop - bdBottom) > maxLength ) {
          EV_VXCOORD_OUT[0] = bdLeft;
	  EV_VYCOORD_OUT[0] = bdBottom;
          EV_VXCOORD_OUT[1] = bdLeft;
	  EV_VYCOORD_OUT[1] = bdTop;
          EV_VXCOORD_OUT[2] = bdRight;
	  EV_VYCOORD_OUT[2] = bdTop;
          EV_VXCOORD_OUT[3] = bdRight;
	  EV_VYCOORD_OUT[3] = bdBottom;
          EV_VXCOORD_OUT[4] = bdLeft;
	  EV_VYCOORD_OUT[4] = bdBottom;
	  EV_VNUM_OUT = 5;
	  EV_SAVE_POLYGON();
        }
      }
    }
  } (14 ) 
  SET maxLength = 0;
}
 
/*Check enclosed area*/
if (minEnclosedArea > 0) {
    SELECT metal4  INSIDE_HOLE {
        INNER_HOLE_ONLY
    } TEMP = holes
    BOOLEAN holes NOT metal4  { } TEMP = holes
 
    AREA holes {
        COMMENT = "$layer_name EnclsArea : minimum enclosed area = minEnclosedArea um*um"
        RANGE = [0.0005 * 0.0005 , minEnclosedArea - 0.0005 * 0.0005 ]
    } (14 )
    /* check min length of bounding box on polygon */
    if (minEnclosedWidth > 0) {
      POLYGON_FEATURES holes {
        COMMENT = "$layer_name EnclsWidth: minimum enclosed Width = minEnclosedWidth um"
        EQUATIONS {
          vnum = EV_VNUM_IN;
          if ( vnum > 0) {
            bdLeft = EV_VXCOORD_IN[0];
            bdRight = EV_VXCOORD_IN[0];
            bdBottom = EV_VYCOORD_IN[0];
            bdTop = EV_VYCOORD_IN[0];
            FOR (i = 1; i < vnum; i++) {
              if (bdLeft > EV_VXCOORD_IN[i]) bdLeft = EV_VXCOORD_IN[i];
              else if (bdRight < EV_VXCOORD_IN[i]) bdRight = EV_VXCOORD_IN[i];
              if (bdBottom > EV_VYCOORD_IN[i]) bdBottom = EV_VYCOORD_IN[i];
              else if (bdTop < EV_VYCOORD_IN[i]) bdTop = EV_VYCOORD_IN[i];
            }
            if ( (bdRight - bdLeft) < minEnclosedWidth &&
                 (bdTop - bdBottom) < minEnclosedWidth) {
              FOR (i = 0; i < vnum; i++) {
                EV_VXCOORD_OUT[i] = EV_VXCOORD_IN[i];
                EV_VYCOORD_OUT[i] = EV_VYCOORD_IN[i];
              }
              EV_VNUM_OUT = vnum;
              EV_SAVE_POLYGON();
            }
          }
        }
      } (14 ) 
    }
}
 
/*check special notch rule*/
if ((minEdgeLength2 > 0.0005  && minEdgeLength3 > 0.0005 ) || minEdgeMode==2) {
  if (minEdgeMode==2) {
    SET minEdgeLength3 = minEdgeLength ;
  }
  NOTCH metal4  {
     SPACING < minEdgeLength3
     SET_CORNERS_TO_SPACING=FALSE
     PARALLEL = TRUE
     OUTPUT_EDGES = TRUE
  } TEMP = notch_vectors
  SELECT_VECTOR notch_vectors {
     LENGTH_RANGE = [0.0005 , minEdgeLength2 - 0.0005 ]
  } TEMP = short_edges
  EXTERNAL short_edges metal4  {
     SPACING < minEdgeLength3
     SET_CORNERS_TO_SPACING=FALSE
     PARALLEL = TRUE
  } TEMP = notch_err
  /* Choose the real U-shaped notch */
  SIZE notch_err { OVERSIZE = 0.001 *10 } TEMP = neighbors 
  BOOLEAN neighbors AND metal4  { } TEMP = neighbors
  VERTEX neighbors { 
     CONCAVE = TRUE
     CONVEX = TRUE
     SIZE = 0.001 
  } TEMP = corners
  SELECT_EDGE neighbors INTERACT notch_err { } TEMP = target_edges
  BOOLEAN target_edges NOT corners { } TEMP = target_edges
  VERTEX neighbors { 
     CONCAVE = TRUE
     SIZE = 2* 0.001 
  } TEMP = corners
  SELECT target_edges INTERACT corners { RANGE = [2, 2] } TEMP=target_edges
  SELECT notch_err INTERACT target_edges {
     COMMENT = "$layer_name SpeclNotch: sameNetSp = minEdgeLength3 um (sideLen minEdgeLength2 um)" 
  } (14 )
}
/*check consecutive short edges*/
if (minEdgeLength > 0.0005  && minEdgeMode != 2) { 
  INTERNAL metal4_top  {
     SEGMENT < minEdgeLength
     FLAG_ACUTE_ANGLE = FALSE
     FLAG_ACUTE_EDGE = FALSE
     OUTPUT_EDGES = TRUE
  } TEMP = short_edges
  if ((minEdgeMode == 0 && maxTotalMinEdgeLength>0) || maxNumMinEdge > 0) {
    SET temporary_1 = 0.001 *2;
    SET temporary_2 = 2*temporary_1+ 0.0005 ;
    SELECT metal4_top  INTERACT short_edges { } TEMP = target_top
    CLASSIFY_EDGES target_top {
       LENGTH = temporary_1
       DMIN   = temporary_2
       INSIDE_CORNER  TEMP = inside_corner_edges
       OUTSIDE_CORNER TEMP = outside_corner_edges
       REMAINDER      TEMP = remainder_edges
    }
    if (minEdgeMode == 0 && (maxNumMinEdge>0 || maxTotalMinEdgeLength > 0)) {
       SELECT short_edges ENCLOSING inside_corner_edges { } TEMP = short_edges
    }
  }
  if (maxTotalMinEdgeLength > 0) {
    LENGTH short_edges {
       RANGE = [maxTotalMinEdgeLength + 0.0005 , 9999999999 ]
    } TEMP = max_length_err
    /* Work around: translate polygons into dimensional check output */
    SIZE max_length_err { OVERSIZE = 2* 0.001  } TEMP = max_length_err
    INTERNAL max_length_err {
       SPACING < 3* 0.001 
       SET_CORNERS_TO_SPACING=FALSE
       COMMENT = "$layer_name MinEdgeLen: maximum total length ( minEdgeLength um)= maxTotalMinEdgeLength um"
    } (14 )
  }
  if (maxTotalMinEdgeLength == 0 || maxNumMinEdge > 0) {
    if (maxNumMinEdge==0)  {
       COPY short_edges {} TEMP=max_edge_err
    } else {
       SIZE short_edges {
         VSIZE_HEAD = - 0.001 
        VSIZE_TAIL = - 0.001 
       } TEMP = short_edges
       SIZE short_edges {
          OVERSIZE = 5* 0.001 
          SIZE_ENDPOINTS = FALSE
       } TEMP = short_contours
       SELECT short_contours ENCLOSING remainder_edges {
          RANGE = [maxNumMinEdge + 1, 9999999999 ]
       } TEMP = short_contours
       SELECT short_edges INSIDE short_contours { } TEMP=max_edge_err
    }
    /* Work around: translate polygons into dimensional check output */
    SIZE max_edge_err { OVERSIZE = 2* 0.001  } TEMP = max_edge_error
    INTERNAL max_edge_error {
       SPACING < 3* 0.001 
       SET_CORNERS_TO_SPACING=FALSE
       COMMENT = "$layer_name MinEdgeLen: maximum number of consecutive short edges ( minEdgeLength um)= maxNumMinEdge"
    } (14 ) 
  }
}
 
/*check basic spacing*/
if (sameNetMinSpacing > 0 && sameNetMinSpacing != minSpacing) {
  if (sameNetMinSpacing > minSpacing) {
    /* Special condition for U-shaped Metal spacing rule */
    NOTCH metal4_pin  {
        SPACING < sameNetMinSpacing
        BOX_CORNER = FALSE 
        SET_CORNERS_TO_SPACING=FALSE
        NON_PARALLEL = TRUE
        OUTPUT_EDGES = TRUE
    } TEMP = errs_to_be_waived
    NOTCH metal4_top  {
	SPACING < sameNetMinSpacing
	BOX_CORNER = FALSE 
        SET_CORNERS_TO_SPACING=FALSE
	NON_PARALLEL = TRUE
        OUTPUT_EDGES = TRUE
    } TEMP = all_errs
    BOOLEAN all_errs NOT errs_to_be_waived { } TEMP=err_edge
    EXTERNAL err_edge metal4_top  {
	SPACING < sameNetMinSpacing
	BOX_CORNER = FALSE 
        SET_CORNERS_TO_SPACING=FALSE
	NON_PARALLEL = TRUE
    } TEMP = notch_err
    SIZE notch_err { OVERSIZE = 0.001 *10 } TEMP = neighbors
    BOOLEAN neighbors AND metal4_top  { } TEMP = neighbors
    VERTEX neighbors { 
       CONCAVE = TRUE
       CONVEX = TRUE
       SIZE = 0.001 
    } TEMP = corners
    SELECT_EDGE neighbors INTERACT notch_err { } TEMP = target_edges
    BOOLEAN target_edges AND notch_err { } TEMP = target_edges
    BOOLEAN target_edges NOT corners { } TEMP = target_edges
    VERTEX neighbors {
       CONCAVE = TRUE
       SIZE = 2* 0.001 
    } TEMP = corners
    SELECT target_edges INTERACT corners { RANGE = [2, 2] } TEMP = target_edges
    SELECT notch_err TOUCHING target_edges {
      COMMENT = "$layer_name U-ShpNotch: U-shape notch minimum spacing = sameNetMinSpacing um" 
    } (14 )
  } else {
    NOTCH metal4  {
        COMMENT = "$layer_name SameNetSpc: same-net minimum spacing = sameNetMinSpacing um" 
	SPACING < sameNetMinSpacing
	BOX_CORNER = FALSE 
	NON_PARALLEL = TRUE
    } (14 )
  }
  if (minSpacing > 0) {
    if (stubMode == 0 && stubSpacing > 0 && stubSpacing < minSpacing) {
	EXTERNAL metal4  {
	    COMMENT = "$layer_name Spacing   : minimum spacing = minSpacing um"
            LONGEDGE > stubThreshold + 0.0005 
	    LONGEDGE_TO_EDGE < minSpacing
	    SPACING <= 0
	    BOX_CORNER = FALSE 
	    NON_PARALLEL = TRUE
            POINT_TOUCH = TRUE
            CHECK_SAME_POLYGON = TRUE 
	} (14 )
    } else {
        EXTERNAL metal4  {
	    COMMENT = "$layer_name Spacing   : minimum spacing = minSpacing um" 
	    SPACING < minSpacing
	    BOX_CORNER = FALSE 
	    NON_PARALLEL = TRUE
            POINT_TOUCH = TRUE
	    CHECK_SAME_POLYGON = FALSE
        } (14 )
    }
  }
} else {
  if (minSpacing > 0) {
    if (stubMode == 0 && stubSpacing > 0 && stubSpacing < minSpacing) {
        EXTERNAL metal4  {
            COMMENT = "$layer_name Spacing   : minimum spacing = minSpacing um"
            LONGEDGE > stubThreshold + 0.0005  
            LONGEDGE_TO_EDGE < minSpacing
            SPACING <= 0 
            BOX_CORNER = FALSE 
            NON_PARALLEL = TRUE
            POINT_TOUCH = TRUE
            CHECK_SAME_POLYGON = TRUE 
        } (14 )
    } else {
        EXTERNAL metal4  {
	    COMMENT = "$layer_name Spacing   : minimum spacing = minSpacing um" 
            SPACING < minSpacing
	    BOX_CORNER = FALSE 
	    NON_PARALLEL = TRUE
	    POINT_TOUCH = TRUE
	    CHECK_SAME_POLYGON = TRUE 
        } (14 )
    }
  }
}
 
/*check dogbone */
if (sameNetMinSpacing > 0 && sameNetWidthThreshold) {
  NOTCH metal4  {
    SPACING < sameNetMinSpacing
    BOX_CORNER = FALSE 
    NON_PARALLEL = TRUE
  } TEMP = dog_bone
 
  if (!layer_empty(dog_bone)) {
    SIZE dog_bone {EDGESIZE = sameNetWidthThreshold} TEMP = dog_ext
    BOOLEAN dog_ext NOT dog_bone {} TEMP = dog_ext
    BOOLEAN dog_ext AND metal4  {} TEMP = dog_ext
    if (!layer_empty(dog_ext)) {
      SELECT dog_ext EDGE_TOUCH dog_bone { OUTSIDE RANGE = [1, 9999999999 ] } TEMP = dog_ext
      NOTCH metal4  {
        SPACING < sameNetMinSpacing
        BOX_CORNER = FALSE 
        NON_PARALLEL = TRUE
	OUTPUT_EDGES = TRUE
      } TEMP = dog_bone
      SELECT dog_ext OUTSIDE dog_bone {} TEMP = dog_ext
      INTERNAL dog_ext {
	COMMENT = "$layer_name dogBone   : notch spacing = sameNetMinSpacing um width sameNetWidthThreshold um" 
	SPACING < sameNetWidthThreshold
      } (14 )
    }
  }
}
/*check basic fat spacing*/
if (fatWireThreshold > 0 && fatTblDimension == 0) {
    SIZE fat_candidate { UNDER_OVER = fatWireThreshold / 2.0 - 0.0005  } TEMP = m_fat
    BOOLEAN m_fat AND metal4  {  } TEMP = m_fat
    BOOLEAN metal4  NOT m_fat {  } TEMP = m_thin
    if (ignoreBlockage == 0) {
        /* the blockages on the metal_blockage layer are treated as thin blockages */
        BOOLEAN m_thin OR metal4_blockage  {  } TEMP = m_thin
    }
 
    if (fatFatMinSpacing > 0) {
	EXTERNAL m_fat {
	    COMMENT = "$layer_name FatWireSpc: fat & fat ( fatWireThreshold um) minimum spacing = fatFatMinSpacing um"
	    SPACING < fatFatMinSpacing
	    BOX_CORNER = FALSE 
	    NON_PARALLEL = TRUE
	    POINT_TOUCH = FALSE
	    CHECK_SAME_POLYGON = TRUE 
       } (14 )
    }
 
    if (fatThinMinSpacing > 0) {
	EXTERNAL m_fat m_thin {
	    COMMENT = "$layer_name FatWireSpc: fat & thin ( fatWireThreshold um) minimum spacing fatThinMinSpacing um"
	    SPACING < fatThinMinSpacing
 	    BOX_CORNER = FALSE 
	    NON_PARALLEL = TRUE
	    POINT_TOUCH = FALSE
        } (14 )
    }
}
 
/*check thin blockage spacing*/
if (minSpacing > 0 && ignoreBlockage == 0) {
    if (!layer_empty (metal4_blockage )) {
	EXTERNAL metal4_blockage  metal4  {
	    COMMENT = "$layer_name Spacing   : metal & thin blockage minimum spacing = minSpacing um"
	    SPACING < minSpacing
	    BOX_CORNER = FALSE 
	    NON_PARALLEL = TRUE
	    POINT_TOUCH = TRUE
            TOUCH = TRUE
        } (14 )
    }
}
/*check blockage overlap*/
/*check shorts between top_level routing and fram_blockages*/
if (minSpacing>0 || checkCrossHierShort>0) {
   if (ignoreBlockage == 0) {
      BOOLEAN metal4_blockage  or metal4_rbkg  {} TEMP=all_blockage
   } else {
      COPY metal4_rbkg  {} TEMP=all_blockage
   }
   BOOLEAN all_blockage AND metal4_top  {} TEMP = overlap_shape1
   EXTERNAL all_blockage metal4_top  {
      SPACING <= 0
      TOUCH = TRUE
   } TEMP = overlap_shape2
   if (checkCrossHierShort>0) {
      BOOLEAN overlap_shape1 OR overlap_shape2 {
         COMMENT = "$layer_name Short Cross Hierarchy"
      } (14 )
   } else {
      BOOLEAN overlap_shape1 OR overlap_shape2 {
         COMMENT = "$layer_name Overlap   : metal & blockage overlap"
      } (14 )
   }
}
 
if (fatPolyContactRule > 0) {
  /* Fat Poly Contact Rule: not new fat wire formed */
  if (readCellView > 0) {
     SIZE metal1 { UNDER_OVER = fatPolyContactRule / 2.0 - 0.0005  } TEMP = fat
     BOOLEAN fat AND metal1 {  } TEMP = fat 
  } else {
     SIZE metal1_top { UNDER_OVER = fatPolyContactRule / 2.0 - 0.0005  } TEMP = fat
     BOOLEAN fat AND metal1_top {  } TEMP = fat 
  }
  SIZE metal1_pin { UNDER_OVER = fatPolyContactRule / 2.0 - 0.0005  } TEMP = fat_pin
  BOOLEAN fat_pin AND metal1_pin {  } TEMP = fat_pin
  BOOLEAN fat NOT fat_pin {
    COMMENT = "$layer_name FatPolyContactRule: fatPolyContactRule um" 
  } (14 )
}
/* Special End-of-Line Spacing Rule */
if (stubMode == 0 && stubSpacing > 0 && stubSpacing < minSpacing) {
  EXTERNAL metal4  {
     COMMENT = "$layer_name specEoLSpc: spacing= stubSpacing um (mode = 0)"
     LONGEDGE > stubThreshold + 0.0005 
     LONGEDGE_TO_EDGE <= 0 
     SPACING < stubSpacing 
     SET_CORNERS_TO_SPACING = FALSE
     PARALLEL_POINT_PROJECTION = FALSE
  } (14 )
} else if (stubMode > 0 && stubSpacing > minSpacing) {
  if (stubMode == 4) {
     INTERNAL metal4  {
        SEGMENT[90,90] < stubThreshold
        OUTPUT_EDGES = TRUE
     } TEMP = end_of_line
  } else {
     INTERNAL metal4  {
        SEGMENT[90,90] <= stubThreshold
        OUTPUT_EDGES = TRUE
     } TEMP = end_of_line
  }
  /* Quick filter to reduce the size of possible end of line */
  if (sideStubExt > 0) {
    SIZE end_of_line {
       VSIZE_HEAD = sideStubExt
       VSIZE_TAIL = sideStubExt
       OUTPUT_EDGES = TRUE
    } TEMP = eol_ext
  } else {
    COPY end_of_line { } TEMP=eol_ext
  }
  if (stub2StubSpacing > stubSpacing) {
     SET temporary_1 = stub2StubSpacing;
  } else {
     SET temporary_1 = stubSpacing; 
  }
  EXTERNAL eol_ext metal4  {
     SPACING < temporary_1
     TOUCH = TRUE
     OVERLAP = TRUE 
     SET_CORNERS_TO_SPACING = FALSE
     PARALLEL_POINT_PROJECTION = FALSE
     OUTPUT_EDGES = TRUE
  } TEMP=err_edge
  SELECT eol_ext INTERACT err_edge { } TEMP=eol_ext
  SELECT end_of_line INTERACT eol_ext { } TEMP=end_of_line 
  /* Reduce the size of METAL_LAYER */
  if (stubMode==3) {
     SIZE end_of_line {
        VSIZE_HEAD = stubSpacing 
        VSIZE_TAIL = stubSpacing 
        VSIZE_INSIDE = sideStubThreshold
        VSIZE_OUTSIDE = stubSpacing
     } TEMP = eol_filter 
  } else {
     if (stubMode == 1 && stubRange > 0) {
        SIZE end_of_line {
           VSIZE_HEAD = stubSpacing- 0.0005 
           VSIZE_TAIL = stubSpacing- 0.0005 
           VSIZE_OUTSIDE = stubSpacing- 0.0005 
        } TEMP = eol_filter
     } else {
        SIZE end_of_line {
           VSIZE_HEAD = stubSpacing- 0.0005 
           VSIZE_TAIL = stubSpacing- 0.0005 
           VSIZE_INSIDE = sideStubThreshold- 0.0005 
           VSIZE_OUTSIDE = stubSpacing- 0.0005 
        } TEMP = eol_filter
     }
  }
  SELECT metal4  INTERACT eol_filter { } TEMP=target_top
  /* Get the side edges and the whole eol of line set */
  SELECT_EDGE target_top INTERACT end_of_line { 
    POINT_TOUCH = TRUE
  } TEMP = eol_set
  VERTEX target_top { 
     CONCAVE = TRUE 
     CONVEX = TRUE
     SIZE = 0.001 
  } TEMP = corners
  SELECT corners OUTSIDE end_of_line {} TEMP =corners 
  BOOLEAN eol_set NOT corners { } TEMP=eol_set
  BOOLEAN eol_set NOT end_of_line { } TEMP=side_edge
  /* find out the real end of line */
  if (stubRange > 0) {
     if (stubMode == 1) {
         COPY side_edge { } TEMP = all_side_edge
         LENGTH side_edge { SPACING <= stubRange- 0.0005  } TEMP=side_edge
     } else {
         LENGTH side_edge { SPACING < stubRange- 0.001  } TEMP=eol_filter
         BOOLEAN side_edge NOT eol_filter { } TEMP=side_edge
     }
     SELECT end_of_line INTERACT side_edge { RANGE = [1,2] } TEMP = end_of_line
  } 
  if (stubMode == 1) {
    if (stub2StubSpacing > 0) {
       if (sideStubExt < 0) {
          SIZE end_of_line {
            VSIZE_HEAD = sideStubExt / 2
            VSIZE_TAIL = sideStubExt / 2
            OUTPUT_EDGES = TRUE
          } TEMP = eol_ext_tip
	 
          EXTERNAL eol_ext_tip {
            COMMENT = "$layer_name specEoLSpc: stub2Stubspacing= stub2StubSpacing um (mode = 1)"
            SPACING < stub2StubSpacing
            SET_CORNERS_TO_SPACING = FALSE
            PARALLEL_POINT_PROJECTION = TRUE
          } (14 )
       } else {
          EXTERNAL end_of_line {
            COMMENT = "$layer_name specEoLSpc: stub2Stubspacing= stub2StubSpacing um (mode = 1)"
            SPACING < stub2StubSpacing
            SET_CORNERS_TO_SPACING = FALSE
            PARALLEL_POINT_PROJECTION = FALSE
          } (14 )
       }
    }
    if (stubRange > 0) {
       SIZE end_of_line {
         VSIZE_INSIDE = 0.001 
       } TEMP = eol_poly
       SELECT_EDGE eol_poly TOUCHING target_top { } TEMP=eol_edge
       EXTERNAL eol_edge target_top {
         COMMENT = "$layer_name specEoLSpc: spacing= stubSpacing um (mode = 1)"
         CONVEX_TO_CONVEX < stubSpacing
         CONVEX_TO_CONVEX [POINT_PROJECTION] < stubSpacing
         CONVEX_TO_EDGE < stubSpacing
         CONCAVE_TO_CONVEX < stubSpacing
         LONGEDGE > 0.001 
         LONGEDGE_TO_EDGE < stubSpacing
         SPACING <= 0
         SET_CORNERS_TO_SPACING = TRUE
         PARALLEL_POINT_PROJECTION = TRUE
       } (14 )
       SELECT all_side_edge INTERACT end_of_line { } TEMP = side_edge
       SIZE side_edge {
         VSIZE_HEAD = 0.001 
         VSIZE_TAIL = 0.001 
       } TEMP = side_edge_ext
       BOOLEAN side_edge_ext NOT side_edge { } TEMP = side_edge_ext
       SELECT side_edge_ext INTERACT end_of_line { } TEMP = side_edge_ext
       EXTERNAL side_edge_ext target_top {
         COMMENT = "$layer_name specEoLSpc: spacing= stubSpacing um (mode = 1)"
         SPACING < stubSpacing
         SET_CORNERS_TO_SPACING = FALSE
         PARALLEL_POINT_PROJECTION = FALSE
       } (14 )
    } else {
       if (stub2StubSpacing > 0) {
         VECTORIZE target_top {
            DIRECTED=TRUE
         } TEMP=target_edges
         BOOLEAN target_edges NOT end_of_line { } TEMP = target_edges
         EXTERNAL end_of_line target_edges {
            COMMENT = "$layer_name specEoLSpc: spacing= stubSpacing um (mode = 1)"
            SPACING < stubSpacing
            TOUCH=TRUE
            OVERLAP=TRUE
            SET_CORNERS_TO_SPACING=FALSE
            PARALLEL_POINT_PROJECTION=FALSE
         } (14 )
       } else {
         if (sideStubExt > 0) {
            SIZE end_of_line {
               VSIZE_HEAD = sideStubExt
               VSIZE_TAIL = sideStubExt
               OUTPUT_EDGES = TRUE
            } TEMP = end_of_line
            EXTERNAL end_of_line target_top {
               COMMENT = "$layer_name specEoLSpc: spacing= stubSpacing ,crnKeepOut= sideStubExt um (mode = 1)"
               SPACING < stubSpacing
               TOUCH=TRUE
               OVERLAP=TRUE
               SET_CORNERS_TO_SPACING=FALSE
               PARALLEL_POINT_PROJECTION=FALSE
            } (14 )
         } else {
            EXTERNAL end_of_line target_top {
               COMMENT = "$layer_name specEoLSpc: spacing= stubSpacing um (mode = 1)"
               SPACING < stubSpacing
               TOUCH=TRUE
               OVERLAP=TRUE
               SET_CORNERS_TO_SPACING=FALSE
               PARALLEL_POINT_PROJECTION=FALSE
            } (14 )
         }
       }
    }
  } else { /* stubMode == 2,3,4 */
    /* stubMode 2 eol classify and reduction */
    if (stubMode !=3 && sideStubExt > 0) {
      if (stubMode == 4) {
        SIZE end_of_line {
           VSIZE_HEAD = sideStubExt
           VSIZE_TAIL = sideStubExt
           OUTPUT_EDGES = TRUE
        } TEMP = eol_ext
        EXTERNAL eol_ext target_top {
           SPACING < stubSpacing
           SET_CORNERS_TO_SPACING=FALSE
           PARALLEL_POINT_PROJECTION=FALSE
           OUTPUT_EDGES = TRUE
        } TEMP=err_edge
        SELECT eol_ext INTERACT err_edge { } TEMP=eol_ext
      } else {
        EXTERNAL end_of_line target_top {
           SPACING < stubSpacing
           SET_CORNERS_TO_SPACING=FALSE
           PARALLEL_POINT_PROJECTION=FALSE
           OUTPUT_EDGES = TRUE
        } TEMP=err_edge
        SELECT end_of_line INTERACT err_edge { } TEMP=eol_body
        SIZE end_of_line {
           VSIZE_HEAD = sideStubExt
           VSIZE_TAIL = sideStubExt
           OUTPUT_EDGES = TRUE
        } TEMP = eol_ext
        BOOLEAN eol_ext NOT end_of_line {} TEMP=eol_ext
        EXTERNAL eol_ext target_top {
           SPACING < stubSpacing
           SET_CORNERS_TO_SPACING=FALSE
           PARALLEL_POINT_PROJECTION=FALSE
           OUTPUT_EDGES = TRUE
        } TEMP=err_edge
        SELECT eol_ext INTERACT err_edge { } TEMP=eol_ext
        BOOLEAN eol_body OR eol_ext { } TEMP=eol_ext
      } 
    } else {
      COPY end_of_line { } TEMP=eol_ext
    }
    SELECT side_edge INTERACT eol_ext { } TEMP=side_edge
    SIZE eol_ext {
       VSIZE_INSIDE = sideStubThreshold 
       VSIZE_OUTSIDE = sideStubExt
    } TEMP = eol_range
    if (sideStubExt > 0) {
       SIZE side_edge {
          VSIZE_HEAD = sideStubExt
          VSIZE_TAIL = sideStubExt
          OUTPUT_EDGES = TRUE
       } TEMP = check_edge
    } else {
       COPY side_edge { } TEMP = check_edge
    }
    BOOLEAN check_edge AND eol_range { } TEMP=check_edge
    EXTERNAL check_edge target_top {
       SPACING < temporary_1
       SET_CORNERS_TO_SPACING = FALSE
       SHADOW_OTHER_LAYER = TRUE
       PARALLEL_POINT_PROJECTION = FALSE
       OUTPUT_EDGES = TRUE
    } TEMP=err_edge
    if (0 && stubMode!=4) { /* Temporarily do not check mode 2,3 side edge length */
       LENGTH side_edge { SPACING < stubSpacing- 0.0005 *2 } TEMP=err_edge_1
       BOOLEAN err_edge OR err_edge_1 { } TEMP=err_edge
    }
    SELECT check_edge INTERACT err_edge { } TEMP=side_edge
    if (stubMode!=3) {
       SELECT eol_ext INTERACT side_edge {} TEMP=err_eol
       EXTERNAL err_eol target_top {
          COMMENT = "$layer_name specEoLSpc: spacing= stubSpacing ,crnKeepOut= sideStubExt um (mode = stubMode )"
          SPACING < temporary_1
          PARALLEL_POINT_PROJECTION=FALSE
          SET_CORNERS_TO_SPACING=FALSE
       } (14 )
    } else { /* stubMode == 3 */
       SELECT eol_ext INTERACT side_edge { RANGE = [2, 2] } TEMP=err_eol
       EXTERNAL err_eol target_top {
          COMMENT = "$layer_name specEoLSpc: spacing= stubSpacing um (mode = 3)"
          SPACING < temporary_1
          PARALLEL_POINT_PROJECTION=FALSE
          SET_CORNERS_TO_SPACING=FALSE
       } (14 )
    }
  }
} /* stubMode > 0, not aligned */
/* Avoid empty optimization result parsing error */
if (addEmptyMetalCheck) {
   BOOLEAN empty OR empty {
      COMMENT = "$layer_name Empty: Dummy Output"
   } (14 )
   SET addEmptyMetalCheck=0;
}
/* reset variables */


 
SET minWidth = 0;
SET maxWidth = 0;
SET minArea = 0;
SET minEnclosedArea = 0;
SET minSpacing = 0;
SET sameNetMinSpacing = 0;
SET maxNumMinEdge = 0;
SET maxTotalMinEdgeLength = 0;
SET minEdgeLength = 0;
SET minEdgeLength2 = 0;
SET minEdgeLength3 = 0;
SET stubRange = 0;
SET stubSpacing = 0;
SET stub2StubSpacing = 0;
SET sideStubExt = 0;
SET sideStubThreshold = 0;
SET stubThreshold = 0;
SET fatPolyContactRule = 0;
SET fatWireThreshold = 0;
SET fatThinMinSpacing = 0;
SET fatFatMinSpacing = 0;
SET fatTblDimension = 0;
@ 266 "adrc/adrc.ev" 2









/*metal 5*/
SET layer_name = "Met5";










SET minWidth = 0.16;
SET maxWidth = 1000;
SET minArea = 0.07;
SET minSpacing = 0.16;
SET stub2StubSpacing = 0;

SET fatTblDimension = 0;
@ 1 "adrc/adrc_check_metal.ev" 1
/* Data Preparation */
if (fatTblDimension > 1 || fatWireThreshold > 0 || maxWidth > 0) {
  if (ignoreBlockage) {
      /* Let the real blockage be treated as thin */
      BOOLEAN metal5  NOT metal5_rbkg  {} TEMP=fat_candidate
  } else {
      COPY metal5  {} TEMP=fat_candidate
  }
  COPY fat_candidate {} TEMP=fat_target
}
/*Check width*/
if (minWidth > 0) {
    INTERNAL metal5  { 
        COMMENT = "$layer_name MinWidth  : minimum width = minWidth um" 
        SPACING < minWidth
        POINT_TOUCH = FALSE
    } (15 )
}
 
if (maxWidth > 0) {
    SIZE  fat_candidate {
        COMMENT = "$layer_name MaxWidth  : maximum width = maxWidth um"
 	UNDER_OVER = maxWidth / 2 
    } (15 ) 
}
 
/*Check area*/
if (minArea > 0) {
    AREA metal5  { 
	COMMENT = "$layer_name MinArea   : minimum area = minArea um*um"
	RANGE = [0.0005 * 0.0005 , minArea - 0.0005 * 0.0005 ]
    } (15 )
}
/* check min length of bounding box on polygon */
if (minLength > 0) {
  if (minLengthMode == 1) {
    INTERNAL metal5  {
        SPACING < minLength
        VERTICAL_ONLY = TRUE
        SET_CORNERS_TO_SPACING = FALSE
    } TEMP = ver_short
    BOOLEAN metal5  NOT ver_short { } TEMP = ver_long
    INTERNAL metal5  {
        SPACING < minLength
        HORIZONTAL_ONLY = TRUE
        SET_CORNERS_TO_SPACING = FALSE
    } TEMP = hor_short
    BOOLEAN metal5  NOT hor_short { } TEMP = hor_long
    SELECT CUT_LAYER1 INSIDE ver_long { } TEMP = good_cut
    BOOLEAN CUT_LAYER1 NOT good_cut { } TEMP = fail_cut_1
    SELECT fail_cut_1 INSIDE hor_long { } TEMP = good_cut
    BOOLEAN fail_cut_1 NOT good_cut { } TEMP = fail_cut_1
    SELECT CUT_LAYER2 INSIDE ver_long { } TEMP = good_cut
    BOOLEAN CUT_LAYER2 NOT good_cut { } TEMP = fail_cut_2
    SELECT fail_cut_2 INSIDE hor_long { } TEMP = good_cut
    BOOLEAN fail_cut_2 NOT good_cut { } TEMP = fail_cut_2
    BOOLEAN fail_cut_1 OR fail_cut_2 { } TEMP = fail_cut
    BOOLEAN hor_short NOT ver_long { } TEMP = hor_short
    BOOLEAN ver_short NOT hor_long { } TEMP = ver_short
    SELECT ver_short INTERACT fail_cut { } TEMP = ver_fail
    SELECT hor_short INTERACT fail_cut { } TEMP = hor_fail
    BOOLEAN ver_fail OR hor_fail { } TEMP = all_fail
    INTERNAL all_fail {
        COMMENT = "$layer_name MinLength : minimum length = minLength um"
        SPACING < minLength
        VERTICAL_ONLY = TRUE
        SET_CORNERS_TO_SPACING = FALSE
    } (15 )
  } else {
    POLYGON_FEATURES metal5  {
      COMMENT = "$layer_name MinLength : minimum length = minLength um"
      EQUATIONS {
        vnum = EV_VNUM_IN;
        if ( vnum > 0) {
	  bdLeft = EV_VXCOORD_IN[0];
	  bdRight = EV_VXCOORD_IN[0];
	  bdBottom = EV_VYCOORD_IN[0];
	  bdTop = EV_VYCOORD_IN[0];
          FOR (i = 1; i < vnum; i++) {
	    if (bdLeft > EV_VXCOORD_IN[i]) bdLeft = EV_VXCOORD_IN[i];
            else if (bdRight < EV_VXCOORD_IN[i]) bdRight = EV_VXCOORD_IN[i];
	    if (bdBottom > EV_VYCOORD_IN[i]) bdBottom = EV_VYCOORD_IN[i];
            else if (bdTop < EV_VYCOORD_IN[i]) bdTop = EV_VYCOORD_IN[i];
          }
	  if ( (bdRight - bdLeft) < minLength &&
	       (bdTop - bdBottom) < minLength) {
	    FOR (i = 0; i < vnum; i++) {
              EV_VXCOORD_OUT[i] = EV_VXCOORD_IN[i];
	      EV_VYCOORD_OUT[i] = EV_VYCOORD_IN[i];
            }
	    EV_VNUM_OUT = vnum;
	    EV_SAVE_POLYGON();
          }
        }
      }
    } (15 ) 
  }
  SET minLength = 0;
}
/* check max length of bounding box on polygon */
if (maxLength > 0) {
  POLYGON_FEATURES metal5  {
    COMMENT = "$layer_name MaxLength : maximum length = maxLength um"
    EQUATIONS {
      vnum = EV_VNUM_IN;
      if ( vnum > 0) {
	bdLeft = EV_VXCOORD_IN[0];
	bdRight = EV_VXCOORD_IN[0];
	bdBottom = EV_VYCOORD_IN[0];
	bdTop = EV_VYCOORD_IN[0];
        FOR (i = 1; i < vnum; i++) {
	  if (bdLeft > EV_VXCOORD_IN[i]) bdLeft = EV_VXCOORD_IN[i];
          else if (bdRight < EV_VXCOORD_IN[i]) bdRight = EV_VXCOORD_IN[i];
	  if (bdBottom > EV_VYCOORD_IN[i]) bdBottom = EV_VYCOORD_IN[i];
          else if (bdTop < EV_VYCOORD_IN[i]) bdTop = EV_VYCOORD_IN[i];
        }
	if ( (bdRight - bdLeft + bdTop - bdBottom) > maxLength ) {
          EV_VXCOORD_OUT[0] = bdLeft;
	  EV_VYCOORD_OUT[0] = bdBottom;
          EV_VXCOORD_OUT[1] = bdLeft;
	  EV_VYCOORD_OUT[1] = bdTop;
          EV_VXCOORD_OUT[2] = bdRight;
	  EV_VYCOORD_OUT[2] = bdTop;
          EV_VXCOORD_OUT[3] = bdRight;
	  EV_VYCOORD_OUT[3] = bdBottom;
          EV_VXCOORD_OUT[4] = bdLeft;
	  EV_VYCOORD_OUT[4] = bdBottom;
	  EV_VNUM_OUT = 5;
	  EV_SAVE_POLYGON();
        }
      }
    }
  } (15 ) 
  SET maxLength = 0;
}
 
/*Check enclosed area*/
if (minEnclosedArea > 0) {
    SELECT metal5  INSIDE_HOLE {
        INNER_HOLE_ONLY
    } TEMP = holes
    BOOLEAN holes NOT metal5  { } TEMP = holes
 
    AREA holes {
        COMMENT = "$layer_name EnclsArea : minimum enclosed area = minEnclosedArea um*um"
        RANGE = [0.0005 * 0.0005 , minEnclosedArea - 0.0005 * 0.0005 ]
    } (15 )
    /* check min length of bounding box on polygon */
    if (minEnclosedWidth > 0) {
      POLYGON_FEATURES holes {
        COMMENT = "$layer_name EnclsWidth: minimum enclosed Width = minEnclosedWidth um"
        EQUATIONS {
          vnum = EV_VNUM_IN;
          if ( vnum > 0) {
            bdLeft = EV_VXCOORD_IN[0];
            bdRight = EV_VXCOORD_IN[0];
            bdBottom = EV_VYCOORD_IN[0];
            bdTop = EV_VYCOORD_IN[0];
            FOR (i = 1; i < vnum; i++) {
              if (bdLeft > EV_VXCOORD_IN[i]) bdLeft = EV_VXCOORD_IN[i];
              else if (bdRight < EV_VXCOORD_IN[i]) bdRight = EV_VXCOORD_IN[i];
              if (bdBottom > EV_VYCOORD_IN[i]) bdBottom = EV_VYCOORD_IN[i];
              else if (bdTop < EV_VYCOORD_IN[i]) bdTop = EV_VYCOORD_IN[i];
            }
            if ( (bdRight - bdLeft) < minEnclosedWidth &&
                 (bdTop - bdBottom) < minEnclosedWidth) {
              FOR (i = 0; i < vnum; i++) {
                EV_VXCOORD_OUT[i] = EV_VXCOORD_IN[i];
                EV_VYCOORD_OUT[i] = EV_VYCOORD_IN[i];
              }
              EV_VNUM_OUT = vnum;
              EV_SAVE_POLYGON();
            }
          }
        }
      } (15 ) 
    }
}
 
/*check special notch rule*/
if ((minEdgeLength2 > 0.0005  && minEdgeLength3 > 0.0005 ) || minEdgeMode==2) {
  if (minEdgeMode==2) {
    SET minEdgeLength3 = minEdgeLength ;
  }
  NOTCH metal5  {
     SPACING < minEdgeLength3
     SET_CORNERS_TO_SPACING=FALSE
     PARALLEL = TRUE
     OUTPUT_EDGES = TRUE
  } TEMP = notch_vectors
  SELECT_VECTOR notch_vectors {
     LENGTH_RANGE = [0.0005 , minEdgeLength2 - 0.0005 ]
  } TEMP = short_edges
  EXTERNAL short_edges metal5  {
     SPACING < minEdgeLength3
     SET_CORNERS_TO_SPACING=FALSE
     PARALLEL = TRUE
  } TEMP = notch_err
  /* Choose the real U-shaped notch */
  SIZE notch_err { OVERSIZE = 0.001 *10 } TEMP = neighbors 
  BOOLEAN neighbors AND metal5  { } TEMP = neighbors
  VERTEX neighbors { 
     CONCAVE = TRUE
     CONVEX = TRUE
     SIZE = 0.001 
  } TEMP = corners
  SELECT_EDGE neighbors INTERACT notch_err { } TEMP = target_edges
  BOOLEAN target_edges NOT corners { } TEMP = target_edges
  VERTEX neighbors { 
     CONCAVE = TRUE
     SIZE = 2* 0.001 
  } TEMP = corners
  SELECT target_edges INTERACT corners { RANGE = [2, 2] } TEMP=target_edges
  SELECT notch_err INTERACT target_edges {
     COMMENT = "$layer_name SpeclNotch: sameNetSp = minEdgeLength3 um (sideLen minEdgeLength2 um)" 
  } (15 )
}
/*check consecutive short edges*/
if (minEdgeLength > 0.0005  && minEdgeMode != 2) { 
  INTERNAL metal5_top  {
     SEGMENT < minEdgeLength
     FLAG_ACUTE_ANGLE = FALSE
     FLAG_ACUTE_EDGE = FALSE
     OUTPUT_EDGES = TRUE
  } TEMP = short_edges
  if ((minEdgeMode == 0 && maxTotalMinEdgeLength>0) || maxNumMinEdge > 0) {
    SET temporary_1 = 0.001 *2;
    SET temporary_2 = 2*temporary_1+ 0.0005 ;
    SELECT metal5_top  INTERACT short_edges { } TEMP = target_top
    CLASSIFY_EDGES target_top {
       LENGTH = temporary_1
       DMIN   = temporary_2
       INSIDE_CORNER  TEMP = inside_corner_edges
       OUTSIDE_CORNER TEMP = outside_corner_edges
       REMAINDER      TEMP = remainder_edges
    }
    if (minEdgeMode == 0 && (maxNumMinEdge>0 || maxTotalMinEdgeLength > 0)) {
       SELECT short_edges ENCLOSING inside_corner_edges { } TEMP = short_edges
    }
  }
  if (maxTotalMinEdgeLength > 0) {
    LENGTH short_edges {
       RANGE = [maxTotalMinEdgeLength + 0.0005 , 9999999999 ]
    } TEMP = max_length_err
    /* Work around: translate polygons into dimensional check output */
    SIZE max_length_err { OVERSIZE = 2* 0.001  } TEMP = max_length_err
    INTERNAL max_length_err {
       SPACING < 3* 0.001 
       SET_CORNERS_TO_SPACING=FALSE
       COMMENT = "$layer_name MinEdgeLen: maximum total length ( minEdgeLength um)= maxTotalMinEdgeLength um"
    } (15 )
  }
  if (maxTotalMinEdgeLength == 0 || maxNumMinEdge > 0) {
    if (maxNumMinEdge==0)  {
       COPY short_edges {} TEMP=max_edge_err
    } else {
       SIZE short_edges {
         VSIZE_HEAD = - 0.001 
        VSIZE_TAIL = - 0.001 
       } TEMP = short_edges
       SIZE short_edges {
          OVERSIZE = 5* 0.001 
          SIZE_ENDPOINTS = FALSE
       } TEMP = short_contours
       SELECT short_contours ENCLOSING remainder_edges {
          RANGE = [maxNumMinEdge + 1, 9999999999 ]
       } TEMP = short_contours
       SELECT short_edges INSIDE short_contours { } TEMP=max_edge_err
    }
    /* Work around: translate polygons into dimensional check output */
    SIZE max_edge_err { OVERSIZE = 2* 0.001  } TEMP = max_edge_error
    INTERNAL max_edge_error {
       SPACING < 3* 0.001 
       SET_CORNERS_TO_SPACING=FALSE
       COMMENT = "$layer_name MinEdgeLen: maximum number of consecutive short edges ( minEdgeLength um)= maxNumMinEdge"
    } (15 ) 
  }
}
 
/*check basic spacing*/
if (sameNetMinSpacing > 0 && sameNetMinSpacing != minSpacing) {
  if (sameNetMinSpacing > minSpacing) {
    /* Special condition for U-shaped Metal spacing rule */
    NOTCH metal5_pin  {
        SPACING < sameNetMinSpacing
        BOX_CORNER = FALSE 
        SET_CORNERS_TO_SPACING=FALSE
        NON_PARALLEL = TRUE
        OUTPUT_EDGES = TRUE
    } TEMP = errs_to_be_waived
    NOTCH metal5_top  {
	SPACING < sameNetMinSpacing
	BOX_CORNER = FALSE 
        SET_CORNERS_TO_SPACING=FALSE
	NON_PARALLEL = TRUE
        OUTPUT_EDGES = TRUE
    } TEMP = all_errs
    BOOLEAN all_errs NOT errs_to_be_waived { } TEMP=err_edge
    EXTERNAL err_edge metal5_top  {
	SPACING < sameNetMinSpacing
	BOX_CORNER = FALSE 
        SET_CORNERS_TO_SPACING=FALSE
	NON_PARALLEL = TRUE
    } TEMP = notch_err
    SIZE notch_err { OVERSIZE = 0.001 *10 } TEMP = neighbors
    BOOLEAN neighbors AND metal5_top  { } TEMP = neighbors
    VERTEX neighbors { 
       CONCAVE = TRUE
       CONVEX = TRUE
       SIZE = 0.001 
    } TEMP = corners
    SELECT_EDGE neighbors INTERACT notch_err { } TEMP = target_edges
    BOOLEAN target_edges AND notch_err { } TEMP = target_edges
    BOOLEAN target_edges NOT corners { } TEMP = target_edges
    VERTEX neighbors {
       CONCAVE = TRUE
       SIZE = 2* 0.001 
    } TEMP = corners
    SELECT target_edges INTERACT corners { RANGE = [2, 2] } TEMP = target_edges
    SELECT notch_err TOUCHING target_edges {
      COMMENT = "$layer_name U-ShpNotch: U-shape notch minimum spacing = sameNetMinSpacing um" 
    } (15 )
  } else {
    NOTCH metal5  {
        COMMENT = "$layer_name SameNetSpc: same-net minimum spacing = sameNetMinSpacing um" 
	SPACING < sameNetMinSpacing
	BOX_CORNER = FALSE 
	NON_PARALLEL = TRUE
    } (15 )
  }
  if (minSpacing > 0) {
    if (stubMode == 0 && stubSpacing > 0 && stubSpacing < minSpacing) {
	EXTERNAL metal5  {
	    COMMENT = "$layer_name Spacing   : minimum spacing = minSpacing um"
            LONGEDGE > stubThreshold + 0.0005 
	    LONGEDGE_TO_EDGE < minSpacing
	    SPACING <= 0
	    BOX_CORNER = FALSE 
	    NON_PARALLEL = TRUE
            POINT_TOUCH = TRUE
            CHECK_SAME_POLYGON = TRUE 
	} (15 )
    } else {
        EXTERNAL metal5  {
	    COMMENT = "$layer_name Spacing   : minimum spacing = minSpacing um" 
	    SPACING < minSpacing
	    BOX_CORNER = FALSE 
	    NON_PARALLEL = TRUE
            POINT_TOUCH = TRUE
	    CHECK_SAME_POLYGON = FALSE
        } (15 )
    }
  }
} else {
  if (minSpacing > 0) {
    if (stubMode == 0 && stubSpacing > 0 && stubSpacing < minSpacing) {
        EXTERNAL metal5  {
            COMMENT = "$layer_name Spacing   : minimum spacing = minSpacing um"
            LONGEDGE > stubThreshold + 0.0005  
            LONGEDGE_TO_EDGE < minSpacing
            SPACING <= 0 
            BOX_CORNER = FALSE 
            NON_PARALLEL = TRUE
            POINT_TOUCH = TRUE
            CHECK_SAME_POLYGON = TRUE 
        } (15 )
    } else {
        EXTERNAL metal5  {
	    COMMENT = "$layer_name Spacing   : minimum spacing = minSpacing um" 
            SPACING < minSpacing
	    BOX_CORNER = FALSE 
	    NON_PARALLEL = TRUE
	    POINT_TOUCH = TRUE
	    CHECK_SAME_POLYGON = TRUE 
        } (15 )
    }
  }
}
 
/*check dogbone */
if (sameNetMinSpacing > 0 && sameNetWidthThreshold) {
  NOTCH metal5  {
    SPACING < sameNetMinSpacing
    BOX_CORNER = FALSE 
    NON_PARALLEL = TRUE
  } TEMP = dog_bone
 
  if (!layer_empty(dog_bone)) {
    SIZE dog_bone {EDGESIZE = sameNetWidthThreshold} TEMP = dog_ext
    BOOLEAN dog_ext NOT dog_bone {} TEMP = dog_ext
    BOOLEAN dog_ext AND metal5  {} TEMP = dog_ext
    if (!layer_empty(dog_ext)) {
      SELECT dog_ext EDGE_TOUCH dog_bone { OUTSIDE RANGE = [1, 9999999999 ] } TEMP = dog_ext
      NOTCH metal5  {
        SPACING < sameNetMinSpacing
        BOX_CORNER = FALSE 
        NON_PARALLEL = TRUE
	OUTPUT_EDGES = TRUE
      } TEMP = dog_bone
      SELECT dog_ext OUTSIDE dog_bone {} TEMP = dog_ext
      INTERNAL dog_ext {
	COMMENT = "$layer_name dogBone   : notch spacing = sameNetMinSpacing um width sameNetWidthThreshold um" 
	SPACING < sameNetWidthThreshold
      } (15 )
    }
  }
}
/*check basic fat spacing*/
if (fatWireThreshold > 0 && fatTblDimension == 0) {
    SIZE fat_candidate { UNDER_OVER = fatWireThreshold / 2.0 - 0.0005  } TEMP = m_fat
    BOOLEAN m_fat AND metal5  {  } TEMP = m_fat
    BOOLEAN metal5  NOT m_fat {  } TEMP = m_thin
    if (ignoreBlockage == 0) {
        /* the blockages on the metal_blockage layer are treated as thin blockages */
        BOOLEAN m_thin OR metal5_blockage  {  } TEMP = m_thin
    }
 
    if (fatFatMinSpacing > 0) {
	EXTERNAL m_fat {
	    COMMENT = "$layer_name FatWireSpc: fat & fat ( fatWireThreshold um) minimum spacing = fatFatMinSpacing um"
	    SPACING < fatFatMinSpacing
	    BOX_CORNER = FALSE 
	    NON_PARALLEL = TRUE
	    POINT_TOUCH = FALSE
	    CHECK_SAME_POLYGON = TRUE 
       } (15 )
    }
 
    if (fatThinMinSpacing > 0) {
	EXTERNAL m_fat m_thin {
	    COMMENT = "$layer_name FatWireSpc: fat & thin ( fatWireThreshold um) minimum spacing fatThinMinSpacing um"
	    SPACING < fatThinMinSpacing
 	    BOX_CORNER = FALSE 
	    NON_PARALLEL = TRUE
	    POINT_TOUCH = FALSE
        } (15 )
    }
}
 
/*check thin blockage spacing*/
if (minSpacing > 0 && ignoreBlockage == 0) {
    if (!layer_empty (metal5_blockage )) {
	EXTERNAL metal5_blockage  metal5  {
	    COMMENT = "$layer_name Spacing   : metal & thin blockage minimum spacing = minSpacing um"
	    SPACING < minSpacing
	    BOX_CORNER = FALSE 
	    NON_PARALLEL = TRUE
	    POINT_TOUCH = TRUE
            TOUCH = TRUE
        } (15 )
    }
}
/*check blockage overlap*/
/*check shorts between top_level routing and fram_blockages*/
if (minSpacing>0 || checkCrossHierShort>0) {
   if (ignoreBlockage == 0) {
      BOOLEAN metal5_blockage  or metal5_rbkg  {} TEMP=all_blockage
   } else {
      COPY metal5_rbkg  {} TEMP=all_blockage
   }
   BOOLEAN all_blockage AND metal5_top  {} TEMP = overlap_shape1
   EXTERNAL all_blockage metal5_top  {
      SPACING <= 0
      TOUCH = TRUE
   } TEMP = overlap_shape2
   if (checkCrossHierShort>0) {
      BOOLEAN overlap_shape1 OR overlap_shape2 {
         COMMENT = "$layer_name Short Cross Hierarchy"
      } (15 )
   } else {
      BOOLEAN overlap_shape1 OR overlap_shape2 {
         COMMENT = "$layer_name Overlap   : metal & blockage overlap"
      } (15 )
   }
}
 
if (fatPolyContactRule > 0) {
  /* Fat Poly Contact Rule: not new fat wire formed */
  if (readCellView > 0) {
     SIZE metal1 { UNDER_OVER = fatPolyContactRule / 2.0 - 0.0005  } TEMP = fat
     BOOLEAN fat AND metal1 {  } TEMP = fat 
  } else {
     SIZE metal1_top { UNDER_OVER = fatPolyContactRule / 2.0 - 0.0005  } TEMP = fat
     BOOLEAN fat AND metal1_top {  } TEMP = fat 
  }
  SIZE metal1_pin { UNDER_OVER = fatPolyContactRule / 2.0 - 0.0005  } TEMP = fat_pin
  BOOLEAN fat_pin AND metal1_pin {  } TEMP = fat_pin
  BOOLEAN fat NOT fat_pin {
    COMMENT = "$layer_name FatPolyContactRule: fatPolyContactRule um" 
  } (15 )
}
/* Special End-of-Line Spacing Rule */
if (stubMode == 0 && stubSpacing > 0 && stubSpacing < minSpacing) {
  EXTERNAL metal5  {
     COMMENT = "$layer_name specEoLSpc: spacing= stubSpacing um (mode = 0)"
     LONGEDGE > stubThreshold + 0.0005 
     LONGEDGE_TO_EDGE <= 0 
     SPACING < stubSpacing 
     SET_CORNERS_TO_SPACING = FALSE
     PARALLEL_POINT_PROJECTION = FALSE
  } (15 )
} else if (stubMode > 0 && stubSpacing > minSpacing) {
  if (stubMode == 4) {
     INTERNAL metal5  {
        SEGMENT[90,90] < stubThreshold
        OUTPUT_EDGES = TRUE
     } TEMP = end_of_line
  } else {
     INTERNAL metal5  {
        SEGMENT[90,90] <= stubThreshold
        OUTPUT_EDGES = TRUE
     } TEMP = end_of_line
  }
  /* Quick filter to reduce the size of possible end of line */
  if (sideStubExt > 0) {
    SIZE end_of_line {
       VSIZE_HEAD = sideStubExt
       VSIZE_TAIL = sideStubExt
       OUTPUT_EDGES = TRUE
    } TEMP = eol_ext
  } else {
    COPY end_of_line { } TEMP=eol_ext
  }
  if (stub2StubSpacing > stubSpacing) {
     SET temporary_1 = stub2StubSpacing;
  } else {
     SET temporary_1 = stubSpacing; 
  }
  EXTERNAL eol_ext metal5  {
     SPACING < temporary_1
     TOUCH = TRUE
     OVERLAP = TRUE 
     SET_CORNERS_TO_SPACING = FALSE
     PARALLEL_POINT_PROJECTION = FALSE
     OUTPUT_EDGES = TRUE
  } TEMP=err_edge
  SELECT eol_ext INTERACT err_edge { } TEMP=eol_ext
  SELECT end_of_line INTERACT eol_ext { } TEMP=end_of_line 
  /* Reduce the size of METAL_LAYER */
  if (stubMode==3) {
     SIZE end_of_line {
        VSIZE_HEAD = stubSpacing 
        VSIZE_TAIL = stubSpacing 
        VSIZE_INSIDE = sideStubThreshold
        VSIZE_OUTSIDE = stubSpacing
     } TEMP = eol_filter 
  } else {
     if (stubMode == 1 && stubRange > 0) {
        SIZE end_of_line {
           VSIZE_HEAD = stubSpacing- 0.0005 
           VSIZE_TAIL = stubSpacing- 0.0005 
           VSIZE_OUTSIDE = stubSpacing- 0.0005 
        } TEMP = eol_filter
     } else {
        SIZE end_of_line {
           VSIZE_HEAD = stubSpacing- 0.0005 
           VSIZE_TAIL = stubSpacing- 0.0005 
           VSIZE_INSIDE = sideStubThreshold- 0.0005 
           VSIZE_OUTSIDE = stubSpacing- 0.0005 
        } TEMP = eol_filter
     }
  }
  SELECT metal5  INTERACT eol_filter { } TEMP=target_top
  /* Get the side edges and the whole eol of line set */
  SELECT_EDGE target_top INTERACT end_of_line { 
    POINT_TOUCH = TRUE
  } TEMP = eol_set
  VERTEX target_top { 
     CONCAVE = TRUE 
     CONVEX = TRUE
     SIZE = 0.001 
  } TEMP = corners
  SELECT corners OUTSIDE end_of_line {} TEMP =corners 
  BOOLEAN eol_set NOT corners { } TEMP=eol_set
  BOOLEAN eol_set NOT end_of_line { } TEMP=side_edge
  /* find out the real end of line */
  if (stubRange > 0) {
     if (stubMode == 1) {
         COPY side_edge { } TEMP = all_side_edge
         LENGTH side_edge { SPACING <= stubRange- 0.0005  } TEMP=side_edge
     } else {
         LENGTH side_edge { SPACING < stubRange- 0.001  } TEMP=eol_filter
         BOOLEAN side_edge NOT eol_filter { } TEMP=side_edge
     }
     SELECT end_of_line INTERACT side_edge { RANGE = [1,2] } TEMP = end_of_line
  } 
  if (stubMode == 1) {
    if (stub2StubSpacing > 0) {
       if (sideStubExt < 0) {
          SIZE end_of_line {
            VSIZE_HEAD = sideStubExt / 2
            VSIZE_TAIL = sideStubExt / 2
            OUTPUT_EDGES = TRUE
          } TEMP = eol_ext_tip
	 
          EXTERNAL eol_ext_tip {
            COMMENT = "$layer_name specEoLSpc: stub2Stubspacing= stub2StubSpacing um (mode = 1)"
            SPACING < stub2StubSpacing
            SET_CORNERS_TO_SPACING = FALSE
            PARALLEL_POINT_PROJECTION = TRUE
          } (15 )
       } else {
          EXTERNAL end_of_line {
            COMMENT = "$layer_name specEoLSpc: stub2Stubspacing= stub2StubSpacing um (mode = 1)"
            SPACING < stub2StubSpacing
            SET_CORNERS_TO_SPACING = FALSE
            PARALLEL_POINT_PROJECTION = FALSE
          } (15 )
       }
    }
    if (stubRange > 0) {
       SIZE end_of_line {
         VSIZE_INSIDE = 0.001 
       } TEMP = eol_poly
       SELECT_EDGE eol_poly TOUCHING target_top { } TEMP=eol_edge
       EXTERNAL eol_edge target_top {
         COMMENT = "$layer_name specEoLSpc: spacing= stubSpacing um (mode = 1)"
         CONVEX_TO_CONVEX < stubSpacing
         CONVEX_TO_CONVEX [POINT_PROJECTION] < stubSpacing
         CONVEX_TO_EDGE < stubSpacing
         CONCAVE_TO_CONVEX < stubSpacing
         LONGEDGE > 0.001 
         LONGEDGE_TO_EDGE < stubSpacing
         SPACING <= 0
         SET_CORNERS_TO_SPACING = TRUE
         PARALLEL_POINT_PROJECTION = TRUE
       } (15 )
       SELECT all_side_edge INTERACT end_of_line { } TEMP = side_edge
       SIZE side_edge {
         VSIZE_HEAD = 0.001 
         VSIZE_TAIL = 0.001 
       } TEMP = side_edge_ext
       BOOLEAN side_edge_ext NOT side_edge { } TEMP = side_edge_ext
       SELECT side_edge_ext INTERACT end_of_line { } TEMP = side_edge_ext
       EXTERNAL side_edge_ext target_top {
         COMMENT = "$layer_name specEoLSpc: spacing= stubSpacing um (mode = 1)"
         SPACING < stubSpacing
         SET_CORNERS_TO_SPACING = FALSE
         PARALLEL_POINT_PROJECTION = FALSE
       } (15 )
    } else {
       if (stub2StubSpacing > 0) {
         VECTORIZE target_top {
            DIRECTED=TRUE
         } TEMP=target_edges
         BOOLEAN target_edges NOT end_of_line { } TEMP = target_edges
         EXTERNAL end_of_line target_edges {
            COMMENT = "$layer_name specEoLSpc: spacing= stubSpacing um (mode = 1)"
            SPACING < stubSpacing
            TOUCH=TRUE
            OVERLAP=TRUE
            SET_CORNERS_TO_SPACING=FALSE
            PARALLEL_POINT_PROJECTION=FALSE
         } (15 )
       } else {
         if (sideStubExt > 0) {
            SIZE end_of_line {
               VSIZE_HEAD = sideStubExt
               VSIZE_TAIL = sideStubExt
               OUTPUT_EDGES = TRUE
            } TEMP = end_of_line
            EXTERNAL end_of_line target_top {
               COMMENT = "$layer_name specEoLSpc: spacing= stubSpacing ,crnKeepOut= sideStubExt um (mode = 1)"
               SPACING < stubSpacing
               TOUCH=TRUE
               OVERLAP=TRUE
               SET_CORNERS_TO_SPACING=FALSE
               PARALLEL_POINT_PROJECTION=FALSE
            } (15 )
         } else {
            EXTERNAL end_of_line target_top {
               COMMENT = "$layer_name specEoLSpc: spacing= stubSpacing um (mode = 1)"
               SPACING < stubSpacing
               TOUCH=TRUE
               OVERLAP=TRUE
               SET_CORNERS_TO_SPACING=FALSE
               PARALLEL_POINT_PROJECTION=FALSE
            } (15 )
         }
       }
    }
  } else { /* stubMode == 2,3,4 */
    /* stubMode 2 eol classify and reduction */
    if (stubMode !=3 && sideStubExt > 0) {
      if (stubMode == 4) {
        SIZE end_of_line {
           VSIZE_HEAD = sideStubExt
           VSIZE_TAIL = sideStubExt
           OUTPUT_EDGES = TRUE
        } TEMP = eol_ext
        EXTERNAL eol_ext target_top {
           SPACING < stubSpacing
           SET_CORNERS_TO_SPACING=FALSE
           PARALLEL_POINT_PROJECTION=FALSE
           OUTPUT_EDGES = TRUE
        } TEMP=err_edge
        SELECT eol_ext INTERACT err_edge { } TEMP=eol_ext
      } else {
        EXTERNAL end_of_line target_top {
           SPACING < stubSpacing
           SET_CORNERS_TO_SPACING=FALSE
           PARALLEL_POINT_PROJECTION=FALSE
           OUTPUT_EDGES = TRUE
        } TEMP=err_edge
        SELECT end_of_line INTERACT err_edge { } TEMP=eol_body
        SIZE end_of_line {
           VSIZE_HEAD = sideStubExt
           VSIZE_TAIL = sideStubExt
           OUTPUT_EDGES = TRUE
        } TEMP = eol_ext
        BOOLEAN eol_ext NOT end_of_line {} TEMP=eol_ext
        EXTERNAL eol_ext target_top {
           SPACING < stubSpacing
           SET_CORNERS_TO_SPACING=FALSE
           PARALLEL_POINT_PROJECTION=FALSE
           OUTPUT_EDGES = TRUE
        } TEMP=err_edge
        SELECT eol_ext INTERACT err_edge { } TEMP=eol_ext
        BOOLEAN eol_body OR eol_ext { } TEMP=eol_ext
      } 
    } else {
      COPY end_of_line { } TEMP=eol_ext
    }
    SELECT side_edge INTERACT eol_ext { } TEMP=side_edge
    SIZE eol_ext {
       VSIZE_INSIDE = sideStubThreshold 
       VSIZE_OUTSIDE = sideStubExt
    } TEMP = eol_range
    if (sideStubExt > 0) {
       SIZE side_edge {
          VSIZE_HEAD = sideStubExt
          VSIZE_TAIL = sideStubExt
          OUTPUT_EDGES = TRUE
       } TEMP = check_edge
    } else {
       COPY side_edge { } TEMP = check_edge
    }
    BOOLEAN check_edge AND eol_range { } TEMP=check_edge
    EXTERNAL check_edge target_top {
       SPACING < temporary_1
       SET_CORNERS_TO_SPACING = FALSE
       SHADOW_OTHER_LAYER = TRUE
       PARALLEL_POINT_PROJECTION = FALSE
       OUTPUT_EDGES = TRUE
    } TEMP=err_edge
    if (0 && stubMode!=4) { /* Temporarily do not check mode 2,3 side edge length */
       LENGTH side_edge { SPACING < stubSpacing- 0.0005 *2 } TEMP=err_edge_1
       BOOLEAN err_edge OR err_edge_1 { } TEMP=err_edge
    }
    SELECT check_edge INTERACT err_edge { } TEMP=side_edge
    if (stubMode!=3) {
       SELECT eol_ext INTERACT side_edge {} TEMP=err_eol
       EXTERNAL err_eol target_top {
          COMMENT = "$layer_name specEoLSpc: spacing= stubSpacing ,crnKeepOut= sideStubExt um (mode = stubMode )"
          SPACING < temporary_1
          PARALLEL_POINT_PROJECTION=FALSE
          SET_CORNERS_TO_SPACING=FALSE
       } (15 )
    } else { /* stubMode == 3 */
       SELECT eol_ext INTERACT side_edge { RANGE = [2, 2] } TEMP=err_eol
       EXTERNAL err_eol target_top {
          COMMENT = "$layer_name specEoLSpc: spacing= stubSpacing um (mode = 3)"
          SPACING < temporary_1
          PARALLEL_POINT_PROJECTION=FALSE
          SET_CORNERS_TO_SPACING=FALSE
       } (15 )
    }
  }
} /* stubMode > 0, not aligned */
/* Avoid empty optimization result parsing error */
if (addEmptyMetalCheck) {
   BOOLEAN empty OR empty {
      COMMENT = "$layer_name Empty: Dummy Output"
   } (15 )
   SET addEmptyMetalCheck=0;
}
/* reset variables */


 
SET minWidth = 0;
SET maxWidth = 0;
SET minArea = 0;
SET minEnclosedArea = 0;
SET minSpacing = 0;
SET sameNetMinSpacing = 0;
SET maxNumMinEdge = 0;
SET maxTotalMinEdgeLength = 0;
SET minEdgeLength = 0;
SET minEdgeLength2 = 0;
SET minEdgeLength3 = 0;
SET stubRange = 0;
SET stubSpacing = 0;
SET stub2StubSpacing = 0;
SET sideStubExt = 0;
SET sideStubThreshold = 0;
SET stubThreshold = 0;
SET fatPolyContactRule = 0;
SET fatWireThreshold = 0;
SET fatThinMinSpacing = 0;
SET fatFatMinSpacing = 0;
SET fatTblDimension = 0;
@ 294 "adrc/adrc.ev" 2









/*metal 6*/
SET layer_name = "Met6";










SET minWidth = 0.16;
SET maxWidth = 1000;
SET minArea = 0.07;
SET minSpacing = 0.16;
SET stub2StubSpacing = 0;

SET fatTblDimension = 0;
@ 1 "adrc/adrc_check_metal.ev" 1
/* Data Preparation */
if (fatTblDimension > 1 || fatWireThreshold > 0 || maxWidth > 0) {
  if (ignoreBlockage) {
      /* Let the real blockage be treated as thin */
      BOOLEAN metal6  NOT metal6_rbkg  {} TEMP=fat_candidate
  } else {
      COPY metal6  {} TEMP=fat_candidate
  }
  COPY fat_candidate {} TEMP=fat_target
}
/*Check width*/
if (minWidth > 0) {
    INTERNAL metal6  { 
        COMMENT = "$layer_name MinWidth  : minimum width = minWidth um" 
        SPACING < minWidth
        POINT_TOUCH = FALSE
    } (16 )
}
 
if (maxWidth > 0) {
    SIZE  fat_candidate {
        COMMENT = "$layer_name MaxWidth  : maximum width = maxWidth um"
 	UNDER_OVER = maxWidth / 2 
    } (16 ) 
}
 
/*Check area*/
if (minArea > 0) {
    AREA metal6  { 
	COMMENT = "$layer_name MinArea   : minimum area = minArea um*um"
	RANGE = [0.0005 * 0.0005 , minArea - 0.0005 * 0.0005 ]
    } (16 )
}
/* check min length of bounding box on polygon */
if (minLength > 0) {
  if (minLengthMode == 1) {
    INTERNAL metal6  {
        SPACING < minLength
        VERTICAL_ONLY = TRUE
        SET_CORNERS_TO_SPACING = FALSE
    } TEMP = ver_short
    BOOLEAN metal6  NOT ver_short { } TEMP = ver_long
    INTERNAL metal6  {
        SPACING < minLength
        HORIZONTAL_ONLY = TRUE
        SET_CORNERS_TO_SPACING = FALSE
    } TEMP = hor_short
    BOOLEAN metal6  NOT hor_short { } TEMP = hor_long
    SELECT CUT_LAYER1 INSIDE ver_long { } TEMP = good_cut
    BOOLEAN CUT_LAYER1 NOT good_cut { } TEMP = fail_cut_1
    SELECT fail_cut_1 INSIDE hor_long { } TEMP = good_cut
    BOOLEAN fail_cut_1 NOT good_cut { } TEMP = fail_cut_1
    SELECT CUT_LAYER2 INSIDE ver_long { } TEMP = good_cut
    BOOLEAN CUT_LAYER2 NOT good_cut { } TEMP = fail_cut_2
    SELECT fail_cut_2 INSIDE hor_long { } TEMP = good_cut
    BOOLEAN fail_cut_2 NOT good_cut { } TEMP = fail_cut_2
    BOOLEAN fail_cut_1 OR fail_cut_2 { } TEMP = fail_cut
    BOOLEAN hor_short NOT ver_long { } TEMP = hor_short
    BOOLEAN ver_short NOT hor_long { } TEMP = ver_short
    SELECT ver_short INTERACT fail_cut { } TEMP = ver_fail
    SELECT hor_short INTERACT fail_cut { } TEMP = hor_fail
    BOOLEAN ver_fail OR hor_fail { } TEMP = all_fail
    INTERNAL all_fail {
        COMMENT = "$layer_name MinLength : minimum length = minLength um"
        SPACING < minLength
        VERTICAL_ONLY = TRUE
        SET_CORNERS_TO_SPACING = FALSE
    } (16 )
  } else {
    POLYGON_FEATURES metal6  {
      COMMENT = "$layer_name MinLength : minimum length = minLength um"
      EQUATIONS {
        vnum = EV_VNUM_IN;
        if ( vnum > 0) {
	  bdLeft = EV_VXCOORD_IN[0];
	  bdRight = EV_VXCOORD_IN[0];
	  bdBottom = EV_VYCOORD_IN[0];
	  bdTop = EV_VYCOORD_IN[0];
          FOR (i = 1; i < vnum; i++) {
	    if (bdLeft > EV_VXCOORD_IN[i]) bdLeft = EV_VXCOORD_IN[i];
            else if (bdRight < EV_VXCOORD_IN[i]) bdRight = EV_VXCOORD_IN[i];
	    if (bdBottom > EV_VYCOORD_IN[i]) bdBottom = EV_VYCOORD_IN[i];
            else if (bdTop < EV_VYCOORD_IN[i]) bdTop = EV_VYCOORD_IN[i];
          }
	  if ( (bdRight - bdLeft) < minLength &&
	       (bdTop - bdBottom) < minLength) {
	    FOR (i = 0; i < vnum; i++) {
              EV_VXCOORD_OUT[i] = EV_VXCOORD_IN[i];
	      EV_VYCOORD_OUT[i] = EV_VYCOORD_IN[i];
            }
	    EV_VNUM_OUT = vnum;
	    EV_SAVE_POLYGON();
          }
        }
      }
    } (16 ) 
  }
  SET minLength = 0;
}
/* check max length of bounding box on polygon */
if (maxLength > 0) {
  POLYGON_FEATURES metal6  {
    COMMENT = "$layer_name MaxLength : maximum length = maxLength um"
    EQUATIONS {
      vnum = EV_VNUM_IN;
      if ( vnum > 0) {
	bdLeft = EV_VXCOORD_IN[0];
	bdRight = EV_VXCOORD_IN[0];
	bdBottom = EV_VYCOORD_IN[0];
	bdTop = EV_VYCOORD_IN[0];
        FOR (i = 1; i < vnum; i++) {
	  if (bdLeft > EV_VXCOORD_IN[i]) bdLeft = EV_VXCOORD_IN[i];
          else if (bdRight < EV_VXCOORD_IN[i]) bdRight = EV_VXCOORD_IN[i];
	  if (bdBottom > EV_VYCOORD_IN[i]) bdBottom = EV_VYCOORD_IN[i];
          else if (bdTop < EV_VYCOORD_IN[i]) bdTop = EV_VYCOORD_IN[i];
        }
	if ( (bdRight - bdLeft + bdTop - bdBottom) > maxLength ) {
          EV_VXCOORD_OUT[0] = bdLeft;
	  EV_VYCOORD_OUT[0] = bdBottom;
          EV_VXCOORD_OUT[1] = bdLeft;
	  EV_VYCOORD_OUT[1] = bdTop;
          EV_VXCOORD_OUT[2] = bdRight;
	  EV_VYCOORD_OUT[2] = bdTop;
          EV_VXCOORD_OUT[3] = bdRight;
	  EV_VYCOORD_OUT[3] = bdBottom;
          EV_VXCOORD_OUT[4] = bdLeft;
	  EV_VYCOORD_OUT[4] = bdBottom;
	  EV_VNUM_OUT = 5;
	  EV_SAVE_POLYGON();
        }
      }
    }
  } (16 ) 
  SET maxLength = 0;
}
 
/*Check enclosed area*/
if (minEnclosedArea > 0) {
    SELECT metal6  INSIDE_HOLE {
        INNER_HOLE_ONLY
    } TEMP = holes
    BOOLEAN holes NOT metal6  { } TEMP = holes
 
    AREA holes {
        COMMENT = "$layer_name EnclsArea : minimum enclosed area = minEnclosedArea um*um"
        RANGE = [0.0005 * 0.0005 , minEnclosedArea - 0.0005 * 0.0005 ]
    } (16 )
    /* check min length of bounding box on polygon */
    if (minEnclosedWidth > 0) {
      POLYGON_FEATURES holes {
        COMMENT = "$layer_name EnclsWidth: minimum enclosed Width = minEnclosedWidth um"
        EQUATIONS {
          vnum = EV_VNUM_IN;
          if ( vnum > 0) {
            bdLeft = EV_VXCOORD_IN[0];
            bdRight = EV_VXCOORD_IN[0];
            bdBottom = EV_VYCOORD_IN[0];
            bdTop = EV_VYCOORD_IN[0];
            FOR (i = 1; i < vnum; i++) {
              if (bdLeft > EV_VXCOORD_IN[i]) bdLeft = EV_VXCOORD_IN[i];
              else if (bdRight < EV_VXCOORD_IN[i]) bdRight = EV_VXCOORD_IN[i];
              if (bdBottom > EV_VYCOORD_IN[i]) bdBottom = EV_VYCOORD_IN[i];
              else if (bdTop < EV_VYCOORD_IN[i]) bdTop = EV_VYCOORD_IN[i];
            }
            if ( (bdRight - bdLeft) < minEnclosedWidth &&
                 (bdTop - bdBottom) < minEnclosedWidth) {
              FOR (i = 0; i < vnum; i++) {
                EV_VXCOORD_OUT[i] = EV_VXCOORD_IN[i];
                EV_VYCOORD_OUT[i] = EV_VYCOORD_IN[i];
              }
              EV_VNUM_OUT = vnum;
              EV_SAVE_POLYGON();
            }
          }
        }
      } (16 ) 
    }
}
 
/*check special notch rule*/
if ((minEdgeLength2 > 0.0005  && minEdgeLength3 > 0.0005 ) || minEdgeMode==2) {
  if (minEdgeMode==2) {
    SET minEdgeLength3 = minEdgeLength ;
  }
  NOTCH metal6  {
     SPACING < minEdgeLength3
     SET_CORNERS_TO_SPACING=FALSE
     PARALLEL = TRUE
     OUTPUT_EDGES = TRUE
  } TEMP = notch_vectors
  SELECT_VECTOR notch_vectors {
     LENGTH_RANGE = [0.0005 , minEdgeLength2 - 0.0005 ]
  } TEMP = short_edges
  EXTERNAL short_edges metal6  {
     SPACING < minEdgeLength3
     SET_CORNERS_TO_SPACING=FALSE
     PARALLEL = TRUE
  } TEMP = notch_err
  /* Choose the real U-shaped notch */
  SIZE notch_err { OVERSIZE = 0.001 *10 } TEMP = neighbors 
  BOOLEAN neighbors AND metal6  { } TEMP = neighbors
  VERTEX neighbors { 
     CONCAVE = TRUE
     CONVEX = TRUE
     SIZE = 0.001 
  } TEMP = corners
  SELECT_EDGE neighbors INTERACT notch_err { } TEMP = target_edges
  BOOLEAN target_edges NOT corners { } TEMP = target_edges
  VERTEX neighbors { 
     CONCAVE = TRUE
     SIZE = 2* 0.001 
  } TEMP = corners
  SELECT target_edges INTERACT corners { RANGE = [2, 2] } TEMP=target_edges
  SELECT notch_err INTERACT target_edges {
     COMMENT = "$layer_name SpeclNotch: sameNetSp = minEdgeLength3 um (sideLen minEdgeLength2 um)" 
  } (16 )
}
/*check consecutive short edges*/
if (minEdgeLength > 0.0005  && minEdgeMode != 2) { 
  INTERNAL metal6_top  {
     SEGMENT < minEdgeLength
     FLAG_ACUTE_ANGLE = FALSE
     FLAG_ACUTE_EDGE = FALSE
     OUTPUT_EDGES = TRUE
  } TEMP = short_edges
  if ((minEdgeMode == 0 && maxTotalMinEdgeLength>0) || maxNumMinEdge > 0) {
    SET temporary_1 = 0.001 *2;
    SET temporary_2 = 2*temporary_1+ 0.0005 ;
    SELECT metal6_top  INTERACT short_edges { } TEMP = target_top
    CLASSIFY_EDGES target_top {
       LENGTH = temporary_1
       DMIN   = temporary_2
       INSIDE_CORNER  TEMP = inside_corner_edges
       OUTSIDE_CORNER TEMP = outside_corner_edges
       REMAINDER      TEMP = remainder_edges
    }
    if (minEdgeMode == 0 && (maxNumMinEdge>0 || maxTotalMinEdgeLength > 0)) {
       SELECT short_edges ENCLOSING inside_corner_edges { } TEMP = short_edges
    }
  }
  if (maxTotalMinEdgeLength > 0) {
    LENGTH short_edges {
       RANGE = [maxTotalMinEdgeLength + 0.0005 , 9999999999 ]
    } TEMP = max_length_err
    /* Work around: translate polygons into dimensional check output */
    SIZE max_length_err { OVERSIZE = 2* 0.001  } TEMP = max_length_err
    INTERNAL max_length_err {
       SPACING < 3* 0.001 
       SET_CORNERS_TO_SPACING=FALSE
       COMMENT = "$layer_name MinEdgeLen: maximum total length ( minEdgeLength um)= maxTotalMinEdgeLength um"
    } (16 )
  }
  if (maxTotalMinEdgeLength == 0 || maxNumMinEdge > 0) {
    if (maxNumMinEdge==0)  {
       COPY short_edges {} TEMP=max_edge_err
    } else {
       SIZE short_edges {
         VSIZE_HEAD = - 0.001 
        VSIZE_TAIL = - 0.001 
       } TEMP = short_edges
       SIZE short_edges {
          OVERSIZE = 5* 0.001 
          SIZE_ENDPOINTS = FALSE
       } TEMP = short_contours
       SELECT short_contours ENCLOSING remainder_edges {
          RANGE = [maxNumMinEdge + 1, 9999999999 ]
       } TEMP = short_contours
       SELECT short_edges INSIDE short_contours { } TEMP=max_edge_err
    }
    /* Work around: translate polygons into dimensional check output */
    SIZE max_edge_err { OVERSIZE = 2* 0.001  } TEMP = max_edge_error
    INTERNAL max_edge_error {
       SPACING < 3* 0.001 
       SET_CORNERS_TO_SPACING=FALSE
       COMMENT = "$layer_name MinEdgeLen: maximum number of consecutive short edges ( minEdgeLength um)= maxNumMinEdge"
    } (16 ) 
  }
}
 
/*check basic spacing*/
if (sameNetMinSpacing > 0 && sameNetMinSpacing != minSpacing) {
  if (sameNetMinSpacing > minSpacing) {
    /* Special condition for U-shaped Metal spacing rule */
    NOTCH metal6_pin  {
        SPACING < sameNetMinSpacing
        BOX_CORNER = FALSE 
        SET_CORNERS_TO_SPACING=FALSE
        NON_PARALLEL = TRUE
        OUTPUT_EDGES = TRUE
    } TEMP = errs_to_be_waived
    NOTCH metal6_top  {
	SPACING < sameNetMinSpacing
	BOX_CORNER = FALSE 
        SET_CORNERS_TO_SPACING=FALSE
	NON_PARALLEL = TRUE
        OUTPUT_EDGES = TRUE
    } TEMP = all_errs
    BOOLEAN all_errs NOT errs_to_be_waived { } TEMP=err_edge
    EXTERNAL err_edge metal6_top  {
	SPACING < sameNetMinSpacing
	BOX_CORNER = FALSE 
        SET_CORNERS_TO_SPACING=FALSE
	NON_PARALLEL = TRUE
    } TEMP = notch_err
    SIZE notch_err { OVERSIZE = 0.001 *10 } TEMP = neighbors
    BOOLEAN neighbors AND metal6_top  { } TEMP = neighbors
    VERTEX neighbors { 
       CONCAVE = TRUE
       CONVEX = TRUE
       SIZE = 0.001 
    } TEMP = corners
    SELECT_EDGE neighbors INTERACT notch_err { } TEMP = target_edges
    BOOLEAN target_edges AND notch_err { } TEMP = target_edges
    BOOLEAN target_edges NOT corners { } TEMP = target_edges
    VERTEX neighbors {
       CONCAVE = TRUE
       SIZE = 2* 0.001 
    } TEMP = corners
    SELECT target_edges INTERACT corners { RANGE = [2, 2] } TEMP = target_edges
    SELECT notch_err TOUCHING target_edges {
      COMMENT = "$layer_name U-ShpNotch: U-shape notch minimum spacing = sameNetMinSpacing um" 
    } (16 )
  } else {
    NOTCH metal6  {
        COMMENT = "$layer_name SameNetSpc: same-net minimum spacing = sameNetMinSpacing um" 
	SPACING < sameNetMinSpacing
	BOX_CORNER = FALSE 
	NON_PARALLEL = TRUE
    } (16 )
  }
  if (minSpacing > 0) {
    if (stubMode == 0 && stubSpacing > 0 && stubSpacing < minSpacing) {
	EXTERNAL metal6  {
	    COMMENT = "$layer_name Spacing   : minimum spacing = minSpacing um"
            LONGEDGE > stubThreshold + 0.0005 
	    LONGEDGE_TO_EDGE < minSpacing
	    SPACING <= 0
	    BOX_CORNER = FALSE 
	    NON_PARALLEL = TRUE
            POINT_TOUCH = TRUE
            CHECK_SAME_POLYGON = TRUE 
	} (16 )
    } else {
        EXTERNAL metal6  {
	    COMMENT = "$layer_name Spacing   : minimum spacing = minSpacing um" 
	    SPACING < minSpacing
	    BOX_CORNER = FALSE 
	    NON_PARALLEL = TRUE
            POINT_TOUCH = TRUE
	    CHECK_SAME_POLYGON = FALSE
        } (16 )
    }
  }
} else {
  if (minSpacing > 0) {
    if (stubMode == 0 && stubSpacing > 0 && stubSpacing < minSpacing) {
        EXTERNAL metal6  {
            COMMENT = "$layer_name Spacing   : minimum spacing = minSpacing um"
            LONGEDGE > stubThreshold + 0.0005  
            LONGEDGE_TO_EDGE < minSpacing
            SPACING <= 0 
            BOX_CORNER = FALSE 
            NON_PARALLEL = TRUE
            POINT_TOUCH = TRUE
            CHECK_SAME_POLYGON = TRUE 
        } (16 )
    } else {
        EXTERNAL metal6  {
	    COMMENT = "$layer_name Spacing   : minimum spacing = minSpacing um" 
            SPACING < minSpacing
	    BOX_CORNER = FALSE 
	    NON_PARALLEL = TRUE
	    POINT_TOUCH = TRUE
	    CHECK_SAME_POLYGON = TRUE 
        } (16 )
    }
  }
}
 
/*check dogbone */
if (sameNetMinSpacing > 0 && sameNetWidthThreshold) {
  NOTCH metal6  {
    SPACING < sameNetMinSpacing
    BOX_CORNER = FALSE 
    NON_PARALLEL = TRUE
  } TEMP = dog_bone
 
  if (!layer_empty(dog_bone)) {
    SIZE dog_bone {EDGESIZE = sameNetWidthThreshold} TEMP = dog_ext
    BOOLEAN dog_ext NOT dog_bone {} TEMP = dog_ext
    BOOLEAN dog_ext AND metal6  {} TEMP = dog_ext
    if (!layer_empty(dog_ext)) {
      SELECT dog_ext EDGE_TOUCH dog_bone { OUTSIDE RANGE = [1, 9999999999 ] } TEMP = dog_ext
      NOTCH metal6  {
        SPACING < sameNetMinSpacing
        BOX_CORNER = FALSE 
        NON_PARALLEL = TRUE
	OUTPUT_EDGES = TRUE
      } TEMP = dog_bone
      SELECT dog_ext OUTSIDE dog_bone {} TEMP = dog_ext
      INTERNAL dog_ext {
	COMMENT = "$layer_name dogBone   : notch spacing = sameNetMinSpacing um width sameNetWidthThreshold um" 
	SPACING < sameNetWidthThreshold
      } (16 )
    }
  }
}
/*check basic fat spacing*/
if (fatWireThreshold > 0 && fatTblDimension == 0) {
    SIZE fat_candidate { UNDER_OVER = fatWireThreshold / 2.0 - 0.0005  } TEMP = m_fat
    BOOLEAN m_fat AND metal6  {  } TEMP = m_fat
    BOOLEAN metal6  NOT m_fat {  } TEMP = m_thin
    if (ignoreBlockage == 0) {
        /* the blockages on the metal_blockage layer are treated as thin blockages */
        BOOLEAN m_thin OR metal6_blockage  {  } TEMP = m_thin
    }
 
    if (fatFatMinSpacing > 0) {
	EXTERNAL m_fat {
	    COMMENT = "$layer_name FatWireSpc: fat & fat ( fatWireThreshold um) minimum spacing = fatFatMinSpacing um"
	    SPACING < fatFatMinSpacing
	    BOX_CORNER = FALSE 
	    NON_PARALLEL = TRUE
	    POINT_TOUCH = FALSE
	    CHECK_SAME_POLYGON = TRUE 
       } (16 )
    }
 
    if (fatThinMinSpacing > 0) {
	EXTERNAL m_fat m_thin {
	    COMMENT = "$layer_name FatWireSpc: fat & thin ( fatWireThreshold um) minimum spacing fatThinMinSpacing um"
	    SPACING < fatThinMinSpacing
 	    BOX_CORNER = FALSE 
	    NON_PARALLEL = TRUE
	    POINT_TOUCH = FALSE
        } (16 )
    }
}
 
/*check thin blockage spacing*/
if (minSpacing > 0 && ignoreBlockage == 0) {
    if (!layer_empty (metal6_blockage )) {
	EXTERNAL metal6_blockage  metal6  {
	    COMMENT = "$layer_name Spacing   : metal & thin blockage minimum spacing = minSpacing um"
	    SPACING < minSpacing
	    BOX_CORNER = FALSE 
	    NON_PARALLEL = TRUE
	    POINT_TOUCH = TRUE
            TOUCH = TRUE
        } (16 )
    }
}
/*check blockage overlap*/
/*check shorts between top_level routing and fram_blockages*/
if (minSpacing>0 || checkCrossHierShort>0) {
   if (ignoreBlockage == 0) {
      BOOLEAN metal6_blockage  or metal6_rbkg  {} TEMP=all_blockage
   } else {
      COPY metal6_rbkg  {} TEMP=all_blockage
   }
   BOOLEAN all_blockage AND metal6_top  {} TEMP = overlap_shape1
   EXTERNAL all_blockage metal6_top  {
      SPACING <= 0
      TOUCH = TRUE
   } TEMP = overlap_shape2
   if (checkCrossHierShort>0) {
      BOOLEAN overlap_shape1 OR overlap_shape2 {
         COMMENT = "$layer_name Short Cross Hierarchy"
      } (16 )
   } else {
      BOOLEAN overlap_shape1 OR overlap_shape2 {
         COMMENT = "$layer_name Overlap   : metal & blockage overlap"
      } (16 )
   }
}
 
if (fatPolyContactRule > 0) {
  /* Fat Poly Contact Rule: not new fat wire formed */
  if (readCellView > 0) {
     SIZE metal1 { UNDER_OVER = fatPolyContactRule / 2.0 - 0.0005  } TEMP = fat
     BOOLEAN fat AND metal1 {  } TEMP = fat 
  } else {
     SIZE metal1_top { UNDER_OVER = fatPolyContactRule / 2.0 - 0.0005  } TEMP = fat
     BOOLEAN fat AND metal1_top {  } TEMP = fat 
  }
  SIZE metal1_pin { UNDER_OVER = fatPolyContactRule / 2.0 - 0.0005  } TEMP = fat_pin
  BOOLEAN fat_pin AND metal1_pin {  } TEMP = fat_pin
  BOOLEAN fat NOT fat_pin {
    COMMENT = "$layer_name FatPolyContactRule: fatPolyContactRule um" 
  } (16 )
}
/* Special End-of-Line Spacing Rule */
if (stubMode == 0 && stubSpacing > 0 && stubSpacing < minSpacing) {
  EXTERNAL metal6  {
     COMMENT = "$layer_name specEoLSpc: spacing= stubSpacing um (mode = 0)"
     LONGEDGE > stubThreshold + 0.0005 
     LONGEDGE_TO_EDGE <= 0 
     SPACING < stubSpacing 
     SET_CORNERS_TO_SPACING = FALSE
     PARALLEL_POINT_PROJECTION = FALSE
  } (16 )
} else if (stubMode > 0 && stubSpacing > minSpacing) {
  if (stubMode == 4) {
     INTERNAL metal6  {
        SEGMENT[90,90] < stubThreshold
        OUTPUT_EDGES = TRUE
     } TEMP = end_of_line
  } else {
     INTERNAL metal6  {
        SEGMENT[90,90] <= stubThreshold
        OUTPUT_EDGES = TRUE
     } TEMP = end_of_line
  }
  /* Quick filter to reduce the size of possible end of line */
  if (sideStubExt > 0) {
    SIZE end_of_line {
       VSIZE_HEAD = sideStubExt
       VSIZE_TAIL = sideStubExt
       OUTPUT_EDGES = TRUE
    } TEMP = eol_ext
  } else {
    COPY end_of_line { } TEMP=eol_ext
  }
  if (stub2StubSpacing > stubSpacing) {
     SET temporary_1 = stub2StubSpacing;
  } else {
     SET temporary_1 = stubSpacing; 
  }
  EXTERNAL eol_ext metal6  {
     SPACING < temporary_1
     TOUCH = TRUE
     OVERLAP = TRUE 
     SET_CORNERS_TO_SPACING = FALSE
     PARALLEL_POINT_PROJECTION = FALSE
     OUTPUT_EDGES = TRUE
  } TEMP=err_edge
  SELECT eol_ext INTERACT err_edge { } TEMP=eol_ext
  SELECT end_of_line INTERACT eol_ext { } TEMP=end_of_line 
  /* Reduce the size of METAL_LAYER */
  if (stubMode==3) {
     SIZE end_of_line {
        VSIZE_HEAD = stubSpacing 
        VSIZE_TAIL = stubSpacing 
        VSIZE_INSIDE = sideStubThreshold
        VSIZE_OUTSIDE = stubSpacing
     } TEMP = eol_filter 
  } else {
     if (stubMode == 1 && stubRange > 0) {
        SIZE end_of_line {
           VSIZE_HEAD = stubSpacing- 0.0005 
           VSIZE_TAIL = stubSpacing- 0.0005 
           VSIZE_OUTSIDE = stubSpacing- 0.0005 
        } TEMP = eol_filter
     } else {
        SIZE end_of_line {
           VSIZE_HEAD = stubSpacing- 0.0005 
           VSIZE_TAIL = stubSpacing- 0.0005 
           VSIZE_INSIDE = sideStubThreshold- 0.0005 
           VSIZE_OUTSIDE = stubSpacing- 0.0005 
        } TEMP = eol_filter
     }
  }
  SELECT metal6  INTERACT eol_filter { } TEMP=target_top
  /* Get the side edges and the whole eol of line set */
  SELECT_EDGE target_top INTERACT end_of_line { 
    POINT_TOUCH = TRUE
  } TEMP = eol_set
  VERTEX target_top { 
     CONCAVE = TRUE 
     CONVEX = TRUE
     SIZE = 0.001 
  } TEMP = corners
  SELECT corners OUTSIDE end_of_line {} TEMP =corners 
  BOOLEAN eol_set NOT corners { } TEMP=eol_set
  BOOLEAN eol_set NOT end_of_line { } TEMP=side_edge
  /* find out the real end of line */
  if (stubRange > 0) {
     if (stubMode == 1) {
         COPY side_edge { } TEMP = all_side_edge
         LENGTH side_edge { SPACING <= stubRange- 0.0005  } TEMP=side_edge
     } else {
         LENGTH side_edge { SPACING < stubRange- 0.001  } TEMP=eol_filter
         BOOLEAN side_edge NOT eol_filter { } TEMP=side_edge
     }
     SELECT end_of_line INTERACT side_edge { RANGE = [1,2] } TEMP = end_of_line
  } 
  if (stubMode == 1) {
    if (stub2StubSpacing > 0) {
       if (sideStubExt < 0) {
          SIZE end_of_line {
            VSIZE_HEAD = sideStubExt / 2
            VSIZE_TAIL = sideStubExt / 2
            OUTPUT_EDGES = TRUE
          } TEMP = eol_ext_tip
	 
          EXTERNAL eol_ext_tip {
            COMMENT = "$layer_name specEoLSpc: stub2Stubspacing= stub2StubSpacing um (mode = 1)"
            SPACING < stub2StubSpacing
            SET_CORNERS_TO_SPACING = FALSE
            PARALLEL_POINT_PROJECTION = TRUE
          } (16 )
       } else {
          EXTERNAL end_of_line {
            COMMENT = "$layer_name specEoLSpc: stub2Stubspacing= stub2StubSpacing um (mode = 1)"
            SPACING < stub2StubSpacing
            SET_CORNERS_TO_SPACING = FALSE
            PARALLEL_POINT_PROJECTION = FALSE
          } (16 )
       }
    }
    if (stubRange > 0) {
       SIZE end_of_line {
         VSIZE_INSIDE = 0.001 
       } TEMP = eol_poly
       SELECT_EDGE eol_poly TOUCHING target_top { } TEMP=eol_edge
       EXTERNAL eol_edge target_top {
         COMMENT = "$layer_name specEoLSpc: spacing= stubSpacing um (mode = 1)"
         CONVEX_TO_CONVEX < stubSpacing
         CONVEX_TO_CONVEX [POINT_PROJECTION] < stubSpacing
         CONVEX_TO_EDGE < stubSpacing
         CONCAVE_TO_CONVEX < stubSpacing
         LONGEDGE > 0.001 
         LONGEDGE_TO_EDGE < stubSpacing
         SPACING <= 0
         SET_CORNERS_TO_SPACING = TRUE
         PARALLEL_POINT_PROJECTION = TRUE
       } (16 )
       SELECT all_side_edge INTERACT end_of_line { } TEMP = side_edge
       SIZE side_edge {
         VSIZE_HEAD = 0.001 
         VSIZE_TAIL = 0.001 
       } TEMP = side_edge_ext
       BOOLEAN side_edge_ext NOT side_edge { } TEMP = side_edge_ext
       SELECT side_edge_ext INTERACT end_of_line { } TEMP = side_edge_ext
       EXTERNAL side_edge_ext target_top {
         COMMENT = "$layer_name specEoLSpc: spacing= stubSpacing um (mode = 1)"
         SPACING < stubSpacing
         SET_CORNERS_TO_SPACING = FALSE
         PARALLEL_POINT_PROJECTION = FALSE
       } (16 )
    } else {
       if (stub2StubSpacing > 0) {
         VECTORIZE target_top {
            DIRECTED=TRUE
         } TEMP=target_edges
         BOOLEAN target_edges NOT end_of_line { } TEMP = target_edges
         EXTERNAL end_of_line target_edges {
            COMMENT = "$layer_name specEoLSpc: spacing= stubSpacing um (mode = 1)"
            SPACING < stubSpacing
            TOUCH=TRUE
            OVERLAP=TRUE
            SET_CORNERS_TO_SPACING=FALSE
            PARALLEL_POINT_PROJECTION=FALSE
         } (16 )
       } else {
         if (sideStubExt > 0) {
            SIZE end_of_line {
               VSIZE_HEAD = sideStubExt
               VSIZE_TAIL = sideStubExt
               OUTPUT_EDGES = TRUE
            } TEMP = end_of_line
            EXTERNAL end_of_line target_top {
               COMMENT = "$layer_name specEoLSpc: spacing= stubSpacing ,crnKeepOut= sideStubExt um (mode = 1)"
               SPACING < stubSpacing
               TOUCH=TRUE
               OVERLAP=TRUE
               SET_CORNERS_TO_SPACING=FALSE
               PARALLEL_POINT_PROJECTION=FALSE
            } (16 )
         } else {
            EXTERNAL end_of_line target_top {
               COMMENT = "$layer_name specEoLSpc: spacing= stubSpacing um (mode = 1)"
               SPACING < stubSpacing
               TOUCH=TRUE
               OVERLAP=TRUE
               SET_CORNERS_TO_SPACING=FALSE
               PARALLEL_POINT_PROJECTION=FALSE
            } (16 )
         }
       }
    }
  } else { /* stubMode == 2,3,4 */
    /* stubMode 2 eol classify and reduction */
    if (stubMode !=3 && sideStubExt > 0) {
      if (stubMode == 4) {
        SIZE end_of_line {
           VSIZE_HEAD = sideStubExt
           VSIZE_TAIL = sideStubExt
           OUTPUT_EDGES = TRUE
        } TEMP = eol_ext
        EXTERNAL eol_ext target_top {
           SPACING < stubSpacing
           SET_CORNERS_TO_SPACING=FALSE
           PARALLEL_POINT_PROJECTION=FALSE
           OUTPUT_EDGES = TRUE
        } TEMP=err_edge
        SELECT eol_ext INTERACT err_edge { } TEMP=eol_ext
      } else {
        EXTERNAL end_of_line target_top {
           SPACING < stubSpacing
           SET_CORNERS_TO_SPACING=FALSE
           PARALLEL_POINT_PROJECTION=FALSE
           OUTPUT_EDGES = TRUE
        } TEMP=err_edge
        SELECT end_of_line INTERACT err_edge { } TEMP=eol_body
        SIZE end_of_line {
           VSIZE_HEAD = sideStubExt
           VSIZE_TAIL = sideStubExt
           OUTPUT_EDGES = TRUE
        } TEMP = eol_ext
        BOOLEAN eol_ext NOT end_of_line {} TEMP=eol_ext
        EXTERNAL eol_ext target_top {
           SPACING < stubSpacing
           SET_CORNERS_TO_SPACING=FALSE
           PARALLEL_POINT_PROJECTION=FALSE
           OUTPUT_EDGES = TRUE
        } TEMP=err_edge
        SELECT eol_ext INTERACT err_edge { } TEMP=eol_ext
        BOOLEAN eol_body OR eol_ext { } TEMP=eol_ext
      } 
    } else {
      COPY end_of_line { } TEMP=eol_ext
    }
    SELECT side_edge INTERACT eol_ext { } TEMP=side_edge
    SIZE eol_ext {
       VSIZE_INSIDE = sideStubThreshold 
       VSIZE_OUTSIDE = sideStubExt
    } TEMP = eol_range
    if (sideStubExt > 0) {
       SIZE side_edge {
          VSIZE_HEAD = sideStubExt
          VSIZE_TAIL = sideStubExt
          OUTPUT_EDGES = TRUE
       } TEMP = check_edge
    } else {
       COPY side_edge { } TEMP = check_edge
    }
    BOOLEAN check_edge AND eol_range { } TEMP=check_edge
    EXTERNAL check_edge target_top {
       SPACING < temporary_1
       SET_CORNERS_TO_SPACING = FALSE
       SHADOW_OTHER_LAYER = TRUE
       PARALLEL_POINT_PROJECTION = FALSE
       OUTPUT_EDGES = TRUE
    } TEMP=err_edge
    if (0 && stubMode!=4) { /* Temporarily do not check mode 2,3 side edge length */
       LENGTH side_edge { SPACING < stubSpacing- 0.0005 *2 } TEMP=err_edge_1
       BOOLEAN err_edge OR err_edge_1 { } TEMP=err_edge
    }
    SELECT check_edge INTERACT err_edge { } TEMP=side_edge
    if (stubMode!=3) {
       SELECT eol_ext INTERACT side_edge {} TEMP=err_eol
       EXTERNAL err_eol target_top {
          COMMENT = "$layer_name specEoLSpc: spacing= stubSpacing ,crnKeepOut= sideStubExt um (mode = stubMode )"
          SPACING < temporary_1
          PARALLEL_POINT_PROJECTION=FALSE
          SET_CORNERS_TO_SPACING=FALSE
       } (16 )
    } else { /* stubMode == 3 */
       SELECT eol_ext INTERACT side_edge { RANGE = [2, 2] } TEMP=err_eol
       EXTERNAL err_eol target_top {
          COMMENT = "$layer_name specEoLSpc: spacing= stubSpacing um (mode = 3)"
          SPACING < temporary_1
          PARALLEL_POINT_PROJECTION=FALSE
          SET_CORNERS_TO_SPACING=FALSE
       } (16 )
    }
  }
} /* stubMode > 0, not aligned */
/* Avoid empty optimization result parsing error */
if (addEmptyMetalCheck) {
   BOOLEAN empty OR empty {
      COMMENT = "$layer_name Empty: Dummy Output"
   } (16 )
   SET addEmptyMetalCheck=0;
}
/* reset variables */


 
SET minWidth = 0;
SET maxWidth = 0;
SET minArea = 0;
SET minEnclosedArea = 0;
SET minSpacing = 0;
SET sameNetMinSpacing = 0;
SET maxNumMinEdge = 0;
SET maxTotalMinEdgeLength = 0;
SET minEdgeLength = 0;
SET minEdgeLength2 = 0;
SET minEdgeLength3 = 0;
SET stubRange = 0;
SET stubSpacing = 0;
SET stub2StubSpacing = 0;
SET sideStubExt = 0;
SET sideStubThreshold = 0;
SET stubThreshold = 0;
SET fatPolyContactRule = 0;
SET fatWireThreshold = 0;
SET fatThinMinSpacing = 0;
SET fatFatMinSpacing = 0;
SET fatTblDimension = 0;
@ 322 "adrc/adrc.ev" 2









/*metal 7*/
SET layer_name = "Met7";










SET minWidth = 0.16;
SET maxWidth = 1000;
SET minArea = 0.07;
SET minSpacing = 0.16;
SET stub2StubSpacing = 0;

SET fatTblDimension = 0;
@ 1 "adrc/adrc_check_metal.ev" 1
/* Data Preparation */
if (fatTblDimension > 1 || fatWireThreshold > 0 || maxWidth > 0) {
  if (ignoreBlockage) {
      /* Let the real blockage be treated as thin */
      BOOLEAN metal7  NOT metal7_rbkg  {} TEMP=fat_candidate
  } else {
      COPY metal7  {} TEMP=fat_candidate
  }
  COPY fat_candidate {} TEMP=fat_target
}
/*Check width*/
if (minWidth > 0) {
    INTERNAL metal7  { 
        COMMENT = "$layer_name MinWidth  : minimum width = minWidth um" 
        SPACING < minWidth
        POINT_TOUCH = FALSE
    } (17 )
}
 
if (maxWidth > 0) {
    SIZE  fat_candidate {
        COMMENT = "$layer_name MaxWidth  : maximum width = maxWidth um"
 	UNDER_OVER = maxWidth / 2 
    } (17 ) 
}
 
/*Check area*/
if (minArea > 0) {
    AREA metal7  { 
	COMMENT = "$layer_name MinArea   : minimum area = minArea um*um"
	RANGE = [0.0005 * 0.0005 , minArea - 0.0005 * 0.0005 ]
    } (17 )
}
/* check min length of bounding box on polygon */
if (minLength > 0) {
  if (minLengthMode == 1) {
    INTERNAL metal7  {
        SPACING < minLength
        VERTICAL_ONLY = TRUE
        SET_CORNERS_TO_SPACING = FALSE
    } TEMP = ver_short
    BOOLEAN metal7  NOT ver_short { } TEMP = ver_long
    INTERNAL metal7  {
        SPACING < minLength
        HORIZONTAL_ONLY = TRUE
        SET_CORNERS_TO_SPACING = FALSE
    } TEMP = hor_short
    BOOLEAN metal7  NOT hor_short { } TEMP = hor_long
    SELECT CUT_LAYER1 INSIDE ver_long { } TEMP = good_cut
    BOOLEAN CUT_LAYER1 NOT good_cut { } TEMP = fail_cut_1
    SELECT fail_cut_1 INSIDE hor_long { } TEMP = good_cut
    BOOLEAN fail_cut_1 NOT good_cut { } TEMP = fail_cut_1
    SELECT CUT_LAYER2 INSIDE ver_long { } TEMP = good_cut
    BOOLEAN CUT_LAYER2 NOT good_cut { } TEMP = fail_cut_2
    SELECT fail_cut_2 INSIDE hor_long { } TEMP = good_cut
    BOOLEAN fail_cut_2 NOT good_cut { } TEMP = fail_cut_2
    BOOLEAN fail_cut_1 OR fail_cut_2 { } TEMP = fail_cut
    BOOLEAN hor_short NOT ver_long { } TEMP = hor_short
    BOOLEAN ver_short NOT hor_long { } TEMP = ver_short
    SELECT ver_short INTERACT fail_cut { } TEMP = ver_fail
    SELECT hor_short INTERACT fail_cut { } TEMP = hor_fail
    BOOLEAN ver_fail OR hor_fail { } TEMP = all_fail
    INTERNAL all_fail {
        COMMENT = "$layer_name MinLength : minimum length = minLength um"
        SPACING < minLength
        VERTICAL_ONLY = TRUE
        SET_CORNERS_TO_SPACING = FALSE
    } (17 )
  } else {
    POLYGON_FEATURES metal7  {
      COMMENT = "$layer_name MinLength : minimum length = minLength um"
      EQUATIONS {
        vnum = EV_VNUM_IN;
        if ( vnum > 0) {
	  bdLeft = EV_VXCOORD_IN[0];
	  bdRight = EV_VXCOORD_IN[0];
	  bdBottom = EV_VYCOORD_IN[0];
	  bdTop = EV_VYCOORD_IN[0];
          FOR (i = 1; i < vnum; i++) {
	    if (bdLeft > EV_VXCOORD_IN[i]) bdLeft = EV_VXCOORD_IN[i];
            else if (bdRight < EV_VXCOORD_IN[i]) bdRight = EV_VXCOORD_IN[i];
	    if (bdBottom > EV_VYCOORD_IN[i]) bdBottom = EV_VYCOORD_IN[i];
            else if (bdTop < EV_VYCOORD_IN[i]) bdTop = EV_VYCOORD_IN[i];
          }
	  if ( (bdRight - bdLeft) < minLength &&
	       (bdTop - bdBottom) < minLength) {
	    FOR (i = 0; i < vnum; i++) {
              EV_VXCOORD_OUT[i] = EV_VXCOORD_IN[i];
	      EV_VYCOORD_OUT[i] = EV_VYCOORD_IN[i];
            }
	    EV_VNUM_OUT = vnum;
	    EV_SAVE_POLYGON();
          }
        }
      }
    } (17 ) 
  }
  SET minLength = 0;
}
/* check max length of bounding box on polygon */
if (maxLength > 0) {
  POLYGON_FEATURES metal7  {
    COMMENT = "$layer_name MaxLength : maximum length = maxLength um"
    EQUATIONS {
      vnum = EV_VNUM_IN;
      if ( vnum > 0) {
	bdLeft = EV_VXCOORD_IN[0];
	bdRight = EV_VXCOORD_IN[0];
	bdBottom = EV_VYCOORD_IN[0];
	bdTop = EV_VYCOORD_IN[0];
        FOR (i = 1; i < vnum; i++) {
	  if (bdLeft > EV_VXCOORD_IN[i]) bdLeft = EV_VXCOORD_IN[i];
          else if (bdRight < EV_VXCOORD_IN[i]) bdRight = EV_VXCOORD_IN[i];
	  if (bdBottom > EV_VYCOORD_IN[i]) bdBottom = EV_VYCOORD_IN[i];
          else if (bdTop < EV_VYCOORD_IN[i]) bdTop = EV_VYCOORD_IN[i];
        }
	if ( (bdRight - bdLeft + bdTop - bdBottom) > maxLength ) {
          EV_VXCOORD_OUT[0] = bdLeft;
	  EV_VYCOORD_OUT[0] = bdBottom;
          EV_VXCOORD_OUT[1] = bdLeft;
	  EV_VYCOORD_OUT[1] = bdTop;
          EV_VXCOORD_OUT[2] = bdRight;
	  EV_VYCOORD_OUT[2] = bdTop;
          EV_VXCOORD_OUT[3] = bdRight;
	  EV_VYCOORD_OUT[3] = bdBottom;
          EV_VXCOORD_OUT[4] = bdLeft;
	  EV_VYCOORD_OUT[4] = bdBottom;
	  EV_VNUM_OUT = 5;
	  EV_SAVE_POLYGON();
        }
      }
    }
  } (17 ) 
  SET maxLength = 0;
}
 
/*Check enclosed area*/
if (minEnclosedArea > 0) {
    SELECT metal7  INSIDE_HOLE {
        INNER_HOLE_ONLY
    } TEMP = holes
    BOOLEAN holes NOT metal7  { } TEMP = holes
 
    AREA holes {
        COMMENT = "$layer_name EnclsArea : minimum enclosed area = minEnclosedArea um*um"
        RANGE = [0.0005 * 0.0005 , minEnclosedArea - 0.0005 * 0.0005 ]
    } (17 )
    /* check min length of bounding box on polygon */
    if (minEnclosedWidth > 0) {
      POLYGON_FEATURES holes {
        COMMENT = "$layer_name EnclsWidth: minimum enclosed Width = minEnclosedWidth um"
        EQUATIONS {
          vnum = EV_VNUM_IN;
          if ( vnum > 0) {
            bdLeft = EV_VXCOORD_IN[0];
            bdRight = EV_VXCOORD_IN[0];
            bdBottom = EV_VYCOORD_IN[0];
            bdTop = EV_VYCOORD_IN[0];
            FOR (i = 1; i < vnum; i++) {
              if (bdLeft > EV_VXCOORD_IN[i]) bdLeft = EV_VXCOORD_IN[i];
              else if (bdRight < EV_VXCOORD_IN[i]) bdRight = EV_VXCOORD_IN[i];
              if (bdBottom > EV_VYCOORD_IN[i]) bdBottom = EV_VYCOORD_IN[i];
              else if (bdTop < EV_VYCOORD_IN[i]) bdTop = EV_VYCOORD_IN[i];
            }
            if ( (bdRight - bdLeft) < minEnclosedWidth &&
                 (bdTop - bdBottom) < minEnclosedWidth) {
              FOR (i = 0; i < vnum; i++) {
                EV_VXCOORD_OUT[i] = EV_VXCOORD_IN[i];
                EV_VYCOORD_OUT[i] = EV_VYCOORD_IN[i];
              }
              EV_VNUM_OUT = vnum;
              EV_SAVE_POLYGON();
            }
          }
        }
      } (17 ) 
    }
}
 
/*check special notch rule*/
if ((minEdgeLength2 > 0.0005  && minEdgeLength3 > 0.0005 ) || minEdgeMode==2) {
  if (minEdgeMode==2) {
    SET minEdgeLength3 = minEdgeLength ;
  }
  NOTCH metal7  {
     SPACING < minEdgeLength3
     SET_CORNERS_TO_SPACING=FALSE
     PARALLEL = TRUE
     OUTPUT_EDGES = TRUE
  } TEMP = notch_vectors
  SELECT_VECTOR notch_vectors {
     LENGTH_RANGE = [0.0005 , minEdgeLength2 - 0.0005 ]
  } TEMP = short_edges
  EXTERNAL short_edges metal7  {
     SPACING < minEdgeLength3
     SET_CORNERS_TO_SPACING=FALSE
     PARALLEL = TRUE
  } TEMP = notch_err
  /* Choose the real U-shaped notch */
  SIZE notch_err { OVERSIZE = 0.001 *10 } TEMP = neighbors 
  BOOLEAN neighbors AND metal7  { } TEMP = neighbors
  VERTEX neighbors { 
     CONCAVE = TRUE
     CONVEX = TRUE
     SIZE = 0.001 
  } TEMP = corners
  SELECT_EDGE neighbors INTERACT notch_err { } TEMP = target_edges
  BOOLEAN target_edges NOT corners { } TEMP = target_edges
  VERTEX neighbors { 
     CONCAVE = TRUE
     SIZE = 2* 0.001 
  } TEMP = corners
  SELECT target_edges INTERACT corners { RANGE = [2, 2] } TEMP=target_edges
  SELECT notch_err INTERACT target_edges {
     COMMENT = "$layer_name SpeclNotch: sameNetSp = minEdgeLength3 um (sideLen minEdgeLength2 um)" 
  } (17 )
}
/*check consecutive short edges*/
if (minEdgeLength > 0.0005  && minEdgeMode != 2) { 
  INTERNAL metal7_top  {
     SEGMENT < minEdgeLength
     FLAG_ACUTE_ANGLE = FALSE
     FLAG_ACUTE_EDGE = FALSE
     OUTPUT_EDGES = TRUE
  } TEMP = short_edges
  if ((minEdgeMode == 0 && maxTotalMinEdgeLength>0) || maxNumMinEdge > 0) {
    SET temporary_1 = 0.001 *2;
    SET temporary_2 = 2*temporary_1+ 0.0005 ;
    SELECT metal7_top  INTERACT short_edges { } TEMP = target_top
    CLASSIFY_EDGES target_top {
       LENGTH = temporary_1
       DMIN   = temporary_2
       INSIDE_CORNER  TEMP = inside_corner_edges
       OUTSIDE_CORNER TEMP = outside_corner_edges
       REMAINDER      TEMP = remainder_edges
    }
    if (minEdgeMode == 0 && (maxNumMinEdge>0 || maxTotalMinEdgeLength > 0)) {
       SELECT short_edges ENCLOSING inside_corner_edges { } TEMP = short_edges
    }
  }
  if (maxTotalMinEdgeLength > 0) {
    LENGTH short_edges {
       RANGE = [maxTotalMinEdgeLength + 0.0005 , 9999999999 ]
    } TEMP = max_length_err
    /* Work around: translate polygons into dimensional check output */
    SIZE max_length_err { OVERSIZE = 2* 0.001  } TEMP = max_length_err
    INTERNAL max_length_err {
       SPACING < 3* 0.001 
       SET_CORNERS_TO_SPACING=FALSE
       COMMENT = "$layer_name MinEdgeLen: maximum total length ( minEdgeLength um)= maxTotalMinEdgeLength um"
    } (17 )
  }
  if (maxTotalMinEdgeLength == 0 || maxNumMinEdge > 0) {
    if (maxNumMinEdge==0)  {
       COPY short_edges {} TEMP=max_edge_err
    } else {
       SIZE short_edges {
         VSIZE_HEAD = - 0.001 
        VSIZE_TAIL = - 0.001 
       } TEMP = short_edges
       SIZE short_edges {
          OVERSIZE = 5* 0.001 
          SIZE_ENDPOINTS = FALSE
       } TEMP = short_contours
       SELECT short_contours ENCLOSING remainder_edges {
          RANGE = [maxNumMinEdge + 1, 9999999999 ]
       } TEMP = short_contours
       SELECT short_edges INSIDE short_contours { } TEMP=max_edge_err
    }
    /* Work around: translate polygons into dimensional check output */
    SIZE max_edge_err { OVERSIZE = 2* 0.001  } TEMP = max_edge_error
    INTERNAL max_edge_error {
       SPACING < 3* 0.001 
       SET_CORNERS_TO_SPACING=FALSE
       COMMENT = "$layer_name MinEdgeLen: maximum number of consecutive short edges ( minEdgeLength um)= maxNumMinEdge"
    } (17 ) 
  }
}
 
/*check basic spacing*/
if (sameNetMinSpacing > 0 && sameNetMinSpacing != minSpacing) {
  if (sameNetMinSpacing > minSpacing) {
    /* Special condition for U-shaped Metal spacing rule */
    NOTCH metal7_pin  {
        SPACING < sameNetMinSpacing
        BOX_CORNER = FALSE 
        SET_CORNERS_TO_SPACING=FALSE
        NON_PARALLEL = TRUE
        OUTPUT_EDGES = TRUE
    } TEMP = errs_to_be_waived
    NOTCH metal7_top  {
	SPACING < sameNetMinSpacing
	BOX_CORNER = FALSE 
        SET_CORNERS_TO_SPACING=FALSE
	NON_PARALLEL = TRUE
        OUTPUT_EDGES = TRUE
    } TEMP = all_errs
    BOOLEAN all_errs NOT errs_to_be_waived { } TEMP=err_edge
    EXTERNAL err_edge metal7_top  {
	SPACING < sameNetMinSpacing
	BOX_CORNER = FALSE 
        SET_CORNERS_TO_SPACING=FALSE
	NON_PARALLEL = TRUE
    } TEMP = notch_err
    SIZE notch_err { OVERSIZE = 0.001 *10 } TEMP = neighbors
    BOOLEAN neighbors AND metal7_top  { } TEMP = neighbors
    VERTEX neighbors { 
       CONCAVE = TRUE
       CONVEX = TRUE
       SIZE = 0.001 
    } TEMP = corners
    SELECT_EDGE neighbors INTERACT notch_err { } TEMP = target_edges
    BOOLEAN target_edges AND notch_err { } TEMP = target_edges
    BOOLEAN target_edges NOT corners { } TEMP = target_edges
    VERTEX neighbors {
       CONCAVE = TRUE
       SIZE = 2* 0.001 
    } TEMP = corners
    SELECT target_edges INTERACT corners { RANGE = [2, 2] } TEMP = target_edges
    SELECT notch_err TOUCHING target_edges {
      COMMENT = "$layer_name U-ShpNotch: U-shape notch minimum spacing = sameNetMinSpacing um" 
    } (17 )
  } else {
    NOTCH metal7  {
        COMMENT = "$layer_name SameNetSpc: same-net minimum spacing = sameNetMinSpacing um" 
	SPACING < sameNetMinSpacing
	BOX_CORNER = FALSE 
	NON_PARALLEL = TRUE
    } (17 )
  }
  if (minSpacing > 0) {
    if (stubMode == 0 && stubSpacing > 0 && stubSpacing < minSpacing) {
	EXTERNAL metal7  {
	    COMMENT = "$layer_name Spacing   : minimum spacing = minSpacing um"
            LONGEDGE > stubThreshold + 0.0005 
	    LONGEDGE_TO_EDGE < minSpacing
	    SPACING <= 0
	    BOX_CORNER = FALSE 
	    NON_PARALLEL = TRUE
            POINT_TOUCH = TRUE
            CHECK_SAME_POLYGON = TRUE 
	} (17 )
    } else {
        EXTERNAL metal7  {
	    COMMENT = "$layer_name Spacing   : minimum spacing = minSpacing um" 
	    SPACING < minSpacing
	    BOX_CORNER = FALSE 
	    NON_PARALLEL = TRUE
            POINT_TOUCH = TRUE
	    CHECK_SAME_POLYGON = FALSE
        } (17 )
    }
  }
} else {
  if (minSpacing > 0) {
    if (stubMode == 0 && stubSpacing > 0 && stubSpacing < minSpacing) {
        EXTERNAL metal7  {
            COMMENT = "$layer_name Spacing   : minimum spacing = minSpacing um"
            LONGEDGE > stubThreshold + 0.0005  
            LONGEDGE_TO_EDGE < minSpacing
            SPACING <= 0 
            BOX_CORNER = FALSE 
            NON_PARALLEL = TRUE
            POINT_TOUCH = TRUE
            CHECK_SAME_POLYGON = TRUE 
        } (17 )
    } else {
        EXTERNAL metal7  {
	    COMMENT = "$layer_name Spacing   : minimum spacing = minSpacing um" 
            SPACING < minSpacing
	    BOX_CORNER = FALSE 
	    NON_PARALLEL = TRUE
	    POINT_TOUCH = TRUE
	    CHECK_SAME_POLYGON = TRUE 
        } (17 )
    }
  }
}
 
/*check dogbone */
if (sameNetMinSpacing > 0 && sameNetWidthThreshold) {
  NOTCH metal7  {
    SPACING < sameNetMinSpacing
    BOX_CORNER = FALSE 
    NON_PARALLEL = TRUE
  } TEMP = dog_bone
 
  if (!layer_empty(dog_bone)) {
    SIZE dog_bone {EDGESIZE = sameNetWidthThreshold} TEMP = dog_ext
    BOOLEAN dog_ext NOT dog_bone {} TEMP = dog_ext
    BOOLEAN dog_ext AND metal7  {} TEMP = dog_ext
    if (!layer_empty(dog_ext)) {
      SELECT dog_ext EDGE_TOUCH dog_bone { OUTSIDE RANGE = [1, 9999999999 ] } TEMP = dog_ext
      NOTCH metal7  {
        SPACING < sameNetMinSpacing
        BOX_CORNER = FALSE 
        NON_PARALLEL = TRUE
	OUTPUT_EDGES = TRUE
      } TEMP = dog_bone
      SELECT dog_ext OUTSIDE dog_bone {} TEMP = dog_ext
      INTERNAL dog_ext {
	COMMENT = "$layer_name dogBone   : notch spacing = sameNetMinSpacing um width sameNetWidthThreshold um" 
	SPACING < sameNetWidthThreshold
      } (17 )
    }
  }
}
/*check basic fat spacing*/
if (fatWireThreshold > 0 && fatTblDimension == 0) {
    SIZE fat_candidate { UNDER_OVER = fatWireThreshold / 2.0 - 0.0005  } TEMP = m_fat
    BOOLEAN m_fat AND metal7  {  } TEMP = m_fat
    BOOLEAN metal7  NOT m_fat {  } TEMP = m_thin
    if (ignoreBlockage == 0) {
        /* the blockages on the metal_blockage layer are treated as thin blockages */
        BOOLEAN m_thin OR metal7_blockage  {  } TEMP = m_thin
    }
 
    if (fatFatMinSpacing > 0) {
	EXTERNAL m_fat {
	    COMMENT = "$layer_name FatWireSpc: fat & fat ( fatWireThreshold um) minimum spacing = fatFatMinSpacing um"
	    SPACING < fatFatMinSpacing
	    BOX_CORNER = FALSE 
	    NON_PARALLEL = TRUE
	    POINT_TOUCH = FALSE
	    CHECK_SAME_POLYGON = TRUE 
       } (17 )
    }
 
    if (fatThinMinSpacing > 0) {
	EXTERNAL m_fat m_thin {
	    COMMENT = "$layer_name FatWireSpc: fat & thin ( fatWireThreshold um) minimum spacing fatThinMinSpacing um"
	    SPACING < fatThinMinSpacing
 	    BOX_CORNER = FALSE 
	    NON_PARALLEL = TRUE
	    POINT_TOUCH = FALSE
        } (17 )
    }
}
 
/*check thin blockage spacing*/
if (minSpacing > 0 && ignoreBlockage == 0) {
    if (!layer_empty (metal7_blockage )) {
	EXTERNAL metal7_blockage  metal7  {
	    COMMENT = "$layer_name Spacing   : metal & thin blockage minimum spacing = minSpacing um"
	    SPACING < minSpacing
	    BOX_CORNER = FALSE 
	    NON_PARALLEL = TRUE
	    POINT_TOUCH = TRUE
            TOUCH = TRUE
        } (17 )
    }
}
/*check blockage overlap*/
/*check shorts between top_level routing and fram_blockages*/
if (minSpacing>0 || checkCrossHierShort>0) {
   if (ignoreBlockage == 0) {
      BOOLEAN metal7_blockage  or metal7_rbkg  {} TEMP=all_blockage
   } else {
      COPY metal7_rbkg  {} TEMP=all_blockage
   }
   BOOLEAN all_blockage AND metal7_top  {} TEMP = overlap_shape1
   EXTERNAL all_blockage metal7_top  {
      SPACING <= 0
      TOUCH = TRUE
   } TEMP = overlap_shape2
   if (checkCrossHierShort>0) {
      BOOLEAN overlap_shape1 OR overlap_shape2 {
         COMMENT = "$layer_name Short Cross Hierarchy"
      } (17 )
   } else {
      BOOLEAN overlap_shape1 OR overlap_shape2 {
         COMMENT = "$layer_name Overlap   : metal & blockage overlap"
      } (17 )
   }
}
 
if (fatPolyContactRule > 0) {
  /* Fat Poly Contact Rule: not new fat wire formed */
  if (readCellView > 0) {
     SIZE metal1 { UNDER_OVER = fatPolyContactRule / 2.0 - 0.0005  } TEMP = fat
     BOOLEAN fat AND metal1 {  } TEMP = fat 
  } else {
     SIZE metal1_top { UNDER_OVER = fatPolyContactRule / 2.0 - 0.0005  } TEMP = fat
     BOOLEAN fat AND metal1_top {  } TEMP = fat 
  }
  SIZE metal1_pin { UNDER_OVER = fatPolyContactRule / 2.0 - 0.0005  } TEMP = fat_pin
  BOOLEAN fat_pin AND metal1_pin {  } TEMP = fat_pin
  BOOLEAN fat NOT fat_pin {
    COMMENT = "$layer_name FatPolyContactRule: fatPolyContactRule um" 
  } (17 )
}
/* Special End-of-Line Spacing Rule */
if (stubMode == 0 && stubSpacing > 0 && stubSpacing < minSpacing) {
  EXTERNAL metal7  {
     COMMENT = "$layer_name specEoLSpc: spacing= stubSpacing um (mode = 0)"
     LONGEDGE > stubThreshold + 0.0005 
     LONGEDGE_TO_EDGE <= 0 
     SPACING < stubSpacing 
     SET_CORNERS_TO_SPACING = FALSE
     PARALLEL_POINT_PROJECTION = FALSE
  } (17 )
} else if (stubMode > 0 && stubSpacing > minSpacing) {
  if (stubMode == 4) {
     INTERNAL metal7  {
        SEGMENT[90,90] < stubThreshold
        OUTPUT_EDGES = TRUE
     } TEMP = end_of_line
  } else {
     INTERNAL metal7  {
        SEGMENT[90,90] <= stubThreshold
        OUTPUT_EDGES = TRUE
     } TEMP = end_of_line
  }
  /* Quick filter to reduce the size of possible end of line */
  if (sideStubExt > 0) {
    SIZE end_of_line {
       VSIZE_HEAD = sideStubExt
       VSIZE_TAIL = sideStubExt
       OUTPUT_EDGES = TRUE
    } TEMP = eol_ext
  } else {
    COPY end_of_line { } TEMP=eol_ext
  }
  if (stub2StubSpacing > stubSpacing) {
     SET temporary_1 = stub2StubSpacing;
  } else {
     SET temporary_1 = stubSpacing; 
  }
  EXTERNAL eol_ext metal7  {
     SPACING < temporary_1
     TOUCH = TRUE
     OVERLAP = TRUE 
     SET_CORNERS_TO_SPACING = FALSE
     PARALLEL_POINT_PROJECTION = FALSE
     OUTPUT_EDGES = TRUE
  } TEMP=err_edge
  SELECT eol_ext INTERACT err_edge { } TEMP=eol_ext
  SELECT end_of_line INTERACT eol_ext { } TEMP=end_of_line 
  /* Reduce the size of METAL_LAYER */
  if (stubMode==3) {
     SIZE end_of_line {
        VSIZE_HEAD = stubSpacing 
        VSIZE_TAIL = stubSpacing 
        VSIZE_INSIDE = sideStubThreshold
        VSIZE_OUTSIDE = stubSpacing
     } TEMP = eol_filter 
  } else {
     if (stubMode == 1 && stubRange > 0) {
        SIZE end_of_line {
           VSIZE_HEAD = stubSpacing- 0.0005 
           VSIZE_TAIL = stubSpacing- 0.0005 
           VSIZE_OUTSIDE = stubSpacing- 0.0005 
        } TEMP = eol_filter
     } else {
        SIZE end_of_line {
           VSIZE_HEAD = stubSpacing- 0.0005 
           VSIZE_TAIL = stubSpacing- 0.0005 
           VSIZE_INSIDE = sideStubThreshold- 0.0005 
           VSIZE_OUTSIDE = stubSpacing- 0.0005 
        } TEMP = eol_filter
     }
  }
  SELECT metal7  INTERACT eol_filter { } TEMP=target_top
  /* Get the side edges and the whole eol of line set */
  SELECT_EDGE target_top INTERACT end_of_line { 
    POINT_TOUCH = TRUE
  } TEMP = eol_set
  VERTEX target_top { 
     CONCAVE = TRUE 
     CONVEX = TRUE
     SIZE = 0.001 
  } TEMP = corners
  SELECT corners OUTSIDE end_of_line {} TEMP =corners 
  BOOLEAN eol_set NOT corners { } TEMP=eol_set
  BOOLEAN eol_set NOT end_of_line { } TEMP=side_edge
  /* find out the real end of line */
  if (stubRange > 0) {
     if (stubMode == 1) {
         COPY side_edge { } TEMP = all_side_edge
         LENGTH side_edge { SPACING <= stubRange- 0.0005  } TEMP=side_edge
     } else {
         LENGTH side_edge { SPACING < stubRange- 0.001  } TEMP=eol_filter
         BOOLEAN side_edge NOT eol_filter { } TEMP=side_edge
     }
     SELECT end_of_line INTERACT side_edge { RANGE = [1,2] } TEMP = end_of_line
  } 
  if (stubMode == 1) {
    if (stub2StubSpacing > 0) {
       if (sideStubExt < 0) {
          SIZE end_of_line {
            VSIZE_HEAD = sideStubExt / 2
            VSIZE_TAIL = sideStubExt / 2
            OUTPUT_EDGES = TRUE
          } TEMP = eol_ext_tip
	 
          EXTERNAL eol_ext_tip {
            COMMENT = "$layer_name specEoLSpc: stub2Stubspacing= stub2StubSpacing um (mode = 1)"
            SPACING < stub2StubSpacing
            SET_CORNERS_TO_SPACING = FALSE
            PARALLEL_POINT_PROJECTION = TRUE
          } (17 )
       } else {
          EXTERNAL end_of_line {
            COMMENT = "$layer_name specEoLSpc: stub2Stubspacing= stub2StubSpacing um (mode = 1)"
            SPACING < stub2StubSpacing
            SET_CORNERS_TO_SPACING = FALSE
            PARALLEL_POINT_PROJECTION = FALSE
          } (17 )
       }
    }
    if (stubRange > 0) {
       SIZE end_of_line {
         VSIZE_INSIDE = 0.001 
       } TEMP = eol_poly
       SELECT_EDGE eol_poly TOUCHING target_top { } TEMP=eol_edge
       EXTERNAL eol_edge target_top {
         COMMENT = "$layer_name specEoLSpc: spacing= stubSpacing um (mode = 1)"
         CONVEX_TO_CONVEX < stubSpacing
         CONVEX_TO_CONVEX [POINT_PROJECTION] < stubSpacing
         CONVEX_TO_EDGE < stubSpacing
         CONCAVE_TO_CONVEX < stubSpacing
         LONGEDGE > 0.001 
         LONGEDGE_TO_EDGE < stubSpacing
         SPACING <= 0
         SET_CORNERS_TO_SPACING = TRUE
         PARALLEL_POINT_PROJECTION = TRUE
       } (17 )
       SELECT all_side_edge INTERACT end_of_line { } TEMP = side_edge
       SIZE side_edge {
         VSIZE_HEAD = 0.001 
         VSIZE_TAIL = 0.001 
       } TEMP = side_edge_ext
       BOOLEAN side_edge_ext NOT side_edge { } TEMP = side_edge_ext
       SELECT side_edge_ext INTERACT end_of_line { } TEMP = side_edge_ext
       EXTERNAL side_edge_ext target_top {
         COMMENT = "$layer_name specEoLSpc: spacing= stubSpacing um (mode = 1)"
         SPACING < stubSpacing
         SET_CORNERS_TO_SPACING = FALSE
         PARALLEL_POINT_PROJECTION = FALSE
       } (17 )
    } else {
       if (stub2StubSpacing > 0) {
         VECTORIZE target_top {
            DIRECTED=TRUE
         } TEMP=target_edges
         BOOLEAN target_edges NOT end_of_line { } TEMP = target_edges
         EXTERNAL end_of_line target_edges {
            COMMENT = "$layer_name specEoLSpc: spacing= stubSpacing um (mode = 1)"
            SPACING < stubSpacing
            TOUCH=TRUE
            OVERLAP=TRUE
            SET_CORNERS_TO_SPACING=FALSE
            PARALLEL_POINT_PROJECTION=FALSE
         } (17 )
       } else {
         if (sideStubExt > 0) {
            SIZE end_of_line {
               VSIZE_HEAD = sideStubExt
               VSIZE_TAIL = sideStubExt
               OUTPUT_EDGES = TRUE
            } TEMP = end_of_line
            EXTERNAL end_of_line target_top {
               COMMENT = "$layer_name specEoLSpc: spacing= stubSpacing ,crnKeepOut= sideStubExt um (mode = 1)"
               SPACING < stubSpacing
               TOUCH=TRUE
               OVERLAP=TRUE
               SET_CORNERS_TO_SPACING=FALSE
               PARALLEL_POINT_PROJECTION=FALSE
            } (17 )
         } else {
            EXTERNAL end_of_line target_top {
               COMMENT = "$layer_name specEoLSpc: spacing= stubSpacing um (mode = 1)"
               SPACING < stubSpacing
               TOUCH=TRUE
               OVERLAP=TRUE
               SET_CORNERS_TO_SPACING=FALSE
               PARALLEL_POINT_PROJECTION=FALSE
            } (17 )
         }
       }
    }
  } else { /* stubMode == 2,3,4 */
    /* stubMode 2 eol classify and reduction */
    if (stubMode !=3 && sideStubExt > 0) {
      if (stubMode == 4) {
        SIZE end_of_line {
           VSIZE_HEAD = sideStubExt
           VSIZE_TAIL = sideStubExt
           OUTPUT_EDGES = TRUE
        } TEMP = eol_ext
        EXTERNAL eol_ext target_top {
           SPACING < stubSpacing
           SET_CORNERS_TO_SPACING=FALSE
           PARALLEL_POINT_PROJECTION=FALSE
           OUTPUT_EDGES = TRUE
        } TEMP=err_edge
        SELECT eol_ext INTERACT err_edge { } TEMP=eol_ext
      } else {
        EXTERNAL end_of_line target_top {
           SPACING < stubSpacing
           SET_CORNERS_TO_SPACING=FALSE
           PARALLEL_POINT_PROJECTION=FALSE
           OUTPUT_EDGES = TRUE
        } TEMP=err_edge
        SELECT end_of_line INTERACT err_edge { } TEMP=eol_body
        SIZE end_of_line {
           VSIZE_HEAD = sideStubExt
           VSIZE_TAIL = sideStubExt
           OUTPUT_EDGES = TRUE
        } TEMP = eol_ext
        BOOLEAN eol_ext NOT end_of_line {} TEMP=eol_ext
        EXTERNAL eol_ext target_top {
           SPACING < stubSpacing
           SET_CORNERS_TO_SPACING=FALSE
           PARALLEL_POINT_PROJECTION=FALSE
           OUTPUT_EDGES = TRUE
        } TEMP=err_edge
        SELECT eol_ext INTERACT err_edge { } TEMP=eol_ext
        BOOLEAN eol_body OR eol_ext { } TEMP=eol_ext
      } 
    } else {
      COPY end_of_line { } TEMP=eol_ext
    }
    SELECT side_edge INTERACT eol_ext { } TEMP=side_edge
    SIZE eol_ext {
       VSIZE_INSIDE = sideStubThreshold 
       VSIZE_OUTSIDE = sideStubExt
    } TEMP = eol_range
    if (sideStubExt > 0) {
       SIZE side_edge {
          VSIZE_HEAD = sideStubExt
          VSIZE_TAIL = sideStubExt
          OUTPUT_EDGES = TRUE
       } TEMP = check_edge
    } else {
       COPY side_edge { } TEMP = check_edge
    }
    BOOLEAN check_edge AND eol_range { } TEMP=check_edge
    EXTERNAL check_edge target_top {
       SPACING < temporary_1
       SET_CORNERS_TO_SPACING = FALSE
       SHADOW_OTHER_LAYER = TRUE
       PARALLEL_POINT_PROJECTION = FALSE
       OUTPUT_EDGES = TRUE
    } TEMP=err_edge
    if (0 && stubMode!=4) { /* Temporarily do not check mode 2,3 side edge length */
       LENGTH side_edge { SPACING < stubSpacing- 0.0005 *2 } TEMP=err_edge_1
       BOOLEAN err_edge OR err_edge_1 { } TEMP=err_edge
    }
    SELECT check_edge INTERACT err_edge { } TEMP=side_edge
    if (stubMode!=3) {
       SELECT eol_ext INTERACT side_edge {} TEMP=err_eol
       EXTERNAL err_eol target_top {
          COMMENT = "$layer_name specEoLSpc: spacing= stubSpacing ,crnKeepOut= sideStubExt um (mode = stubMode )"
          SPACING < temporary_1
          PARALLEL_POINT_PROJECTION=FALSE
          SET_CORNERS_TO_SPACING=FALSE
       } (17 )
    } else { /* stubMode == 3 */
       SELECT eol_ext INTERACT side_edge { RANGE = [2, 2] } TEMP=err_eol
       EXTERNAL err_eol target_top {
          COMMENT = "$layer_name specEoLSpc: spacing= stubSpacing um (mode = 3)"
          SPACING < temporary_1
          PARALLEL_POINT_PROJECTION=FALSE
          SET_CORNERS_TO_SPACING=FALSE
       } (17 )
    }
  }
} /* stubMode > 0, not aligned */
/* Avoid empty optimization result parsing error */
if (addEmptyMetalCheck) {
   BOOLEAN empty OR empty {
      COMMENT = "$layer_name Empty: Dummy Output"
   } (17 )
   SET addEmptyMetalCheck=0;
}
/* reset variables */


 
SET minWidth = 0;
SET maxWidth = 0;
SET minArea = 0;
SET minEnclosedArea = 0;
SET minSpacing = 0;
SET sameNetMinSpacing = 0;
SET maxNumMinEdge = 0;
SET maxTotalMinEdgeLength = 0;
SET minEdgeLength = 0;
SET minEdgeLength2 = 0;
SET minEdgeLength3 = 0;
SET stubRange = 0;
SET stubSpacing = 0;
SET stub2StubSpacing = 0;
SET sideStubExt = 0;
SET sideStubThreshold = 0;
SET stubThreshold = 0;
SET fatPolyContactRule = 0;
SET fatWireThreshold = 0;
SET fatThinMinSpacing = 0;
SET fatFatMinSpacing = 0;
SET fatTblDimension = 0;
@ 350 "adrc/adrc.ev" 2









/*metal 8*/
SET layer_name = "Met8";










SET minWidth = 0.16;
SET maxWidth = 1000;
SET minArea = 0.07;
SET minSpacing = 0.16;
SET stub2StubSpacing = 0;

SET fatTblDimension = 0;
@ 1 "adrc/adrc_check_metal.ev" 1
/* Data Preparation */
if (fatTblDimension > 1 || fatWireThreshold > 0 || maxWidth > 0) {
  if (ignoreBlockage) {
      /* Let the real blockage be treated as thin */
      BOOLEAN metal8  NOT metal8_rbkg  {} TEMP=fat_candidate
  } else {
      COPY metal8  {} TEMP=fat_candidate
  }
  COPY fat_candidate {} TEMP=fat_target
}
/*Check width*/
if (minWidth > 0) {
    INTERNAL metal8  { 
        COMMENT = "$layer_name MinWidth  : minimum width = minWidth um" 
        SPACING < minWidth
        POINT_TOUCH = FALSE
    } (18 )
}
 
if (maxWidth > 0) {
    SIZE  fat_candidate {
        COMMENT = "$layer_name MaxWidth  : maximum width = maxWidth um"
 	UNDER_OVER = maxWidth / 2 
    } (18 ) 
}
 
/*Check area*/
if (minArea > 0) {
    AREA metal8  { 
	COMMENT = "$layer_name MinArea   : minimum area = minArea um*um"
	RANGE = [0.0005 * 0.0005 , minArea - 0.0005 * 0.0005 ]
    } (18 )
}
/* check min length of bounding box on polygon */
if (minLength > 0) {
  if (minLengthMode == 1) {
    INTERNAL metal8  {
        SPACING < minLength
        VERTICAL_ONLY = TRUE
        SET_CORNERS_TO_SPACING = FALSE
    } TEMP = ver_short
    BOOLEAN metal8  NOT ver_short { } TEMP = ver_long
    INTERNAL metal8  {
        SPACING < minLength
        HORIZONTAL_ONLY = TRUE
        SET_CORNERS_TO_SPACING = FALSE
    } TEMP = hor_short
    BOOLEAN metal8  NOT hor_short { } TEMP = hor_long
    SELECT CUT_LAYER1 INSIDE ver_long { } TEMP = good_cut
    BOOLEAN CUT_LAYER1 NOT good_cut { } TEMP = fail_cut_1
    SELECT fail_cut_1 INSIDE hor_long { } TEMP = good_cut
    BOOLEAN fail_cut_1 NOT good_cut { } TEMP = fail_cut_1
    SELECT CUT_LAYER2 INSIDE ver_long { } TEMP = good_cut
    BOOLEAN CUT_LAYER2 NOT good_cut { } TEMP = fail_cut_2
    SELECT fail_cut_2 INSIDE hor_long { } TEMP = good_cut
    BOOLEAN fail_cut_2 NOT good_cut { } TEMP = fail_cut_2
    BOOLEAN fail_cut_1 OR fail_cut_2 { } TEMP = fail_cut
    BOOLEAN hor_short NOT ver_long { } TEMP = hor_short
    BOOLEAN ver_short NOT hor_long { } TEMP = ver_short
    SELECT ver_short INTERACT fail_cut { } TEMP = ver_fail
    SELECT hor_short INTERACT fail_cut { } TEMP = hor_fail
    BOOLEAN ver_fail OR hor_fail { } TEMP = all_fail
    INTERNAL all_fail {
        COMMENT = "$layer_name MinLength : minimum length = minLength um"
        SPACING < minLength
        VERTICAL_ONLY = TRUE
        SET_CORNERS_TO_SPACING = FALSE
    } (18 )
  } else {
    POLYGON_FEATURES metal8  {
      COMMENT = "$layer_name MinLength : minimum length = minLength um"
      EQUATIONS {
        vnum = EV_VNUM_IN;
        if ( vnum > 0) {
	  bdLeft = EV_VXCOORD_IN[0];
	  bdRight = EV_VXCOORD_IN[0];
	  bdBottom = EV_VYCOORD_IN[0];
	  bdTop = EV_VYCOORD_IN[0];
          FOR (i = 1; i < vnum; i++) {
	    if (bdLeft > EV_VXCOORD_IN[i]) bdLeft = EV_VXCOORD_IN[i];
            else if (bdRight < EV_VXCOORD_IN[i]) bdRight = EV_VXCOORD_IN[i];
	    if (bdBottom > EV_VYCOORD_IN[i]) bdBottom = EV_VYCOORD_IN[i];
            else if (bdTop < EV_VYCOORD_IN[i]) bdTop = EV_VYCOORD_IN[i];
          }
	  if ( (bdRight - bdLeft) < minLength &&
	       (bdTop - bdBottom) < minLength) {
	    FOR (i = 0; i < vnum; i++) {
              EV_VXCOORD_OUT[i] = EV_VXCOORD_IN[i];
	      EV_VYCOORD_OUT[i] = EV_VYCOORD_IN[i];
            }
	    EV_VNUM_OUT = vnum;
	    EV_SAVE_POLYGON();
          }
        }
      }
    } (18 ) 
  }
  SET minLength = 0;
}
/* check max length of bounding box on polygon */
if (maxLength > 0) {
  POLYGON_FEATURES metal8  {
    COMMENT = "$layer_name MaxLength : maximum length = maxLength um"
    EQUATIONS {
      vnum = EV_VNUM_IN;
      if ( vnum > 0) {
	bdLeft = EV_VXCOORD_IN[0];
	bdRight = EV_VXCOORD_IN[0];
	bdBottom = EV_VYCOORD_IN[0];
	bdTop = EV_VYCOORD_IN[0];
        FOR (i = 1; i < vnum; i++) {
	  if (bdLeft > EV_VXCOORD_IN[i]) bdLeft = EV_VXCOORD_IN[i];
          else if (bdRight < EV_VXCOORD_IN[i]) bdRight = EV_VXCOORD_IN[i];
	  if (bdBottom > EV_VYCOORD_IN[i]) bdBottom = EV_VYCOORD_IN[i];
          else if (bdTop < EV_VYCOORD_IN[i]) bdTop = EV_VYCOORD_IN[i];
        }
	if ( (bdRight - bdLeft + bdTop - bdBottom) > maxLength ) {
          EV_VXCOORD_OUT[0] = bdLeft;
	  EV_VYCOORD_OUT[0] = bdBottom;
          EV_VXCOORD_OUT[1] = bdLeft;
	  EV_VYCOORD_OUT[1] = bdTop;
          EV_VXCOORD_OUT[2] = bdRight;
	  EV_VYCOORD_OUT[2] = bdTop;
          EV_VXCOORD_OUT[3] = bdRight;
	  EV_VYCOORD_OUT[3] = bdBottom;
          EV_VXCOORD_OUT[4] = bdLeft;
	  EV_VYCOORD_OUT[4] = bdBottom;
	  EV_VNUM_OUT = 5;
	  EV_SAVE_POLYGON();
        }
      }
    }
  } (18 ) 
  SET maxLength = 0;
}
 
/*Check enclosed area*/
if (minEnclosedArea > 0) {
    SELECT metal8  INSIDE_HOLE {
        INNER_HOLE_ONLY
    } TEMP = holes
    BOOLEAN holes NOT metal8  { } TEMP = holes
 
    AREA holes {
        COMMENT = "$layer_name EnclsArea : minimum enclosed area = minEnclosedArea um*um"
        RANGE = [0.0005 * 0.0005 , minEnclosedArea - 0.0005 * 0.0005 ]
    } (18 )
    /* check min length of bounding box on polygon */
    if (minEnclosedWidth > 0) {
      POLYGON_FEATURES holes {
        COMMENT = "$layer_name EnclsWidth: minimum enclosed Width = minEnclosedWidth um"
        EQUATIONS {
          vnum = EV_VNUM_IN;
          if ( vnum > 0) {
            bdLeft = EV_VXCOORD_IN[0];
            bdRight = EV_VXCOORD_IN[0];
            bdBottom = EV_VYCOORD_IN[0];
            bdTop = EV_VYCOORD_IN[0];
            FOR (i = 1; i < vnum; i++) {
              if (bdLeft > EV_VXCOORD_IN[i]) bdLeft = EV_VXCOORD_IN[i];
              else if (bdRight < EV_VXCOORD_IN[i]) bdRight = EV_VXCOORD_IN[i];
              if (bdBottom > EV_VYCOORD_IN[i]) bdBottom = EV_VYCOORD_IN[i];
              else if (bdTop < EV_VYCOORD_IN[i]) bdTop = EV_VYCOORD_IN[i];
            }
            if ( (bdRight - bdLeft) < minEnclosedWidth &&
                 (bdTop - bdBottom) < minEnclosedWidth) {
              FOR (i = 0; i < vnum; i++) {
                EV_VXCOORD_OUT[i] = EV_VXCOORD_IN[i];
                EV_VYCOORD_OUT[i] = EV_VYCOORD_IN[i];
              }
              EV_VNUM_OUT = vnum;
              EV_SAVE_POLYGON();
            }
          }
        }
      } (18 ) 
    }
}
 
/*check special notch rule*/
if ((minEdgeLength2 > 0.0005  && minEdgeLength3 > 0.0005 ) || minEdgeMode==2) {
  if (minEdgeMode==2) {
    SET minEdgeLength3 = minEdgeLength ;
  }
  NOTCH metal8  {
     SPACING < minEdgeLength3
     SET_CORNERS_TO_SPACING=FALSE
     PARALLEL = TRUE
     OUTPUT_EDGES = TRUE
  } TEMP = notch_vectors
  SELECT_VECTOR notch_vectors {
     LENGTH_RANGE = [0.0005 , minEdgeLength2 - 0.0005 ]
  } TEMP = short_edges
  EXTERNAL short_edges metal8  {
     SPACING < minEdgeLength3
     SET_CORNERS_TO_SPACING=FALSE
     PARALLEL = TRUE
  } TEMP = notch_err
  /* Choose the real U-shaped notch */
  SIZE notch_err { OVERSIZE = 0.001 *10 } TEMP = neighbors 
  BOOLEAN neighbors AND metal8  { } TEMP = neighbors
  VERTEX neighbors { 
     CONCAVE = TRUE
     CONVEX = TRUE
     SIZE = 0.001 
  } TEMP = corners
  SELECT_EDGE neighbors INTERACT notch_err { } TEMP = target_edges
  BOOLEAN target_edges NOT corners { } TEMP = target_edges
  VERTEX neighbors { 
     CONCAVE = TRUE
     SIZE = 2* 0.001 
  } TEMP = corners
  SELECT target_edges INTERACT corners { RANGE = [2, 2] } TEMP=target_edges
  SELECT notch_err INTERACT target_edges {
     COMMENT = "$layer_name SpeclNotch: sameNetSp = minEdgeLength3 um (sideLen minEdgeLength2 um)" 
  } (18 )
}
/*check consecutive short edges*/
if (minEdgeLength > 0.0005  && minEdgeMode != 2) { 
  INTERNAL metal8_top  {
     SEGMENT < minEdgeLength
     FLAG_ACUTE_ANGLE = FALSE
     FLAG_ACUTE_EDGE = FALSE
     OUTPUT_EDGES = TRUE
  } TEMP = short_edges
  if ((minEdgeMode == 0 && maxTotalMinEdgeLength>0) || maxNumMinEdge > 0) {
    SET temporary_1 = 0.001 *2;
    SET temporary_2 = 2*temporary_1+ 0.0005 ;
    SELECT metal8_top  INTERACT short_edges { } TEMP = target_top
    CLASSIFY_EDGES target_top {
       LENGTH = temporary_1
       DMIN   = temporary_2
       INSIDE_CORNER  TEMP = inside_corner_edges
       OUTSIDE_CORNER TEMP = outside_corner_edges
       REMAINDER      TEMP = remainder_edges
    }
    if (minEdgeMode == 0 && (maxNumMinEdge>0 || maxTotalMinEdgeLength > 0)) {
       SELECT short_edges ENCLOSING inside_corner_edges { } TEMP = short_edges
    }
  }
  if (maxTotalMinEdgeLength > 0) {
    LENGTH short_edges {
       RANGE = [maxTotalMinEdgeLength + 0.0005 , 9999999999 ]
    } TEMP = max_length_err
    /* Work around: translate polygons into dimensional check output */
    SIZE max_length_err { OVERSIZE = 2* 0.001  } TEMP = max_length_err
    INTERNAL max_length_err {
       SPACING < 3* 0.001 
       SET_CORNERS_TO_SPACING=FALSE
       COMMENT = "$layer_name MinEdgeLen: maximum total length ( minEdgeLength um)= maxTotalMinEdgeLength um"
    } (18 )
  }
  if (maxTotalMinEdgeLength == 0 || maxNumMinEdge > 0) {
    if (maxNumMinEdge==0)  {
       COPY short_edges {} TEMP=max_edge_err
    } else {
       SIZE short_edges {
         VSIZE_HEAD = - 0.001 
        VSIZE_TAIL = - 0.001 
       } TEMP = short_edges
       SIZE short_edges {
          OVERSIZE = 5* 0.001 
          SIZE_ENDPOINTS = FALSE
       } TEMP = short_contours
       SELECT short_contours ENCLOSING remainder_edges {
          RANGE = [maxNumMinEdge + 1, 9999999999 ]
       } TEMP = short_contours
       SELECT short_edges INSIDE short_contours { } TEMP=max_edge_err
    }
    /* Work around: translate polygons into dimensional check output */
    SIZE max_edge_err { OVERSIZE = 2* 0.001  } TEMP = max_edge_error
    INTERNAL max_edge_error {
       SPACING < 3* 0.001 
       SET_CORNERS_TO_SPACING=FALSE
       COMMENT = "$layer_name MinEdgeLen: maximum number of consecutive short edges ( minEdgeLength um)= maxNumMinEdge"
    } (18 ) 
  }
}
 
/*check basic spacing*/
if (sameNetMinSpacing > 0 && sameNetMinSpacing != minSpacing) {
  if (sameNetMinSpacing > minSpacing) {
    /* Special condition for U-shaped Metal spacing rule */
    NOTCH metal8_pin  {
        SPACING < sameNetMinSpacing
        BOX_CORNER = FALSE 
        SET_CORNERS_TO_SPACING=FALSE
        NON_PARALLEL = TRUE
        OUTPUT_EDGES = TRUE
    } TEMP = errs_to_be_waived
    NOTCH metal8_top  {
	SPACING < sameNetMinSpacing
	BOX_CORNER = FALSE 
        SET_CORNERS_TO_SPACING=FALSE
	NON_PARALLEL = TRUE
        OUTPUT_EDGES = TRUE
    } TEMP = all_errs
    BOOLEAN all_errs NOT errs_to_be_waived { } TEMP=err_edge
    EXTERNAL err_edge metal8_top  {
	SPACING < sameNetMinSpacing
	BOX_CORNER = FALSE 
        SET_CORNERS_TO_SPACING=FALSE
	NON_PARALLEL = TRUE
    } TEMP = notch_err
    SIZE notch_err { OVERSIZE = 0.001 *10 } TEMP = neighbors
    BOOLEAN neighbors AND metal8_top  { } TEMP = neighbors
    VERTEX neighbors { 
       CONCAVE = TRUE
       CONVEX = TRUE
       SIZE = 0.001 
    } TEMP = corners
    SELECT_EDGE neighbors INTERACT notch_err { } TEMP = target_edges
    BOOLEAN target_edges AND notch_err { } TEMP = target_edges
    BOOLEAN target_edges NOT corners { } TEMP = target_edges
    VERTEX neighbors {
       CONCAVE = TRUE
       SIZE = 2* 0.001 
    } TEMP = corners
    SELECT target_edges INTERACT corners { RANGE = [2, 2] } TEMP = target_edges
    SELECT notch_err TOUCHING target_edges {
      COMMENT = "$layer_name U-ShpNotch: U-shape notch minimum spacing = sameNetMinSpacing um" 
    } (18 )
  } else {
    NOTCH metal8  {
        COMMENT = "$layer_name SameNetSpc: same-net minimum spacing = sameNetMinSpacing um" 
	SPACING < sameNetMinSpacing
	BOX_CORNER = FALSE 
	NON_PARALLEL = TRUE
    } (18 )
  }
  if (minSpacing > 0) {
    if (stubMode == 0 && stubSpacing > 0 && stubSpacing < minSpacing) {
	EXTERNAL metal8  {
	    COMMENT = "$layer_name Spacing   : minimum spacing = minSpacing um"
            LONGEDGE > stubThreshold + 0.0005 
	    LONGEDGE_TO_EDGE < minSpacing
	    SPACING <= 0
	    BOX_CORNER = FALSE 
	    NON_PARALLEL = TRUE
            POINT_TOUCH = TRUE
            CHECK_SAME_POLYGON = TRUE 
	} (18 )
    } else {
        EXTERNAL metal8  {
	    COMMENT = "$layer_name Spacing   : minimum spacing = minSpacing um" 
	    SPACING < minSpacing
	    BOX_CORNER = FALSE 
	    NON_PARALLEL = TRUE
            POINT_TOUCH = TRUE
	    CHECK_SAME_POLYGON = FALSE
        } (18 )
    }
  }
} else {
  if (minSpacing > 0) {
    if (stubMode == 0 && stubSpacing > 0 && stubSpacing < minSpacing) {
        EXTERNAL metal8  {
            COMMENT = "$layer_name Spacing   : minimum spacing = minSpacing um"
            LONGEDGE > stubThreshold + 0.0005  
            LONGEDGE_TO_EDGE < minSpacing
            SPACING <= 0 
            BOX_CORNER = FALSE 
            NON_PARALLEL = TRUE
            POINT_TOUCH = TRUE
            CHECK_SAME_POLYGON = TRUE 
        } (18 )
    } else {
        EXTERNAL metal8  {
	    COMMENT = "$layer_name Spacing   : minimum spacing = minSpacing um" 
            SPACING < minSpacing
	    BOX_CORNER = FALSE 
	    NON_PARALLEL = TRUE
	    POINT_TOUCH = TRUE
	    CHECK_SAME_POLYGON = TRUE 
        } (18 )
    }
  }
}
 
/*check dogbone */
if (sameNetMinSpacing > 0 && sameNetWidthThreshold) {
  NOTCH metal8  {
    SPACING < sameNetMinSpacing
    BOX_CORNER = FALSE 
    NON_PARALLEL = TRUE
  } TEMP = dog_bone
 
  if (!layer_empty(dog_bone)) {
    SIZE dog_bone {EDGESIZE = sameNetWidthThreshold} TEMP = dog_ext
    BOOLEAN dog_ext NOT dog_bone {} TEMP = dog_ext
    BOOLEAN dog_ext AND metal8  {} TEMP = dog_ext
    if (!layer_empty(dog_ext)) {
      SELECT dog_ext EDGE_TOUCH dog_bone { OUTSIDE RANGE = [1, 9999999999 ] } TEMP = dog_ext
      NOTCH metal8  {
        SPACING < sameNetMinSpacing
        BOX_CORNER = FALSE 
        NON_PARALLEL = TRUE
	OUTPUT_EDGES = TRUE
      } TEMP = dog_bone
      SELECT dog_ext OUTSIDE dog_bone {} TEMP = dog_ext
      INTERNAL dog_ext {
	COMMENT = "$layer_name dogBone   : notch spacing = sameNetMinSpacing um width sameNetWidthThreshold um" 
	SPACING < sameNetWidthThreshold
      } (18 )
    }
  }
}
/*check basic fat spacing*/
if (fatWireThreshold > 0 && fatTblDimension == 0) {
    SIZE fat_candidate { UNDER_OVER = fatWireThreshold / 2.0 - 0.0005  } TEMP = m_fat
    BOOLEAN m_fat AND metal8  {  } TEMP = m_fat
    BOOLEAN metal8  NOT m_fat {  } TEMP = m_thin
    if (ignoreBlockage == 0) {
        /* the blockages on the metal_blockage layer are treated as thin blockages */
        BOOLEAN m_thin OR metal8_blockage  {  } TEMP = m_thin
    }
 
    if (fatFatMinSpacing > 0) {
	EXTERNAL m_fat {
	    COMMENT = "$layer_name FatWireSpc: fat & fat ( fatWireThreshold um) minimum spacing = fatFatMinSpacing um"
	    SPACING < fatFatMinSpacing
	    BOX_CORNER = FALSE 
	    NON_PARALLEL = TRUE
	    POINT_TOUCH = FALSE
	    CHECK_SAME_POLYGON = TRUE 
       } (18 )
    }
 
    if (fatThinMinSpacing > 0) {
	EXTERNAL m_fat m_thin {
	    COMMENT = "$layer_name FatWireSpc: fat & thin ( fatWireThreshold um) minimum spacing fatThinMinSpacing um"
	    SPACING < fatThinMinSpacing
 	    BOX_CORNER = FALSE 
	    NON_PARALLEL = TRUE
	    POINT_TOUCH = FALSE
        } (18 )
    }
}
 
/*check thin blockage spacing*/
if (minSpacing > 0 && ignoreBlockage == 0) {
    if (!layer_empty (metal8_blockage )) {
	EXTERNAL metal8_blockage  metal8  {
	    COMMENT = "$layer_name Spacing   : metal & thin blockage minimum spacing = minSpacing um"
	    SPACING < minSpacing
	    BOX_CORNER = FALSE 
	    NON_PARALLEL = TRUE
	    POINT_TOUCH = TRUE
            TOUCH = TRUE
        } (18 )
    }
}
/*check blockage overlap*/
/*check shorts between top_level routing and fram_blockages*/
if (minSpacing>0 || checkCrossHierShort>0) {
   if (ignoreBlockage == 0) {
      BOOLEAN metal8_blockage  or metal8_rbkg  {} TEMP=all_blockage
   } else {
      COPY metal8_rbkg  {} TEMP=all_blockage
   }
   BOOLEAN all_blockage AND metal8_top  {} TEMP = overlap_shape1
   EXTERNAL all_blockage metal8_top  {
      SPACING <= 0
      TOUCH = TRUE
   } TEMP = overlap_shape2
   if (checkCrossHierShort>0) {
      BOOLEAN overlap_shape1 OR overlap_shape2 {
         COMMENT = "$layer_name Short Cross Hierarchy"
      } (18 )
   } else {
      BOOLEAN overlap_shape1 OR overlap_shape2 {
         COMMENT = "$layer_name Overlap   : metal & blockage overlap"
      } (18 )
   }
}
 
if (fatPolyContactRule > 0) {
  /* Fat Poly Contact Rule: not new fat wire formed */
  if (readCellView > 0) {
     SIZE metal1 { UNDER_OVER = fatPolyContactRule / 2.0 - 0.0005  } TEMP = fat
     BOOLEAN fat AND metal1 {  } TEMP = fat 
  } else {
     SIZE metal1_top { UNDER_OVER = fatPolyContactRule / 2.0 - 0.0005  } TEMP = fat
     BOOLEAN fat AND metal1_top {  } TEMP = fat 
  }
  SIZE metal1_pin { UNDER_OVER = fatPolyContactRule / 2.0 - 0.0005  } TEMP = fat_pin
  BOOLEAN fat_pin AND metal1_pin {  } TEMP = fat_pin
  BOOLEAN fat NOT fat_pin {
    COMMENT = "$layer_name FatPolyContactRule: fatPolyContactRule um" 
  } (18 )
}
/* Special End-of-Line Spacing Rule */
if (stubMode == 0 && stubSpacing > 0 && stubSpacing < minSpacing) {
  EXTERNAL metal8  {
     COMMENT = "$layer_name specEoLSpc: spacing= stubSpacing um (mode = 0)"
     LONGEDGE > stubThreshold + 0.0005 
     LONGEDGE_TO_EDGE <= 0 
     SPACING < stubSpacing 
     SET_CORNERS_TO_SPACING = FALSE
     PARALLEL_POINT_PROJECTION = FALSE
  } (18 )
} else if (stubMode > 0 && stubSpacing > minSpacing) {
  if (stubMode == 4) {
     INTERNAL metal8  {
        SEGMENT[90,90] < stubThreshold
        OUTPUT_EDGES = TRUE
     } TEMP = end_of_line
  } else {
     INTERNAL metal8  {
        SEGMENT[90,90] <= stubThreshold
        OUTPUT_EDGES = TRUE
     } TEMP = end_of_line
  }
  /* Quick filter to reduce the size of possible end of line */
  if (sideStubExt > 0) {
    SIZE end_of_line {
       VSIZE_HEAD = sideStubExt
       VSIZE_TAIL = sideStubExt
       OUTPUT_EDGES = TRUE
    } TEMP = eol_ext
  } else {
    COPY end_of_line { } TEMP=eol_ext
  }
  if (stub2StubSpacing > stubSpacing) {
     SET temporary_1 = stub2StubSpacing;
  } else {
     SET temporary_1 = stubSpacing; 
  }
  EXTERNAL eol_ext metal8  {
     SPACING < temporary_1
     TOUCH = TRUE
     OVERLAP = TRUE 
     SET_CORNERS_TO_SPACING = FALSE
     PARALLEL_POINT_PROJECTION = FALSE
     OUTPUT_EDGES = TRUE
  } TEMP=err_edge
  SELECT eol_ext INTERACT err_edge { } TEMP=eol_ext
  SELECT end_of_line INTERACT eol_ext { } TEMP=end_of_line 
  /* Reduce the size of METAL_LAYER */
  if (stubMode==3) {
     SIZE end_of_line {
        VSIZE_HEAD = stubSpacing 
        VSIZE_TAIL = stubSpacing 
        VSIZE_INSIDE = sideStubThreshold
        VSIZE_OUTSIDE = stubSpacing
     } TEMP = eol_filter 
  } else {
     if (stubMode == 1 && stubRange > 0) {
        SIZE end_of_line {
           VSIZE_HEAD = stubSpacing- 0.0005 
           VSIZE_TAIL = stubSpacing- 0.0005 
           VSIZE_OUTSIDE = stubSpacing- 0.0005 
        } TEMP = eol_filter
     } else {
        SIZE end_of_line {
           VSIZE_HEAD = stubSpacing- 0.0005 
           VSIZE_TAIL = stubSpacing- 0.0005 
           VSIZE_INSIDE = sideStubThreshold- 0.0005 
           VSIZE_OUTSIDE = stubSpacing- 0.0005 
        } TEMP = eol_filter
     }
  }
  SELECT metal8  INTERACT eol_filter { } TEMP=target_top
  /* Get the side edges and the whole eol of line set */
  SELECT_EDGE target_top INTERACT end_of_line { 
    POINT_TOUCH = TRUE
  } TEMP = eol_set
  VERTEX target_top { 
     CONCAVE = TRUE 
     CONVEX = TRUE
     SIZE = 0.001 
  } TEMP = corners
  SELECT corners OUTSIDE end_of_line {} TEMP =corners 
  BOOLEAN eol_set NOT corners { } TEMP=eol_set
  BOOLEAN eol_set NOT end_of_line { } TEMP=side_edge
  /* find out the real end of line */
  if (stubRange > 0) {
     if (stubMode == 1) {
         COPY side_edge { } TEMP = all_side_edge
         LENGTH side_edge { SPACING <= stubRange- 0.0005  } TEMP=side_edge
     } else {
         LENGTH side_edge { SPACING < stubRange- 0.001  } TEMP=eol_filter
         BOOLEAN side_edge NOT eol_filter { } TEMP=side_edge
     }
     SELECT end_of_line INTERACT side_edge { RANGE = [1,2] } TEMP = end_of_line
  } 
  if (stubMode == 1) {
    if (stub2StubSpacing > 0) {
       if (sideStubExt < 0) {
          SIZE end_of_line {
            VSIZE_HEAD = sideStubExt / 2
            VSIZE_TAIL = sideStubExt / 2
            OUTPUT_EDGES = TRUE
          } TEMP = eol_ext_tip
	 
          EXTERNAL eol_ext_tip {
            COMMENT = "$layer_name specEoLSpc: stub2Stubspacing= stub2StubSpacing um (mode = 1)"
            SPACING < stub2StubSpacing
            SET_CORNERS_TO_SPACING = FALSE
            PARALLEL_POINT_PROJECTION = TRUE
          } (18 )
       } else {
          EXTERNAL end_of_line {
            COMMENT = "$layer_name specEoLSpc: stub2Stubspacing= stub2StubSpacing um (mode = 1)"
            SPACING < stub2StubSpacing
            SET_CORNERS_TO_SPACING = FALSE
            PARALLEL_POINT_PROJECTION = FALSE
          } (18 )
       }
    }
    if (stubRange > 0) {
       SIZE end_of_line {
         VSIZE_INSIDE = 0.001 
       } TEMP = eol_poly
       SELECT_EDGE eol_poly TOUCHING target_top { } TEMP=eol_edge
       EXTERNAL eol_edge target_top {
         COMMENT = "$layer_name specEoLSpc: spacing= stubSpacing um (mode = 1)"
         CONVEX_TO_CONVEX < stubSpacing
         CONVEX_TO_CONVEX [POINT_PROJECTION] < stubSpacing
         CONVEX_TO_EDGE < stubSpacing
         CONCAVE_TO_CONVEX < stubSpacing
         LONGEDGE > 0.001 
         LONGEDGE_TO_EDGE < stubSpacing
         SPACING <= 0
         SET_CORNERS_TO_SPACING = TRUE
         PARALLEL_POINT_PROJECTION = TRUE
       } (18 )
       SELECT all_side_edge INTERACT end_of_line { } TEMP = side_edge
       SIZE side_edge {
         VSIZE_HEAD = 0.001 
         VSIZE_TAIL = 0.001 
       } TEMP = side_edge_ext
       BOOLEAN side_edge_ext NOT side_edge { } TEMP = side_edge_ext
       SELECT side_edge_ext INTERACT end_of_line { } TEMP = side_edge_ext
       EXTERNAL side_edge_ext target_top {
         COMMENT = "$layer_name specEoLSpc: spacing= stubSpacing um (mode = 1)"
         SPACING < stubSpacing
         SET_CORNERS_TO_SPACING = FALSE
         PARALLEL_POINT_PROJECTION = FALSE
       } (18 )
    } else {
       if (stub2StubSpacing > 0) {
         VECTORIZE target_top {
            DIRECTED=TRUE
         } TEMP=target_edges
         BOOLEAN target_edges NOT end_of_line { } TEMP = target_edges
         EXTERNAL end_of_line target_edges {
            COMMENT = "$layer_name specEoLSpc: spacing= stubSpacing um (mode = 1)"
            SPACING < stubSpacing
            TOUCH=TRUE
            OVERLAP=TRUE
            SET_CORNERS_TO_SPACING=FALSE
            PARALLEL_POINT_PROJECTION=FALSE
         } (18 )
       } else {
         if (sideStubExt > 0) {
            SIZE end_of_line {
               VSIZE_HEAD = sideStubExt
               VSIZE_TAIL = sideStubExt
               OUTPUT_EDGES = TRUE
            } TEMP = end_of_line
            EXTERNAL end_of_line target_top {
               COMMENT = "$layer_name specEoLSpc: spacing= stubSpacing ,crnKeepOut= sideStubExt um (mode = 1)"
               SPACING < stubSpacing
               TOUCH=TRUE
               OVERLAP=TRUE
               SET_CORNERS_TO_SPACING=FALSE
               PARALLEL_POINT_PROJECTION=FALSE
            } (18 )
         } else {
            EXTERNAL end_of_line target_top {
               COMMENT = "$layer_name specEoLSpc: spacing= stubSpacing um (mode = 1)"
               SPACING < stubSpacing
               TOUCH=TRUE
               OVERLAP=TRUE
               SET_CORNERS_TO_SPACING=FALSE
               PARALLEL_POINT_PROJECTION=FALSE
            } (18 )
         }
       }
    }
  } else { /* stubMode == 2,3,4 */
    /* stubMode 2 eol classify and reduction */
    if (stubMode !=3 && sideStubExt > 0) {
      if (stubMode == 4) {
        SIZE end_of_line {
           VSIZE_HEAD = sideStubExt
           VSIZE_TAIL = sideStubExt
           OUTPUT_EDGES = TRUE
        } TEMP = eol_ext
        EXTERNAL eol_ext target_top {
           SPACING < stubSpacing
           SET_CORNERS_TO_SPACING=FALSE
           PARALLEL_POINT_PROJECTION=FALSE
           OUTPUT_EDGES = TRUE
        } TEMP=err_edge
        SELECT eol_ext INTERACT err_edge { } TEMP=eol_ext
      } else {
        EXTERNAL end_of_line target_top {
           SPACING < stubSpacing
           SET_CORNERS_TO_SPACING=FALSE
           PARALLEL_POINT_PROJECTION=FALSE
           OUTPUT_EDGES = TRUE
        } TEMP=err_edge
        SELECT end_of_line INTERACT err_edge { } TEMP=eol_body
        SIZE end_of_line {
           VSIZE_HEAD = sideStubExt
           VSIZE_TAIL = sideStubExt
           OUTPUT_EDGES = TRUE
        } TEMP = eol_ext
        BOOLEAN eol_ext NOT end_of_line {} TEMP=eol_ext
        EXTERNAL eol_ext target_top {
           SPACING < stubSpacing
           SET_CORNERS_TO_SPACING=FALSE
           PARALLEL_POINT_PROJECTION=FALSE
           OUTPUT_EDGES = TRUE
        } TEMP=err_edge
        SELECT eol_ext INTERACT err_edge { } TEMP=eol_ext
        BOOLEAN eol_body OR eol_ext { } TEMP=eol_ext
      } 
    } else {
      COPY end_of_line { } TEMP=eol_ext
    }
    SELECT side_edge INTERACT eol_ext { } TEMP=side_edge
    SIZE eol_ext {
       VSIZE_INSIDE = sideStubThreshold 
       VSIZE_OUTSIDE = sideStubExt
    } TEMP = eol_range
    if (sideStubExt > 0) {
       SIZE side_edge {
          VSIZE_HEAD = sideStubExt
          VSIZE_TAIL = sideStubExt
          OUTPUT_EDGES = TRUE
       } TEMP = check_edge
    } else {
       COPY side_edge { } TEMP = check_edge
    }
    BOOLEAN check_edge AND eol_range { } TEMP=check_edge
    EXTERNAL check_edge target_top {
       SPACING < temporary_1
       SET_CORNERS_TO_SPACING = FALSE
       SHADOW_OTHER_LAYER = TRUE
       PARALLEL_POINT_PROJECTION = FALSE
       OUTPUT_EDGES = TRUE
    } TEMP=err_edge
    if (0 && stubMode!=4) { /* Temporarily do not check mode 2,3 side edge length */
       LENGTH side_edge { SPACING < stubSpacing- 0.0005 *2 } TEMP=err_edge_1
       BOOLEAN err_edge OR err_edge_1 { } TEMP=err_edge
    }
    SELECT check_edge INTERACT err_edge { } TEMP=side_edge
    if (stubMode!=3) {
       SELECT eol_ext INTERACT side_edge {} TEMP=err_eol
       EXTERNAL err_eol target_top {
          COMMENT = "$layer_name specEoLSpc: spacing= stubSpacing ,crnKeepOut= sideStubExt um (mode = stubMode )"
          SPACING < temporary_1
          PARALLEL_POINT_PROJECTION=FALSE
          SET_CORNERS_TO_SPACING=FALSE
       } (18 )
    } else { /* stubMode == 3 */
       SELECT eol_ext INTERACT side_edge { RANGE = [2, 2] } TEMP=err_eol
       EXTERNAL err_eol target_top {
          COMMENT = "$layer_name specEoLSpc: spacing= stubSpacing um (mode = 3)"
          SPACING < temporary_1
          PARALLEL_POINT_PROJECTION=FALSE
          SET_CORNERS_TO_SPACING=FALSE
       } (18 )
    }
  }
} /* stubMode > 0, not aligned */
/* Avoid empty optimization result parsing error */
if (addEmptyMetalCheck) {
   BOOLEAN empty OR empty {
      COMMENT = "$layer_name Empty: Dummy Output"
   } (18 )
   SET addEmptyMetalCheck=0;
}
/* reset variables */


 
SET minWidth = 0;
SET maxWidth = 0;
SET minArea = 0;
SET minEnclosedArea = 0;
SET minSpacing = 0;
SET sameNetMinSpacing = 0;
SET maxNumMinEdge = 0;
SET maxTotalMinEdgeLength = 0;
SET minEdgeLength = 0;
SET minEdgeLength2 = 0;
SET minEdgeLength3 = 0;
SET stubRange = 0;
SET stubSpacing = 0;
SET stub2StubSpacing = 0;
SET sideStubExt = 0;
SET sideStubThreshold = 0;
SET stubThreshold = 0;
SET fatPolyContactRule = 0;
SET fatWireThreshold = 0;
SET fatThinMinSpacing = 0;
SET fatFatMinSpacing = 0;
SET fatTblDimension = 0;
@ 378 "adrc/adrc.ev" 2









/*metal 9*/
SET layer_name = "Met9";










SET minWidth = 0.45;
SET maxWidth = 1000;
SET minArea = 0.6;
SET minSpacing = 0.45;
SET stub2StubSpacing = 0;

SET fatTblDimension = 0;
@ 1 "adrc/adrc_check_metal.ev" 1
/* Data Preparation */
if (fatTblDimension > 1 || fatWireThreshold > 0 || maxWidth > 0) {
  if (ignoreBlockage) {
      /* Let the real blockage be treated as thin */
      BOOLEAN metal9  NOT metal9_rbkg  {} TEMP=fat_candidate
  } else {
      COPY metal9  {} TEMP=fat_candidate
  }
  COPY fat_candidate {} TEMP=fat_target
}
/*Check width*/
if (minWidth > 0) {
    INTERNAL metal9  { 
        COMMENT = "$layer_name MinWidth  : minimum width = minWidth um" 
        SPACING < minWidth
        POINT_TOUCH = FALSE
    } (19 )
}
 
if (maxWidth > 0) {
    SIZE  fat_candidate {
        COMMENT = "$layer_name MaxWidth  : maximum width = maxWidth um"
 	UNDER_OVER = maxWidth / 2 
    } (19 ) 
}
 
/*Check area*/
if (minArea > 0) {
    AREA metal9  { 
	COMMENT = "$layer_name MinArea   : minimum area = minArea um*um"
	RANGE = [0.0005 * 0.0005 , minArea - 0.0005 * 0.0005 ]
    } (19 )
}
/* check min length of bounding box on polygon */
if (minLength > 0) {
  if (minLengthMode == 1) {
    INTERNAL metal9  {
        SPACING < minLength
        VERTICAL_ONLY = TRUE
        SET_CORNERS_TO_SPACING = FALSE
    } TEMP = ver_short
    BOOLEAN metal9  NOT ver_short { } TEMP = ver_long
    INTERNAL metal9  {
        SPACING < minLength
        HORIZONTAL_ONLY = TRUE
        SET_CORNERS_TO_SPACING = FALSE
    } TEMP = hor_short
    BOOLEAN metal9  NOT hor_short { } TEMP = hor_long
    SELECT CUT_LAYER1 INSIDE ver_long { } TEMP = good_cut
    BOOLEAN CUT_LAYER1 NOT good_cut { } TEMP = fail_cut_1
    SELECT fail_cut_1 INSIDE hor_long { } TEMP = good_cut
    BOOLEAN fail_cut_1 NOT good_cut { } TEMP = fail_cut_1
    SELECT CUT_LAYER2 INSIDE ver_long { } TEMP = good_cut
    BOOLEAN CUT_LAYER2 NOT good_cut { } TEMP = fail_cut_2
    SELECT fail_cut_2 INSIDE hor_long { } TEMP = good_cut
    BOOLEAN fail_cut_2 NOT good_cut { } TEMP = fail_cut_2
    BOOLEAN fail_cut_1 OR fail_cut_2 { } TEMP = fail_cut
    BOOLEAN hor_short NOT ver_long { } TEMP = hor_short
    BOOLEAN ver_short NOT hor_long { } TEMP = ver_short
    SELECT ver_short INTERACT fail_cut { } TEMP = ver_fail
    SELECT hor_short INTERACT fail_cut { } TEMP = hor_fail
    BOOLEAN ver_fail OR hor_fail { } TEMP = all_fail
    INTERNAL all_fail {
        COMMENT = "$layer_name MinLength : minimum length = minLength um"
        SPACING < minLength
        VERTICAL_ONLY = TRUE
        SET_CORNERS_TO_SPACING = FALSE
    } (19 )
  } else {
    POLYGON_FEATURES metal9  {
      COMMENT = "$layer_name MinLength : minimum length = minLength um"
      EQUATIONS {
        vnum = EV_VNUM_IN;
        if ( vnum > 0) {
	  bdLeft = EV_VXCOORD_IN[0];
	  bdRight = EV_VXCOORD_IN[0];
	  bdBottom = EV_VYCOORD_IN[0];
	  bdTop = EV_VYCOORD_IN[0];
          FOR (i = 1; i < vnum; i++) {
	    if (bdLeft > EV_VXCOORD_IN[i]) bdLeft = EV_VXCOORD_IN[i];
            else if (bdRight < EV_VXCOORD_IN[i]) bdRight = EV_VXCOORD_IN[i];
	    if (bdBottom > EV_VYCOORD_IN[i]) bdBottom = EV_VYCOORD_IN[i];
            else if (bdTop < EV_VYCOORD_IN[i]) bdTop = EV_VYCOORD_IN[i];
          }
	  if ( (bdRight - bdLeft) < minLength &&
	       (bdTop - bdBottom) < minLength) {
	    FOR (i = 0; i < vnum; i++) {
              EV_VXCOORD_OUT[i] = EV_VXCOORD_IN[i];
	      EV_VYCOORD_OUT[i] = EV_VYCOORD_IN[i];
            }
	    EV_VNUM_OUT = vnum;
	    EV_SAVE_POLYGON();
          }
        }
      }
    } (19 ) 
  }
  SET minLength = 0;
}
/* check max length of bounding box on polygon */
if (maxLength > 0) {
  POLYGON_FEATURES metal9  {
    COMMENT = "$layer_name MaxLength : maximum length = maxLength um"
    EQUATIONS {
      vnum = EV_VNUM_IN;
      if ( vnum > 0) {
	bdLeft = EV_VXCOORD_IN[0];
	bdRight = EV_VXCOORD_IN[0];
	bdBottom = EV_VYCOORD_IN[0];
	bdTop = EV_VYCOORD_IN[0];
        FOR (i = 1; i < vnum; i++) {
	  if (bdLeft > EV_VXCOORD_IN[i]) bdLeft = EV_VXCOORD_IN[i];
          else if (bdRight < EV_VXCOORD_IN[i]) bdRight = EV_VXCOORD_IN[i];
	  if (bdBottom > EV_VYCOORD_IN[i]) bdBottom = EV_VYCOORD_IN[i];
          else if (bdTop < EV_VYCOORD_IN[i]) bdTop = EV_VYCOORD_IN[i];
        }
	if ( (bdRight - bdLeft + bdTop - bdBottom) > maxLength ) {
          EV_VXCOORD_OUT[0] = bdLeft;
	  EV_VYCOORD_OUT[0] = bdBottom;
          EV_VXCOORD_OUT[1] = bdLeft;
	  EV_VYCOORD_OUT[1] = bdTop;
          EV_VXCOORD_OUT[2] = bdRight;
	  EV_VYCOORD_OUT[2] = bdTop;
          EV_VXCOORD_OUT[3] = bdRight;
	  EV_VYCOORD_OUT[3] = bdBottom;
          EV_VXCOORD_OUT[4] = bdLeft;
	  EV_VYCOORD_OUT[4] = bdBottom;
	  EV_VNUM_OUT = 5;
	  EV_SAVE_POLYGON();
        }
      }
    }
  } (19 ) 
  SET maxLength = 0;
}
 
/*Check enclosed area*/
if (minEnclosedArea > 0) {
    SELECT metal9  INSIDE_HOLE {
        INNER_HOLE_ONLY
    } TEMP = holes
    BOOLEAN holes NOT metal9  { } TEMP = holes
 
    AREA holes {
        COMMENT = "$layer_name EnclsArea : minimum enclosed area = minEnclosedArea um*um"
        RANGE = [0.0005 * 0.0005 , minEnclosedArea - 0.0005 * 0.0005 ]
    } (19 )
    /* check min length of bounding box on polygon */
    if (minEnclosedWidth > 0) {
      POLYGON_FEATURES holes {
        COMMENT = "$layer_name EnclsWidth: minimum enclosed Width = minEnclosedWidth um"
        EQUATIONS {
          vnum = EV_VNUM_IN;
          if ( vnum > 0) {
            bdLeft = EV_VXCOORD_IN[0];
            bdRight = EV_VXCOORD_IN[0];
            bdBottom = EV_VYCOORD_IN[0];
            bdTop = EV_VYCOORD_IN[0];
            FOR (i = 1; i < vnum; i++) {
              if (bdLeft > EV_VXCOORD_IN[i]) bdLeft = EV_VXCOORD_IN[i];
              else if (bdRight < EV_VXCOORD_IN[i]) bdRight = EV_VXCOORD_IN[i];
              if (bdBottom > EV_VYCOORD_IN[i]) bdBottom = EV_VYCOORD_IN[i];
              else if (bdTop < EV_VYCOORD_IN[i]) bdTop = EV_VYCOORD_IN[i];
            }
            if ( (bdRight - bdLeft) < minEnclosedWidth &&
                 (bdTop - bdBottom) < minEnclosedWidth) {
              FOR (i = 0; i < vnum; i++) {
                EV_VXCOORD_OUT[i] = EV_VXCOORD_IN[i];
                EV_VYCOORD_OUT[i] = EV_VYCOORD_IN[i];
              }
              EV_VNUM_OUT = vnum;
              EV_SAVE_POLYGON();
            }
          }
        }
      } (19 ) 
    }
}
 
/*check special notch rule*/
if ((minEdgeLength2 > 0.0005  && minEdgeLength3 > 0.0005 ) || minEdgeMode==2) {
  if (minEdgeMode==2) {
    SET minEdgeLength3 = minEdgeLength ;
  }
  NOTCH metal9  {
     SPACING < minEdgeLength3
     SET_CORNERS_TO_SPACING=FALSE
     PARALLEL = TRUE
     OUTPUT_EDGES = TRUE
  } TEMP = notch_vectors
  SELECT_VECTOR notch_vectors {
     LENGTH_RANGE = [0.0005 , minEdgeLength2 - 0.0005 ]
  } TEMP = short_edges
  EXTERNAL short_edges metal9  {
     SPACING < minEdgeLength3
     SET_CORNERS_TO_SPACING=FALSE
     PARALLEL = TRUE
  } TEMP = notch_err
  /* Choose the real U-shaped notch */
  SIZE notch_err { OVERSIZE = 0.001 *10 } TEMP = neighbors 
  BOOLEAN neighbors AND metal9  { } TEMP = neighbors
  VERTEX neighbors { 
     CONCAVE = TRUE
     CONVEX = TRUE
     SIZE = 0.001 
  } TEMP = corners
  SELECT_EDGE neighbors INTERACT notch_err { } TEMP = target_edges
  BOOLEAN target_edges NOT corners { } TEMP = target_edges
  VERTEX neighbors { 
     CONCAVE = TRUE
     SIZE = 2* 0.001 
  } TEMP = corners
  SELECT target_edges INTERACT corners { RANGE = [2, 2] } TEMP=target_edges
  SELECT notch_err INTERACT target_edges {
     COMMENT = "$layer_name SpeclNotch: sameNetSp = minEdgeLength3 um (sideLen minEdgeLength2 um)" 
  } (19 )
}
/*check consecutive short edges*/
if (minEdgeLength > 0.0005  && minEdgeMode != 2) { 
  INTERNAL metal9_top  {
     SEGMENT < minEdgeLength
     FLAG_ACUTE_ANGLE = FALSE
     FLAG_ACUTE_EDGE = FALSE
     OUTPUT_EDGES = TRUE
  } TEMP = short_edges
  if ((minEdgeMode == 0 && maxTotalMinEdgeLength>0) || maxNumMinEdge > 0) {
    SET temporary_1 = 0.001 *2;
    SET temporary_2 = 2*temporary_1+ 0.0005 ;
    SELECT metal9_top  INTERACT short_edges { } TEMP = target_top
    CLASSIFY_EDGES target_top {
       LENGTH = temporary_1
       DMIN   = temporary_2
       INSIDE_CORNER  TEMP = inside_corner_edges
       OUTSIDE_CORNER TEMP = outside_corner_edges
       REMAINDER      TEMP = remainder_edges
    }
    if (minEdgeMode == 0 && (maxNumMinEdge>0 || maxTotalMinEdgeLength > 0)) {
       SELECT short_edges ENCLOSING inside_corner_edges { } TEMP = short_edges
    }
  }
  if (maxTotalMinEdgeLength > 0) {
    LENGTH short_edges {
       RANGE = [maxTotalMinEdgeLength + 0.0005 , 9999999999 ]
    } TEMP = max_length_err
    /* Work around: translate polygons into dimensional check output */
    SIZE max_length_err { OVERSIZE = 2* 0.001  } TEMP = max_length_err
    INTERNAL max_length_err {
       SPACING < 3* 0.001 
       SET_CORNERS_TO_SPACING=FALSE
       COMMENT = "$layer_name MinEdgeLen: maximum total length ( minEdgeLength um)= maxTotalMinEdgeLength um"
    } (19 )
  }
  if (maxTotalMinEdgeLength == 0 || maxNumMinEdge > 0) {
    if (maxNumMinEdge==0)  {
       COPY short_edges {} TEMP=max_edge_err
    } else {
       SIZE short_edges {
         VSIZE_HEAD = - 0.001 
        VSIZE_TAIL = - 0.001 
       } TEMP = short_edges
       SIZE short_edges {
          OVERSIZE = 5* 0.001 
          SIZE_ENDPOINTS = FALSE
       } TEMP = short_contours
       SELECT short_contours ENCLOSING remainder_edges {
          RANGE = [maxNumMinEdge + 1, 9999999999 ]
       } TEMP = short_contours
       SELECT short_edges INSIDE short_contours { } TEMP=max_edge_err
    }
    /* Work around: translate polygons into dimensional check output */
    SIZE max_edge_err { OVERSIZE = 2* 0.001  } TEMP = max_edge_error
    INTERNAL max_edge_error {
       SPACING < 3* 0.001 
       SET_CORNERS_TO_SPACING=FALSE
       COMMENT = "$layer_name MinEdgeLen: maximum number of consecutive short edges ( minEdgeLength um)= maxNumMinEdge"
    } (19 ) 
  }
}
 
/*check basic spacing*/
if (sameNetMinSpacing > 0 && sameNetMinSpacing != minSpacing) {
  if (sameNetMinSpacing > minSpacing) {
    /* Special condition for U-shaped Metal spacing rule */
    NOTCH metal9_pin  {
        SPACING < sameNetMinSpacing
        BOX_CORNER = FALSE 
        SET_CORNERS_TO_SPACING=FALSE
        NON_PARALLEL = TRUE
        OUTPUT_EDGES = TRUE
    } TEMP = errs_to_be_waived
    NOTCH metal9_top  {
	SPACING < sameNetMinSpacing
	BOX_CORNER = FALSE 
        SET_CORNERS_TO_SPACING=FALSE
	NON_PARALLEL = TRUE
        OUTPUT_EDGES = TRUE
    } TEMP = all_errs
    BOOLEAN all_errs NOT errs_to_be_waived { } TEMP=err_edge
    EXTERNAL err_edge metal9_top  {
	SPACING < sameNetMinSpacing
	BOX_CORNER = FALSE 
        SET_CORNERS_TO_SPACING=FALSE
	NON_PARALLEL = TRUE
    } TEMP = notch_err
    SIZE notch_err { OVERSIZE = 0.001 *10 } TEMP = neighbors
    BOOLEAN neighbors AND metal9_top  { } TEMP = neighbors
    VERTEX neighbors { 
       CONCAVE = TRUE
       CONVEX = TRUE
       SIZE = 0.001 
    } TEMP = corners
    SELECT_EDGE neighbors INTERACT notch_err { } TEMP = target_edges
    BOOLEAN target_edges AND notch_err { } TEMP = target_edges
    BOOLEAN target_edges NOT corners { } TEMP = target_edges
    VERTEX neighbors {
       CONCAVE = TRUE
       SIZE = 2* 0.001 
    } TEMP = corners
    SELECT target_edges INTERACT corners { RANGE = [2, 2] } TEMP = target_edges
    SELECT notch_err TOUCHING target_edges {
      COMMENT = "$layer_name U-ShpNotch: U-shape notch minimum spacing = sameNetMinSpacing um" 
    } (19 )
  } else {
    NOTCH metal9  {
        COMMENT = "$layer_name SameNetSpc: same-net minimum spacing = sameNetMinSpacing um" 
	SPACING < sameNetMinSpacing
	BOX_CORNER = FALSE 
	NON_PARALLEL = TRUE
    } (19 )
  }
  if (minSpacing > 0) {
    if (stubMode == 0 && stubSpacing > 0 && stubSpacing < minSpacing) {
	EXTERNAL metal9  {
	    COMMENT = "$layer_name Spacing   : minimum spacing = minSpacing um"
            LONGEDGE > stubThreshold + 0.0005 
	    LONGEDGE_TO_EDGE < minSpacing
	    SPACING <= 0
	    BOX_CORNER = FALSE 
	    NON_PARALLEL = TRUE
            POINT_TOUCH = TRUE
            CHECK_SAME_POLYGON = TRUE 
	} (19 )
    } else {
        EXTERNAL metal9  {
	    COMMENT = "$layer_name Spacing   : minimum spacing = minSpacing um" 
	    SPACING < minSpacing
	    BOX_CORNER = FALSE 
	    NON_PARALLEL = TRUE
            POINT_TOUCH = TRUE
	    CHECK_SAME_POLYGON = FALSE
        } (19 )
    }
  }
} else {
  if (minSpacing > 0) {
    if (stubMode == 0 && stubSpacing > 0 && stubSpacing < minSpacing) {
        EXTERNAL metal9  {
            COMMENT = "$layer_name Spacing   : minimum spacing = minSpacing um"
            LONGEDGE > stubThreshold + 0.0005  
            LONGEDGE_TO_EDGE < minSpacing
            SPACING <= 0 
            BOX_CORNER = FALSE 
            NON_PARALLEL = TRUE
            POINT_TOUCH = TRUE
            CHECK_SAME_POLYGON = TRUE 
        } (19 )
    } else {
        EXTERNAL metal9  {
	    COMMENT = "$layer_name Spacing   : minimum spacing = minSpacing um" 
            SPACING < minSpacing
	    BOX_CORNER = FALSE 
	    NON_PARALLEL = TRUE
	    POINT_TOUCH = TRUE
	    CHECK_SAME_POLYGON = TRUE 
        } (19 )
    }
  }
}
 
/*check dogbone */
if (sameNetMinSpacing > 0 && sameNetWidthThreshold) {
  NOTCH metal9  {
    SPACING < sameNetMinSpacing
    BOX_CORNER = FALSE 
    NON_PARALLEL = TRUE
  } TEMP = dog_bone
 
  if (!layer_empty(dog_bone)) {
    SIZE dog_bone {EDGESIZE = sameNetWidthThreshold} TEMP = dog_ext
    BOOLEAN dog_ext NOT dog_bone {} TEMP = dog_ext
    BOOLEAN dog_ext AND metal9  {} TEMP = dog_ext
    if (!layer_empty(dog_ext)) {
      SELECT dog_ext EDGE_TOUCH dog_bone { OUTSIDE RANGE = [1, 9999999999 ] } TEMP = dog_ext
      NOTCH metal9  {
        SPACING < sameNetMinSpacing
        BOX_CORNER = FALSE 
        NON_PARALLEL = TRUE
	OUTPUT_EDGES = TRUE
      } TEMP = dog_bone
      SELECT dog_ext OUTSIDE dog_bone {} TEMP = dog_ext
      INTERNAL dog_ext {
	COMMENT = "$layer_name dogBone   : notch spacing = sameNetMinSpacing um width sameNetWidthThreshold um" 
	SPACING < sameNetWidthThreshold
      } (19 )
    }
  }
}
/*check basic fat spacing*/
if (fatWireThreshold > 0 && fatTblDimension == 0) {
    SIZE fat_candidate { UNDER_OVER = fatWireThreshold / 2.0 - 0.0005  } TEMP = m_fat
    BOOLEAN m_fat AND metal9  {  } TEMP = m_fat
    BOOLEAN metal9  NOT m_fat {  } TEMP = m_thin
    if (ignoreBlockage == 0) {
        /* the blockages on the metal_blockage layer are treated as thin blockages */
        BOOLEAN m_thin OR metal9_blockage  {  } TEMP = m_thin
    }
 
    if (fatFatMinSpacing > 0) {
	EXTERNAL m_fat {
	    COMMENT = "$layer_name FatWireSpc: fat & fat ( fatWireThreshold um) minimum spacing = fatFatMinSpacing um"
	    SPACING < fatFatMinSpacing
	    BOX_CORNER = FALSE 
	    NON_PARALLEL = TRUE
	    POINT_TOUCH = FALSE
	    CHECK_SAME_POLYGON = TRUE 
       } (19 )
    }
 
    if (fatThinMinSpacing > 0) {
	EXTERNAL m_fat m_thin {
	    COMMENT = "$layer_name FatWireSpc: fat & thin ( fatWireThreshold um) minimum spacing fatThinMinSpacing um"
	    SPACING < fatThinMinSpacing
 	    BOX_CORNER = FALSE 
	    NON_PARALLEL = TRUE
	    POINT_TOUCH = FALSE
        } (19 )
    }
}
 
/*check thin blockage spacing*/
if (minSpacing > 0 && ignoreBlockage == 0) {
    if (!layer_empty (metal9_blockage )) {
	EXTERNAL metal9_blockage  metal9  {
	    COMMENT = "$layer_name Spacing   : metal & thin blockage minimum spacing = minSpacing um"
	    SPACING < minSpacing
	    BOX_CORNER = FALSE 
	    NON_PARALLEL = TRUE
	    POINT_TOUCH = TRUE
            TOUCH = TRUE
        } (19 )
    }
}
/*check blockage overlap*/
/*check shorts between top_level routing and fram_blockages*/
if (minSpacing>0 || checkCrossHierShort>0) {
   if (ignoreBlockage == 0) {
      BOOLEAN metal9_blockage  or metal9_rbkg  {} TEMP=all_blockage
   } else {
      COPY metal9_rbkg  {} TEMP=all_blockage
   }
   BOOLEAN all_blockage AND metal9_top  {} TEMP = overlap_shape1
   EXTERNAL all_blockage metal9_top  {
      SPACING <= 0
      TOUCH = TRUE
   } TEMP = overlap_shape2
   if (checkCrossHierShort>0) {
      BOOLEAN overlap_shape1 OR overlap_shape2 {
         COMMENT = "$layer_name Short Cross Hierarchy"
      } (19 )
   } else {
      BOOLEAN overlap_shape1 OR overlap_shape2 {
         COMMENT = "$layer_name Overlap   : metal & blockage overlap"
      } (19 )
   }
}
 
if (fatPolyContactRule > 0) {
  /* Fat Poly Contact Rule: not new fat wire formed */
  if (readCellView > 0) {
     SIZE metal1 { UNDER_OVER = fatPolyContactRule / 2.0 - 0.0005  } TEMP = fat
     BOOLEAN fat AND metal1 {  } TEMP = fat 
  } else {
     SIZE metal1_top { UNDER_OVER = fatPolyContactRule / 2.0 - 0.0005  } TEMP = fat
     BOOLEAN fat AND metal1_top {  } TEMP = fat 
  }
  SIZE metal1_pin { UNDER_OVER = fatPolyContactRule / 2.0 - 0.0005  } TEMP = fat_pin
  BOOLEAN fat_pin AND metal1_pin {  } TEMP = fat_pin
  BOOLEAN fat NOT fat_pin {
    COMMENT = "$layer_name FatPolyContactRule: fatPolyContactRule um" 
  } (19 )
}
/* Special End-of-Line Spacing Rule */
if (stubMode == 0 && stubSpacing > 0 && stubSpacing < minSpacing) {
  EXTERNAL metal9  {
     COMMENT = "$layer_name specEoLSpc: spacing= stubSpacing um (mode = 0)"
     LONGEDGE > stubThreshold + 0.0005 
     LONGEDGE_TO_EDGE <= 0 
     SPACING < stubSpacing 
     SET_CORNERS_TO_SPACING = FALSE
     PARALLEL_POINT_PROJECTION = FALSE
  } (19 )
} else if (stubMode > 0 && stubSpacing > minSpacing) {
  if (stubMode == 4) {
     INTERNAL metal9  {
        SEGMENT[90,90] < stubThreshold
        OUTPUT_EDGES = TRUE
     } TEMP = end_of_line
  } else {
     INTERNAL metal9  {
        SEGMENT[90,90] <= stubThreshold
        OUTPUT_EDGES = TRUE
     } TEMP = end_of_line
  }
  /* Quick filter to reduce the size of possible end of line */
  if (sideStubExt > 0) {
    SIZE end_of_line {
       VSIZE_HEAD = sideStubExt
       VSIZE_TAIL = sideStubExt
       OUTPUT_EDGES = TRUE
    } TEMP = eol_ext
  } else {
    COPY end_of_line { } TEMP=eol_ext
  }
  if (stub2StubSpacing > stubSpacing) {
     SET temporary_1 = stub2StubSpacing;
  } else {
     SET temporary_1 = stubSpacing; 
  }
  EXTERNAL eol_ext metal9  {
     SPACING < temporary_1
     TOUCH = TRUE
     OVERLAP = TRUE 
     SET_CORNERS_TO_SPACING = FALSE
     PARALLEL_POINT_PROJECTION = FALSE
     OUTPUT_EDGES = TRUE
  } TEMP=err_edge
  SELECT eol_ext INTERACT err_edge { } TEMP=eol_ext
  SELECT end_of_line INTERACT eol_ext { } TEMP=end_of_line 
  /* Reduce the size of METAL_LAYER */
  if (stubMode==3) {
     SIZE end_of_line {
        VSIZE_HEAD = stubSpacing 
        VSIZE_TAIL = stubSpacing 
        VSIZE_INSIDE = sideStubThreshold
        VSIZE_OUTSIDE = stubSpacing
     } TEMP = eol_filter 
  } else {
     if (stubMode == 1 && stubRange > 0) {
        SIZE end_of_line {
           VSIZE_HEAD = stubSpacing- 0.0005 
           VSIZE_TAIL = stubSpacing- 0.0005 
           VSIZE_OUTSIDE = stubSpacing- 0.0005 
        } TEMP = eol_filter
     } else {
        SIZE end_of_line {
           VSIZE_HEAD = stubSpacing- 0.0005 
           VSIZE_TAIL = stubSpacing- 0.0005 
           VSIZE_INSIDE = sideStubThreshold- 0.0005 
           VSIZE_OUTSIDE = stubSpacing- 0.0005 
        } TEMP = eol_filter
     }
  }
  SELECT metal9  INTERACT eol_filter { } TEMP=target_top
  /* Get the side edges and the whole eol of line set */
  SELECT_EDGE target_top INTERACT end_of_line { 
    POINT_TOUCH = TRUE
  } TEMP = eol_set
  VERTEX target_top { 
     CONCAVE = TRUE 
     CONVEX = TRUE
     SIZE = 0.001 
  } TEMP = corners
  SELECT corners OUTSIDE end_of_line {} TEMP =corners 
  BOOLEAN eol_set NOT corners { } TEMP=eol_set
  BOOLEAN eol_set NOT end_of_line { } TEMP=side_edge
  /* find out the real end of line */
  if (stubRange > 0) {
     if (stubMode == 1) {
         COPY side_edge { } TEMP = all_side_edge
         LENGTH side_edge { SPACING <= stubRange- 0.0005  } TEMP=side_edge
     } else {
         LENGTH side_edge { SPACING < stubRange- 0.001  } TEMP=eol_filter
         BOOLEAN side_edge NOT eol_filter { } TEMP=side_edge
     }
     SELECT end_of_line INTERACT side_edge { RANGE = [1,2] } TEMP = end_of_line
  } 
  if (stubMode == 1) {
    if (stub2StubSpacing > 0) {
       if (sideStubExt < 0) {
          SIZE end_of_line {
            VSIZE_HEAD = sideStubExt / 2
            VSIZE_TAIL = sideStubExt / 2
            OUTPUT_EDGES = TRUE
          } TEMP = eol_ext_tip
	 
          EXTERNAL eol_ext_tip {
            COMMENT = "$layer_name specEoLSpc: stub2Stubspacing= stub2StubSpacing um (mode = 1)"
            SPACING < stub2StubSpacing
            SET_CORNERS_TO_SPACING = FALSE
            PARALLEL_POINT_PROJECTION = TRUE
          } (19 )
       } else {
          EXTERNAL end_of_line {
            COMMENT = "$layer_name specEoLSpc: stub2Stubspacing= stub2StubSpacing um (mode = 1)"
            SPACING < stub2StubSpacing
            SET_CORNERS_TO_SPACING = FALSE
            PARALLEL_POINT_PROJECTION = FALSE
          } (19 )
       }
    }
    if (stubRange > 0) {
       SIZE end_of_line {
         VSIZE_INSIDE = 0.001 
       } TEMP = eol_poly
       SELECT_EDGE eol_poly TOUCHING target_top { } TEMP=eol_edge
       EXTERNAL eol_edge target_top {
         COMMENT = "$layer_name specEoLSpc: spacing= stubSpacing um (mode = 1)"
         CONVEX_TO_CONVEX < stubSpacing
         CONVEX_TO_CONVEX [POINT_PROJECTION] < stubSpacing
         CONVEX_TO_EDGE < stubSpacing
         CONCAVE_TO_CONVEX < stubSpacing
         LONGEDGE > 0.001 
         LONGEDGE_TO_EDGE < stubSpacing
         SPACING <= 0
         SET_CORNERS_TO_SPACING = TRUE
         PARALLEL_POINT_PROJECTION = TRUE
       } (19 )
       SELECT all_side_edge INTERACT end_of_line { } TEMP = side_edge
       SIZE side_edge {
         VSIZE_HEAD = 0.001 
         VSIZE_TAIL = 0.001 
       } TEMP = side_edge_ext
       BOOLEAN side_edge_ext NOT side_edge { } TEMP = side_edge_ext
       SELECT side_edge_ext INTERACT end_of_line { } TEMP = side_edge_ext
       EXTERNAL side_edge_ext target_top {
         COMMENT = "$layer_name specEoLSpc: spacing= stubSpacing um (mode = 1)"
         SPACING < stubSpacing
         SET_CORNERS_TO_SPACING = FALSE
         PARALLEL_POINT_PROJECTION = FALSE
       } (19 )
    } else {
       if (stub2StubSpacing > 0) {
         VECTORIZE target_top {
            DIRECTED=TRUE
         } TEMP=target_edges
         BOOLEAN target_edges NOT end_of_line { } TEMP = target_edges
         EXTERNAL end_of_line target_edges {
            COMMENT = "$layer_name specEoLSpc: spacing= stubSpacing um (mode = 1)"
            SPACING < stubSpacing
            TOUCH=TRUE
            OVERLAP=TRUE
            SET_CORNERS_TO_SPACING=FALSE
            PARALLEL_POINT_PROJECTION=FALSE
         } (19 )
       } else {
         if (sideStubExt > 0) {
            SIZE end_of_line {
               VSIZE_HEAD = sideStubExt
               VSIZE_TAIL = sideStubExt
               OUTPUT_EDGES = TRUE
            } TEMP = end_of_line
            EXTERNAL end_of_line target_top {
               COMMENT = "$layer_name specEoLSpc: spacing= stubSpacing ,crnKeepOut= sideStubExt um (mode = 1)"
               SPACING < stubSpacing
               TOUCH=TRUE
               OVERLAP=TRUE
               SET_CORNERS_TO_SPACING=FALSE
               PARALLEL_POINT_PROJECTION=FALSE
            } (19 )
         } else {
            EXTERNAL end_of_line target_top {
               COMMENT = "$layer_name specEoLSpc: spacing= stubSpacing um (mode = 1)"
               SPACING < stubSpacing
               TOUCH=TRUE
               OVERLAP=TRUE
               SET_CORNERS_TO_SPACING=FALSE
               PARALLEL_POINT_PROJECTION=FALSE
            } (19 )
         }
       }
    }
  } else { /* stubMode == 2,3,4 */
    /* stubMode 2 eol classify and reduction */
    if (stubMode !=3 && sideStubExt > 0) {
      if (stubMode == 4) {
        SIZE end_of_line {
           VSIZE_HEAD = sideStubExt
           VSIZE_TAIL = sideStubExt
           OUTPUT_EDGES = TRUE
        } TEMP = eol_ext
        EXTERNAL eol_ext target_top {
           SPACING < stubSpacing
           SET_CORNERS_TO_SPACING=FALSE
           PARALLEL_POINT_PROJECTION=FALSE
           OUTPUT_EDGES = TRUE
        } TEMP=err_edge
        SELECT eol_ext INTERACT err_edge { } TEMP=eol_ext
      } else {
        EXTERNAL end_of_line target_top {
           SPACING < stubSpacing
           SET_CORNERS_TO_SPACING=FALSE
           PARALLEL_POINT_PROJECTION=FALSE
           OUTPUT_EDGES = TRUE
        } TEMP=err_edge
        SELECT end_of_line INTERACT err_edge { } TEMP=eol_body
        SIZE end_of_line {
           VSIZE_HEAD = sideStubExt
           VSIZE_TAIL = sideStubExt
           OUTPUT_EDGES = TRUE
        } TEMP = eol_ext
        BOOLEAN eol_ext NOT end_of_line {} TEMP=eol_ext
        EXTERNAL eol_ext target_top {
           SPACING < stubSpacing
           SET_CORNERS_TO_SPACING=FALSE
           PARALLEL_POINT_PROJECTION=FALSE
           OUTPUT_EDGES = TRUE
        } TEMP=err_edge
        SELECT eol_ext INTERACT err_edge { } TEMP=eol_ext
        BOOLEAN eol_body OR eol_ext { } TEMP=eol_ext
      } 
    } else {
      COPY end_of_line { } TEMP=eol_ext
    }
    SELECT side_edge INTERACT eol_ext { } TEMP=side_edge
    SIZE eol_ext {
       VSIZE_INSIDE = sideStubThreshold 
       VSIZE_OUTSIDE = sideStubExt
    } TEMP = eol_range
    if (sideStubExt > 0) {
       SIZE side_edge {
          VSIZE_HEAD = sideStubExt
          VSIZE_TAIL = sideStubExt
          OUTPUT_EDGES = TRUE
       } TEMP = check_edge
    } else {
       COPY side_edge { } TEMP = check_edge
    }
    BOOLEAN check_edge AND eol_range { } TEMP=check_edge
    EXTERNAL check_edge target_top {
       SPACING < temporary_1
       SET_CORNERS_TO_SPACING = FALSE
       SHADOW_OTHER_LAYER = TRUE
       PARALLEL_POINT_PROJECTION = FALSE
       OUTPUT_EDGES = TRUE
    } TEMP=err_edge
    if (0 && stubMode!=4) { /* Temporarily do not check mode 2,3 side edge length */
       LENGTH side_edge { SPACING < stubSpacing- 0.0005 *2 } TEMP=err_edge_1
       BOOLEAN err_edge OR err_edge_1 { } TEMP=err_edge
    }
    SELECT check_edge INTERACT err_edge { } TEMP=side_edge
    if (stubMode!=3) {
       SELECT eol_ext INTERACT side_edge {} TEMP=err_eol
       EXTERNAL err_eol target_top {
          COMMENT = "$layer_name specEoLSpc: spacing= stubSpacing ,crnKeepOut= sideStubExt um (mode = stubMode )"
          SPACING < temporary_1
          PARALLEL_POINT_PROJECTION=FALSE
          SET_CORNERS_TO_SPACING=FALSE
       } (19 )
    } else { /* stubMode == 3 */
       SELECT eol_ext INTERACT side_edge { RANGE = [2, 2] } TEMP=err_eol
       EXTERNAL err_eol target_top {
          COMMENT = "$layer_name specEoLSpc: spacing= stubSpacing um (mode = 3)"
          SPACING < temporary_1
          PARALLEL_POINT_PROJECTION=FALSE
          SET_CORNERS_TO_SPACING=FALSE
       } (19 )
    }
  }
} /* stubMode > 0, not aligned */
/* Avoid empty optimization result parsing error */
if (addEmptyMetalCheck) {
   BOOLEAN empty OR empty {
      COMMENT = "$layer_name Empty: Dummy Output"
   } (19 )
   SET addEmptyMetalCheck=0;
}
/* reset variables */


 
SET minWidth = 0;
SET maxWidth = 0;
SET minArea = 0;
SET minEnclosedArea = 0;
SET minSpacing = 0;
SET sameNetMinSpacing = 0;
SET maxNumMinEdge = 0;
SET maxTotalMinEdgeLength = 0;
SET minEdgeLength = 0;
SET minEdgeLength2 = 0;
SET minEdgeLength3 = 0;
SET stubRange = 0;
SET stubSpacing = 0;
SET stub2StubSpacing = 0;
SET sideStubExt = 0;
SET sideStubThreshold = 0;
SET stubThreshold = 0;
SET fatPolyContactRule = 0;
SET fatWireThreshold = 0;
SET fatThinMinSpacing = 0;
SET fatFatMinSpacing = 0;
SET fatTblDimension = 0;
@ 406 "adrc/adrc.ev" 2









/*Via rules*/

SET ignoreContactCodeSpacing = 1;
/*via 1*/
SET layer_name = "Via1";












SET cornerSpacingMode = 0;
SET cut_minSpacing = 0.14;
SET cut_fatTblDimension = 0;
@ 1 "adrc/adrc_check_via.ev" 1
/* check size */
if (cut_size > 0) {
    INTERNAL via1  {  
        COMMENT = "$layer_name Size      : contact size = cut_size um" 
	DIMENSION = [cut_size , cut_size]
    } (21 )
}
if (cut_minSpacing > 0) {
   if (ignoreContactCodeSpacing) {
      COPY via1  { } TEMP= default_via1 
   } else {
      SIZE metal1  { UNDER_OVER = cut_fatContactThreshold1 } TEMP = m_fat1
      SIZE metal2  { UNDER_OVER = cut_fatContactThreshold2 } TEMP = m_fat2
      BOOLEAN m_fat1 OR m_fat2 {} TEMP=m_fat
      SELECT via1  OUTSIDE m_fat { } TEMP= default_via1 
   }
}
 
/*check basic spacing*/
if (cut_sameNetMinSpacing > 0 && cut_sameNetMinSpacing < cut_minSpacing) {
  CONNECT { default_via1  BY via1  }
  if (cut_cornerMinSpacing > 0) {
    if (cornerSpacingMode == 1) {
        /* Work around: CONVEX_TO_CONVEX [POINT_PROJECTION] has a bug */
        EXTERNAL default_via1  {
             SPACING <= 0
             CONVEX_TO_CONVEX [POINT_PROJECTION] < cut_cornerMinSpacing
             FLAG_DISCONNECTED = FALSE
             NON_PARALLEL = TRUE
             POINT_TOUCH = TRUE
             BOX_CORNER = FALSE
        } TEMP = sameNet_corner_err1
        EXTERNAL default_via1  {
             SPACING <= 0
             CONVEX_TO_CONVEX < cut_cornerMinSpacing
             FLAG_DISCONNECTED = FALSE
             NON_PARALLEL = TRUE
             POINT_TOUCH = TRUE
             BOX_CORNER = TRUE
        } TEMP = sameNet_corner_err2 
        BOOLEAN sameNet_corner_err1 OR sameNet_corner_err2 {
             COMMENT = "$layer_name SameNetSpc: corner to corner spacing = cut_cornerMinSpacing um "
        } (21 ) 
        EXTERNAL default_via1  {
             COMMENT = "$layer_name SameNetSpc: same-net minimum spacing = cut_sameNetMinSpacing um "
             SPACING < cut_sameNetMinSpacing
             FLAG_DISCONNECTED = FALSE
             SET_CORNERS_TO_SPACING = FALSE
             PARALLEL_POINT_PROJECTION = FALSE
             NON_PARALLEL = TRUE
             TOUCH = FALSE
             POINT_TOUCH = FALSE
        } (21 )
    } else {
        EXTERNAL default_via1  {
            COMMENT = "$layer_name SameNetSpc: same-net minimum spacing = cut_sameNetMinSpacing um (corner to corner spacing = cut_cornerMinSpacing um) "
            SPACING < cut_sameNetMinSpacing
            CONVEX_TO_CONVEX < cut_cornerMinSpacing
            FLAG_DISCONNECTED = FALSE
            NON_PARALLEL = TRUE
            POINT_TOUCH = TRUE
        } (21 )
    }
  } else {
    EXTERNAL default_via1  {
        COMMENT = "$layer_name SameNetSpc: same-net minimum spacing = cut_sameNetMinSpacing um"
        SPACING < cut_sameNetMinSpacing
	BOX_CORNER = FALSE 
        FLAG_DISCONNECTED = FALSE
	NON_PARALLEL = TRUE
	POINT_TOUCH = TRUE
    } (21 )
  }
  if (cut_cornerMinSpacing > 0) {
    if (cornerSpacingMode == 1) {
        /* Work around: CONVEX_TO_CONVEX [POINT_PROJECTION] has a bug */
        EXTERNAL default_via1  {
          SPACING <= 0
          CONVEX_TO_CONVEX [POINT_PROJECTION] < cut_cornerMinSpacing
          NON_PARALLEL = TRUE
          POINT_TOUCH = TRUE
          BOX_CORNER = FALSE
          NODAL = TRUE
        } TEMP = diffNet_corner_err1 
        EXTERNAL default_via1  {
          SPACING <= 0
          CONVEX_TO_CONVEX < cut_cornerMinSpacing
          NON_PARALLEL = TRUE
          POINT_TOUCH = TRUE
          BOX_CORNER = TRUE
          NODAL = TRUE
        } TEMP = diffNet_corner_err2 
        BOOLEAN diffNet_corner_err1 OR diffNet_corner_err2 {
          COMMENT = "$layer_name Spacing   : corner to corner spacing = cut_cornerMinSpacing um "
        } (21 )
        EXTERNAL default_via1  {
          COMMENT = "$layer_name Spacing   : minimum spacing = cut_minSpacing um"
          SPACING < cut_minSpacing
          SET_CORNERS_TO_SPACING = FALSE
          PARALLEL_POINT_PROJECTION = FALSE
          NON_PARALLEL = TRUE
          TOUCH = FALSE
          POINT_TOUCH = FALSE
          NODAL = TRUE
        } (21 )
    } else {
        EXTERNAL default_via1  {
          COMMENT = "$layer_name Spacing   : minimum spacing = cut_minSpacing um (corner to corner spacing = cut_cornerMinSpacing um) "
          SPACING < cut_minSpacing
          CONVEX_TO_CONVEX < cut_cornerMinSpacing
          NON_PARALLEL = TRUE
          POINT_TOUCH = TRUE
          NODAL = TRUE
        } (21 )
    }
  } else {
    EXTERNAL default_via1  {
      COMMENT = "$layer_name Spacing   : minimum spacing = cut_minSpacing um"
      SPACING < cut_minSpacing
      BOX_CORNER = FALSE 
      NON_PARALLEL = TRUE
      POINT_TOUCH = TRUE
      NODAL = TRUE
    } (21 ) 
  }
} else {
   if (cut_minSpacing > 0) {
     if (cut_cornerMinSpacing > 0) {
        if (cornerSpacingMode == 1) {
           /* Work around: CONVEX_TO_CONVEX [POINT_PROJECTION] has a bug */
           EXTERNAL default_via1  {
             SPACING <= 0
             CONVEX_TO_CONVEX [POINT_PROJECTION] < cut_cornerMinSpacing
             NON_PARALLEL = TRUE
             POINT_TOUCH = TRUE
             BOX_CORNER = FALSE 
           } TEMP = corner_err1 
           EXTERNAL default_via1  {
             SPACING <= 0
             CONVEX_TO_CONVEX < cut_cornerMinSpacing
             NON_PARALLEL = TRUE
             POINT_TOUCH = TRUE
             BOX_CORNER = TRUE
           } TEMP = corner_err2 
           BOOLEAN corner_err1 OR corner_err2 {
             COMMENT = "$layer_name Spacing   : corner to corner spacing = cut_cornerMinSpacing um "
           } (21 )
           EXTERNAL default_via1  {
             COMMENT = "$layer_name Spacing   : minimum spacing = cut_minSpacing um"
             SPACING < cut_minSpacing
             SET_CORNERS_TO_SPACING = FALSE
             PARALLEL_POINT_PROJECTION = FALSE
             NON_PARALLEL = TRUE
             TOUCH = FALSE
             POINT_TOUCH = FALSE
           } (21 )
        } else {
           EXTERNAL default_via1  {
             COMMENT = "$layer_name Spacing   : minimum spacing = cut_minSpacing um (corner to corner spacing = cut_cornerMinSpacing um) "
             SPACING < cut_minSpacing
             CONVEX_TO_CONVEX < cut_cornerMinSpacing
             NON_PARALLEL = TRUE
             POINT_TOUCH = TRUE
           } (21 )
        }
    } else {
       EXTERNAL default_via1  {
          COMMENT = "$layer_name Spacing   : minimum spacing = cut_minSpacing um"
          SPACING < cut_minSpacing
	  BOX_CORNER = FALSE 
	  NON_PARALLEL = TRUE
	  POINT_TOUCH = TRUE
       } (21 )
    }
  }
}
 
/*check blockage spacing*/
if (ignoreBlockage == 0) {
   if (!layer_empty (via1_blockage )) {
      if (cutBlkg_minSpacing > 0) {
	  EXTERNAL via1_blockage  via1  {
              COMMENT = "$layer_name Spacing   : contact & blockage minimum spacing = cutBlkg_minSpacing um"
	      SPACING < cutBlkg_minSpacing
	      BOX_CORNER = FALSE 
	      NON_PARALLEL = TRUE
	      POINT_TOUCH = TRUE
          } (21 )
      }
   }
}
/*check blockage overlap*/ 
/*check shorts between top_level routing and fram_blockages*/
if (cutBlkg_minSpacing > 0 || checkCrossHierShort > 0) {
   if (readCellView > 0) {
       COPY empty {} TEMP = real_blockage
       COPY via1  {} TEMP = top_cut
   } else {
       COPY via1_fram  {} TEMP = real_blockage
       COPY via1_top  {} TEMP = top_cut
   }
   if (ignoreBlockage == 0) {
      BOOLEAN via1_blockage  OR real_blockage {} TEMP=all_blockage
   } else {
      COPY real_blockage {} TEMP=all_blockage
   }
   
   BOOLEAN all_blockage AND top_cut {} TEMP = overlap_shape1
   EXTERNAL all_blockage top_cut {
      SPACING <= 0
      TOUCH = TRUE
   } TEMP = overlap_shape2
   if (checkCrossHierShort > 0) {
      BOOLEAN overlap_shape1 OR overlap_shape2 {
          COMMENT = "$layer_name Short Cross Hierarchy"
      } (21 )
   } else {
      BOOLEAN overlap_shape1 OR overlap_shape2 {
          COMMENT = "$layer_name Overlap   : cut & blockage overlap"
      } (21 )
   }
}
/*check adjacent via number*/
if (cut_adjacentCutRange > 0 && cut_maxNumAdjacentCut > 0) {
    if (router_ignoreSameNetAdjacentViaDRC) {
       EXTERNAL via1  {  
	   SPACING < cut_adjacentCutRange
	   SET_CORNERS_TO_SPACING = FALSE
	   PARALLEL_POINT_PROJECTION = FALSE
	   NON_PARALLEL = TRUE
	   BOX_CORNER = FALSE
	   SHADOW = FALSE
           NODAL = TRUE
       } TEMP=edge_spacing
       EXTERNAL via1  {
	   SPACING < 0
	   CONVEX_TO_EDGE < cut_adjacentCutRange
	   CONVEX_TO_CONVEX < cut_adjacentCutRange
	   BOX_CORNER = FALSE
	   SHADOW = FALSE
           NODAL = TRUE
       } TEMP=corner_spacing
    } else {
       EXTERNAL via1  {  
	   SPACING < cut_adjacentCutRange
	   SET_CORNERS_TO_SPACING = FALSE
	   PARALLEL_POINT_PROJECTION = FALSE
	   NON_PARALLEL = TRUE
	   BOX_CORNER = FALSE
	   SHADOW = FALSE
       } TEMP=edge_spacing
 
       EXTERNAL via1  {
	   SPACING < 0
	   CONVEX_TO_EDGE < cut_adjacentCutRange
	   CONVEX_TO_CONVEX < cut_adjacentCutRange
	   BOX_CORNER = FALSE
	   SHADOW = FALSE
       } TEMP=corner_spacing
    }
    SIZE edge_spacing { UNDERSIZE = 0.001  } TEMP = edge_spacing1
    SIZE edge_spacing1 { OVERSIZE = 0.001  } TEMP = edge_spacing2
    BOOLEAN (edge_spacing NOT edge_spacing2) OR edge_spacing1 { } TEMP=edge_spacing
 
    SIZE corner_spacing { UNDERSIZE = 0.001  } TEMP = corner_spacing1
    SIZE corner_spacing1 { OVERSIZE = 0.001  } TEMP = corner_spacing2
    BOOLEAN (corner_spacing NOT corner_spacing2) OR corner_spacing1 { } TEMP=corner_spacing
  
    BOOLEAN edge_spacing OR corner_spacing { } TEMP = spacing
 
    SIZE via1  { OVERSIZE = 5* 0.001  } TEMP = cut
 
    SELECT cut INTERACT spacing {
        POINT_TOUCH = TRUE
        RANGE = [cut_maxNumAdjacentCut + 1, 9999999999 ]
    } TEMP = enclosed_cut
 
    SELECT via1  INSIDE enclosed_cut {
        COMMENT = "$layer_name AdjContNum: maximum number of the adjacent contacts ( cut_adjacentCutRange um) = cut_maxNumAdjacentCut "
    } (21 )
}
 
/*check enclosed via spacing*/
if (cut_enclosedCutNeighborRange > 0 && cut_enclosedCutNumNeighbor > 0) {
    if (cut_enclosedCutDiagViaExcluded) {
       EXTERNAL via1  {
          SPACING < cut_enclosedCutNeighborRange
          SET_CORNERS_TO_SPACING = FALSE
          PARALLEL_POINT_PROJECTION = FALSE
          NON_PARALLEL = TRUE
          BOX_CORNER = FALSE
          SHADOW = FALSE
       } TEMP = edge_spacing
       SELECT via1  TOUCHING edge_spacing {
          RANGE = [cut_enclosedCutNumNeighbor, 9999999999 ]
       } TEMP = enclosed_cut
    } else {
       /* Work around: for SIZE_RECT FLAG_INTERACTION_COUNT parser bug */
       
@ 308 "adrc/adrc_check_via.ev"
       if (cut_enclosedCutNumNeighbor==1) {
          
@-         SIZE_RECT via1  { 
@-            RANGE1=[0, 10] 
@-            RANGE2=[0, 10] 
@-            RANGE1_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0005 ) 
@-            RANGE2_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0005 ) 
@-            FLAG_INTERACTION_COUNT >  0  
@-            CORNER_METHOD = RADIAL 
@-         } TEMP=enclosed_cut 
       } else if (cut_enclosedCutNumNeighbor==2) {
          
@-         SIZE_RECT via1  { 
@-            RANGE1=[0, 10] 
@-            RANGE2=[0, 10] 
@-            RANGE1_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0005 ) 
@-            RANGE2_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0005 ) 
@-            FLAG_INTERACTION_COUNT >  1  
@-            CORNER_METHOD = RADIAL 
@-         } TEMP=enclosed_cut 
       } else if (cut_enclosedCutNumNeighbor==3) {
          
@-         SIZE_RECT via1  { 
@-            RANGE1=[0, 10] 
@-            RANGE2=[0, 10] 
@-            RANGE1_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0005 ) 
@-            RANGE2_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0005 ) 
@-            FLAG_INTERACTION_COUNT >  2  
@-            CORNER_METHOD = RADIAL 
@-         } TEMP=enclosed_cut 
       } else if (cut_enclosedCutNumNeighbor==4) {
          
@-         SIZE_RECT via1  { 
@-            RANGE1=[0, 10] 
@-            RANGE2=[0, 10] 
@-            RANGE1_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0005 ) 
@-            RANGE2_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0005 ) 
@-            FLAG_INTERACTION_COUNT >  3  
@-            CORNER_METHOD = RADIAL 
@-         } TEMP=enclosed_cut 
       } else if (cut_enclosedCutNumNeighbor==5) {
          
@-         SIZE_RECT via1  { 
@-            RANGE1=[0, 10] 
@-            RANGE2=[0, 10] 
@-            RANGE1_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0005 ) 
@-            RANGE2_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0005 ) 
@-            FLAG_INTERACTION_COUNT >  4  
@-            CORNER_METHOD = RADIAL 
@-         } TEMP=enclosed_cut 
       } else if (cut_enclosedCutNumNeighbor==6) {
          
@-         SIZE_RECT via1  { 
@-            RANGE1=[0, 10] 
@-            RANGE2=[0, 10] 
@-            RANGE1_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0005 ) 
@-            RANGE2_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0005 ) 
@-            FLAG_INTERACTION_COUNT >  5  
@-            CORNER_METHOD = RADIAL 
@-         } TEMP=enclosed_cut 
       } else if (cut_enclosedCutNumNeighbor==7) {
          
@-         SIZE_RECT via1  { 
@-            RANGE1=[0, 10] 
@-            RANGE2=[0, 10] 
@-            RANGE1_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0005 ) 
@-            RANGE2_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0005 ) 
@-            FLAG_INTERACTION_COUNT >  6  
@-            CORNER_METHOD = RADIAL 
@-         } TEMP=enclosed_cut 
       } else if (cut_enclosedCutNumNeighbor==8) {
          
@-         SIZE_RECT via1  { 
@-            RANGE1=[0, 10] 
@-            RANGE2=[0, 10] 
@-            RANGE1_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0005 ) 
@-            RANGE2_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0005 ) 
@-            FLAG_INTERACTION_COUNT >  7  
@-            CORNER_METHOD = RADIAL 
@-         } TEMP=enclosed_cut 
       } else if (cut_enclosedCutNumNeighbor==9) {
          
@-         SIZE_RECT via1  { 
@-            RANGE1=[0, 10] 
@-            RANGE2=[0, 10] 
@-            RANGE1_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0005 ) 
@-            RANGE2_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0005 ) 
@-            FLAG_INTERACTION_COUNT >  8  
@-            CORNER_METHOD = RADIAL 
@-         } TEMP=enclosed_cut 
       } else if (cut_enclosedCutNumNeighbor>9) {
          
@-         SIZE_RECT via1  { 
@-            RANGE1=[0, 10] 
@-            RANGE2=[0, 10] 
@-            RANGE1_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0005 ) 
@-            RANGE2_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0005 ) 
@-            FLAG_INTERACTION_COUNT >  9  
@-            CORNER_METHOD = RADIAL 
@-         } TEMP=enclosed_cut 
       }
    }
    if (router_ignoreSameNetAdjacentViaDRC) {
      /* Good approximation for same net via filter */
      CENTER_TO_CENTER via1  {
        NODAL=TRUE
        SPACING < cut_enclosedCutNeighborRange + 1.41421*cut_size + 0.0005 
        OUTPUT_VECTOR = TRUE
      } TEMP = c2c_spacing
      SIZE via1  { UNDERSIZE = (cut_size/2.0- 0.0005 ) } TEMP=cut_center
      BOOLEAN c2c_spacing NOT cut_center { } TEMP=c2c_spacing
      SIZE cut_center { OVERSIZE = 0.001  } TEMP=cut_center
      BOOLEAN c2c_spacing AND via1   { } TEMP=c2c_filter
      SELECT cut_center INTERACT c2c_filter {
        POINT_TOUCH=TRUE
        RANGE = [cut_enclosedCutNumNeighbor, 9999999999 ]
      } TEMP = target_cut
   
      SELECT enclosed_cut ENCLOSING target_cut { } TEMP = enclosed_cut
    }
  
    if (cut_enclosedCutMinSpacing > 0) {
        EXTERNAL enclosed_cut {
        COMMENT = "$layer_name EncContSpc: minimum spacing between enclosed contacts ( cut_enclosedCutNeighborRange um / cut_enclosedCutNumNeighbor ) = cut_enclosedCutMinSpacing "
            SPACING < cut_enclosedCutMinSpacing
            SET_CORNERS_TO_SPACING = TRUE 
	    BOX_CORNER = FALSE 
	    NON_PARALLEL = TRUE
	    POINT_TOUCH = TRUE
        } (21 )
    }
 
    if (cut_enclosedCutToNeighborMinSpacing > 0) {
       if (router_ignoreSameNetAdjacentViaDRC) {
          CONNECT { enclosed_cut BY via1  }
          EXTERNAL enclosed_cut via1  {
              COMMENT = "$layer_name EncContSpc: minimum spacing between enclosed and neighboring contacts ( cut_enclosedCutNeighborRange um / cut_enclosedCutNumNeighbor ) = cut_enclosedCutToNeighborMinSpacing "
              SPACING < cut_enclosedCutToNeighborMinSpacing
              SET_CORNERS_TO_SPACING = TRUE 
	      BOX_CORNER = FALSE 
	      NON_PARALLEL = TRUE
	      POINT_TOUCH = TRUE
              NODAL = TRUE
          } (21 )
       } else {
          EXTERNAL enclosed_cut via1  {
              COMMENT = "$layer_name EncContSpc: minimum spacing between enclosed and neighboring contacts ( cut_enclosedCutNeighborRange um / cut_enclosedCutNumNeighbor ) = cut_enclosedCutToNeighborMinSpacing "
              SPACING < cut_enclosedCutToNeighborMinSpacing
              SET_CORNERS_TO_SPACING = TRUE 
	      BOX_CORNER = FALSE 
	      NON_PARALLEL = TRUE
	      POINT_TOUCH = TRUE
          } (21 )
       }
    }
}
 
/*check max stack level, upward only*/
if (cut_maxStackLevel > 0 && cut_stackLevelSpacing > 0) {
    if (cut_maxStackLevel == 1) {
      BOOLEAN via1  AND CUT_LAYER1 { } TEMP = neighbors
    }
    else if (cut_maxStackLevel == 2) {
      BOOLEAN (via1  AND CUT_LAYER1) AND CUT_LAYER2 { } TEMP = neighbors
    }
    else if (cut_maxStackLevel == 3) {
      BOOLEAN (via1  AND CUT_LAYER1) AND (CUT_LAYER2 AND CUT_LAYER3)
        { } TEMP = neighbors
    }
    else if (cut_maxStackLevel == 4) {
      BOOLEAN ((via1  AND CUT_LAYER1) AND (CUT_LAYER2 AND CUT_LAYER3))
        AND CUT_LAYER4 { } TEMP = neighbors
    }
    else if (cut_maxStackLevel == 5) {
      BOOLEAN ((via1  AND CUT_LAYER1) AND (CUT_LAYER2 AND CUT_LAYER3))
        AND (CUT_LAYER4 AND CUT_LAYER5) { } TEMP = neighbors
    }
    else if (cut_maxStackLevel == 6) {
      BOOLEAN ((via1  AND CUT_LAYER1) AND (CUT_LAYER2 AND CUT_LAYER3))
        AND ((CUT_LAYER4 AND CUT_LAYER5) AND CUT_LAYER6) { } TEMP = neighbors
    }
    else if (cut_maxStackLevel >= 7) { 
      BOOLEAN ((via1  AND CUT_LAYER1) AND (CUT_LAYER2 AND CUT_LAYER3))
        AND ((CUT_LAYER4 AND CUT_LAYER5) AND (CUT_LAYER6 AND CUT_LAYER7))
       { } TEMP = neighbors
    }
 
    if (!layer_empty(neighbors)) {
      SELECT CUT_LAYER0 INTERACT neighbors {
        LINE_TOUCH = FALSE POINT_TOUCH = FALSE 
      } TEMP = neighbors
      EXTERNAL neighbors {
	spacing <= cut_stackLevelSpacing
      } TEMP = via_arr_ext
      if (!layer_empty (via_arr_ext)) {
	SELECT neighbors OUTSIDE via_arr_ext {
         COMMENT = "$layer_name StackLevel: maximum stack level = cut_maxStackLevel "
          LINE_TOUCH = FALSE
          POINT_TOUCH = FALSE	    
        } (21 )
      }
      else {
        BOOLEAN via1  AND neighbors {
            COMMENT = "$layer_name StackLevel: maximum stack level = cut_maxStackLevel "
        } (21 )
      }
    }
  }
  else if (cut_maxStackLevel > 0) {
    if (cut_maxStackLevel == 1) {
      COPY CUT_LAYER1 { } TEMP = neighbors
    }
    else if (cut_maxStackLevel == 2) {
      BOOLEAN CUT_LAYER1 AND CUT_LAYER2 { } TEMP = neighbors
    }
    else if (cut_maxStackLevel == 3) {
      BOOLEAN CUT_LAYER1 AND (CUT_LAYER2 AND CUT_LAYER3)
        { } TEMP = neighbors
    }
    else if (cut_maxStackLevel == 4) {
      BOOLEAN (CUT_LAYER1 AND CUT_LAYER2) AND (CUT_LAYER3 AND CUT_LAYER4)
        { } TEMP = neighbors
    }
    else if (cut_maxStackLevel == 5) {
      BOOLEAN ((CUT_LAYER1 AND CUT_LAYER2) AND (CUT_LAYER3 AND CUT_LAYER4))
        AND CUT_LAYER5 { } TEMP = neighbors
    }
    else if (cut_maxStackLevel == 6) {
      BOOLEAN ((CUT_LAYER6 AND CUT_LAYER1) AND (CUT_LAYER2 AND CUT_LAYER3))
        AND (CUT_LAYER4 AND CUT_LAYER5) { } TEMP = neighbors
    }
    else if (cut_maxStackLevel >= 7) { 
      BOOLEAN ((CUT_LAYER7 AND CUT_LAYER1) AND (CUT_LAYER2 AND CUT_LAYER3))
        AND ((CUT_LAYER4 AND CUT_LAYER5) AND CUT_LAYER6) { } TEMP = neighbors
    }
 
    if (!layer_empty (neighbors)) {
        BOOLEAN via1  AND neighbors {
            COMMENT = "$layer_name StackLevel: maximum stack level = cut_maxStackLevel "
        } (21 )
    }
}
 
/*Check fat contact*/
if (cut_fatContactMinSpacing > 0 && cut_fatTblDimension == 0) {
    if (cut_fatContactThreshold1 > 0) {
    	SIZE metal1    { UNDER_OVER = cut_fatContactThreshold1 / 2.0 - 0.0005  } TEMP = m_fat
    	BOOLEAN m_fat AND metal1  { } TEMP = m_fat
 
    	SELECT via1  INSIDE  m_fat { } TEMP = v_fat
 
    	EXTERNAL v_fat via1  {
            COMMENT = "$layer_name FatContSpc: fat contact ( cut_fatContactThreshold1 um, lower layer) minimum spacing = cut_fatContactMinSpacing um"
            SPACING < cut_fatContactMinSpacing
	    BOX_CORNER = FALSE 
	    NON_PARALLEL = TRUE
	    POINT_TOUCH = TRUE
        } (21 )
    }
 
    if (cut_fatContactThreshold2 > 0) {
    	SIZE metal2    { UNDER_OVER = cut_fatContactThreshold2 / 2.0 - 0.0005  } TEMP = m_fat
    	BOOLEAN m_fat AND metal2  { } TEMP = m_fat
 
    	SELECT via1  INSIDE  m_fat { } TEMP = v_fat
 
    	EXTERNAL v_fat via1  {
            COMMENT = "$layer_name FatContSpc: fat contact ( cut_fatContactThreshold2 um, upper layer) minimum spacing = cut_fatContactMinSpacing um"
            SPACING < cut_fatContactMinSpacing
	    BOX_CORNER = FALSE 
	    NON_PARALLEL = TRUE
	    POINT_TOUCH = TRUE
        } (21 )
    }
}
/* Avoid empty optimization result parsing error */
if (addEmptyViaCheck) {
   BOOLEAN empty OR empty {
      COMMENT = "$layer_name Empty: Dummy Output"
   } (21 )
   SET addEmptyViaCheck=0;
}
 
/* reset variables */















SET cut_size = 0;
SET cut_minSpacing = 0;
SET cut_sameNetMinSpacing = 0;
SET cut_cornerMinSpacing = 0;
SET cutBlkg_minSpacing = 0;
SET cut_maxNumAdjacentCut = 0;
SET cut_adjacentCutRange = 0;
SET cut_enclosedCutNeighborRange = 0;
SET cut_enclosedCutNumNeighbor = 0;
SET cut_enclosedCutMinSpacing = 0;
SET cut_enclosedCutToNeighborMinSpacing = 0;
SET cut_enclosedCutDiagViaExcluded = 0;
SET cut_maxStackLevel = 0;
SET cut_defaultContactMinSpacing = 0;
SET cut_fatContactThreshold1 = 0;
SET cut_fatContactThreshold2 = 0;
SET cut_fatContactMinSpacing = 0;
SET cut_maxCutSpacing = 0; 
SET cut_fatTblDimension = 0;
SET cut_fatTblThreshold_1 = 0;
SET cut_fatTblThreshold_2 = 0;
SET cut_fatTblNextThreshold_1 = 0;
SET cut_fatTblNextThreshold_2 = 0;
SET cut_fatTblMinCuts = 0;
SET cut_fatTblMinSpacing = 0;
SET cut_fatTblExtensionRange = 0;
SET cut_fatTblExtensionMinCuts = 0;
SET cut_fatTblExtensionMinSpacing = 0;
@ 435 "adrc/adrc.ev" 2











/*via 2*/
SET layer_name = "Via2";












SET cornerSpacingMode = 0;
SET cut_minSpacing = 0.14;
SET cut_fatTblDimension = 0;
@ 1 "adrc/adrc_check_via.ev" 1
/* check size */
if (cut_size > 0) {
    INTERNAL via2  {  
        COMMENT = "$layer_name Size      : contact size = cut_size um" 
	DIMENSION = [cut_size , cut_size]
    } (22 )
}
if (cut_minSpacing > 0) {
   if (ignoreContactCodeSpacing) {
      COPY via2  { } TEMP= default_via2 
   } else {
      SIZE metal2  { UNDER_OVER = cut_fatContactThreshold1 } TEMP = m_fat1
      SIZE metal3  { UNDER_OVER = cut_fatContactThreshold2 } TEMP = m_fat2
      BOOLEAN m_fat1 OR m_fat2 {} TEMP=m_fat
      SELECT via2  OUTSIDE m_fat { } TEMP= default_via2 
   }
}
 
/*check basic spacing*/
if (cut_sameNetMinSpacing > 0 && cut_sameNetMinSpacing < cut_minSpacing) {
  CONNECT { default_via2  BY via2  }
  if (cut_cornerMinSpacing > 0) {
    if (cornerSpacingMode == 1) {
        /* Work around: CONVEX_TO_CONVEX [POINT_PROJECTION] has a bug */
        EXTERNAL default_via2  {
             SPACING <= 0
             CONVEX_TO_CONVEX [POINT_PROJECTION] < cut_cornerMinSpacing
             FLAG_DISCONNECTED = FALSE
             NON_PARALLEL = TRUE
             POINT_TOUCH = TRUE
             BOX_CORNER = FALSE
        } TEMP = sameNet_corner_err1
        EXTERNAL default_via2  {
             SPACING <= 0
             CONVEX_TO_CONVEX < cut_cornerMinSpacing
             FLAG_DISCONNECTED = FALSE
             NON_PARALLEL = TRUE
             POINT_TOUCH = TRUE
             BOX_CORNER = TRUE
        } TEMP = sameNet_corner_err2 
        BOOLEAN sameNet_corner_err1 OR sameNet_corner_err2 {
             COMMENT = "$layer_name SameNetSpc: corner to corner spacing = cut_cornerMinSpacing um "
        } (22 ) 
        EXTERNAL default_via2  {
             COMMENT = "$layer_name SameNetSpc: same-net minimum spacing = cut_sameNetMinSpacing um "
             SPACING < cut_sameNetMinSpacing
             FLAG_DISCONNECTED = FALSE
             SET_CORNERS_TO_SPACING = FALSE
             PARALLEL_POINT_PROJECTION = FALSE
             NON_PARALLEL = TRUE
             TOUCH = FALSE
             POINT_TOUCH = FALSE
        } (22 )
    } else {
        EXTERNAL default_via2  {
            COMMENT = "$layer_name SameNetSpc: same-net minimum spacing = cut_sameNetMinSpacing um (corner to corner spacing = cut_cornerMinSpacing um) "
            SPACING < cut_sameNetMinSpacing
            CONVEX_TO_CONVEX < cut_cornerMinSpacing
            FLAG_DISCONNECTED = FALSE
            NON_PARALLEL = TRUE
            POINT_TOUCH = TRUE
        } (22 )
    }
  } else {
    EXTERNAL default_via2  {
        COMMENT = "$layer_name SameNetSpc: same-net minimum spacing = cut_sameNetMinSpacing um"
        SPACING < cut_sameNetMinSpacing
	BOX_CORNER = FALSE 
        FLAG_DISCONNECTED = FALSE
	NON_PARALLEL = TRUE
	POINT_TOUCH = TRUE
    } (22 )
  }
  if (cut_cornerMinSpacing > 0) {
    if (cornerSpacingMode == 1) {
        /* Work around: CONVEX_TO_CONVEX [POINT_PROJECTION] has a bug */
        EXTERNAL default_via2  {
          SPACING <= 0
          CONVEX_TO_CONVEX [POINT_PROJECTION] < cut_cornerMinSpacing
          NON_PARALLEL = TRUE
          POINT_TOUCH = TRUE
          BOX_CORNER = FALSE
          NODAL = TRUE
        } TEMP = diffNet_corner_err1 
        EXTERNAL default_via2  {
          SPACING <= 0
          CONVEX_TO_CONVEX < cut_cornerMinSpacing
          NON_PARALLEL = TRUE
          POINT_TOUCH = TRUE
          BOX_CORNER = TRUE
          NODAL = TRUE
        } TEMP = diffNet_corner_err2 
        BOOLEAN diffNet_corner_err1 OR diffNet_corner_err2 {
          COMMENT = "$layer_name Spacing   : corner to corner spacing = cut_cornerMinSpacing um "
        } (22 )
        EXTERNAL default_via2  {
          COMMENT = "$layer_name Spacing   : minimum spacing = cut_minSpacing um"
          SPACING < cut_minSpacing
          SET_CORNERS_TO_SPACING = FALSE
          PARALLEL_POINT_PROJECTION = FALSE
          NON_PARALLEL = TRUE
          TOUCH = FALSE
          POINT_TOUCH = FALSE
          NODAL = TRUE
        } (22 )
    } else {
        EXTERNAL default_via2  {
          COMMENT = "$layer_name Spacing   : minimum spacing = cut_minSpacing um (corner to corner spacing = cut_cornerMinSpacing um) "
          SPACING < cut_minSpacing
          CONVEX_TO_CONVEX < cut_cornerMinSpacing
          NON_PARALLEL = TRUE
          POINT_TOUCH = TRUE
          NODAL = TRUE
        } (22 )
    }
  } else {
    EXTERNAL default_via2  {
      COMMENT = "$layer_name Spacing   : minimum spacing = cut_minSpacing um"
      SPACING < cut_minSpacing
      BOX_CORNER = FALSE 
      NON_PARALLEL = TRUE
      POINT_TOUCH = TRUE
      NODAL = TRUE
    } (22 ) 
  }
} else {
   if (cut_minSpacing > 0) {
     if (cut_cornerMinSpacing > 0) {
        if (cornerSpacingMode == 1) {
           /* Work around: CONVEX_TO_CONVEX [POINT_PROJECTION] has a bug */
           EXTERNAL default_via2  {
             SPACING <= 0
             CONVEX_TO_CONVEX [POINT_PROJECTION] < cut_cornerMinSpacing
             NON_PARALLEL = TRUE
             POINT_TOUCH = TRUE
             BOX_CORNER = FALSE 
           } TEMP = corner_err1 
           EXTERNAL default_via2  {
             SPACING <= 0
             CONVEX_TO_CONVEX < cut_cornerMinSpacing
             NON_PARALLEL = TRUE
             POINT_TOUCH = TRUE
             BOX_CORNER = TRUE
           } TEMP = corner_err2 
           BOOLEAN corner_err1 OR corner_err2 {
             COMMENT = "$layer_name Spacing   : corner to corner spacing = cut_cornerMinSpacing um "
           } (22 )
           EXTERNAL default_via2  {
             COMMENT = "$layer_name Spacing   : minimum spacing = cut_minSpacing um"
             SPACING < cut_minSpacing
             SET_CORNERS_TO_SPACING = FALSE
             PARALLEL_POINT_PROJECTION = FALSE
             NON_PARALLEL = TRUE
             TOUCH = FALSE
             POINT_TOUCH = FALSE
           } (22 )
        } else {
           EXTERNAL default_via2  {
             COMMENT = "$layer_name Spacing   : minimum spacing = cut_minSpacing um (corner to corner spacing = cut_cornerMinSpacing um) "
             SPACING < cut_minSpacing
             CONVEX_TO_CONVEX < cut_cornerMinSpacing
             NON_PARALLEL = TRUE
             POINT_TOUCH = TRUE
           } (22 )
        }
    } else {
       EXTERNAL default_via2  {
          COMMENT = "$layer_name Spacing   : minimum spacing = cut_minSpacing um"
          SPACING < cut_minSpacing
	  BOX_CORNER = FALSE 
	  NON_PARALLEL = TRUE
	  POINT_TOUCH = TRUE
       } (22 )
    }
  }
}
 
/*check blockage spacing*/
if (ignoreBlockage == 0) {
   if (!layer_empty (via2_blockage )) {
      if (cutBlkg_minSpacing > 0) {
	  EXTERNAL via2_blockage  via2  {
              COMMENT = "$layer_name Spacing   : contact & blockage minimum spacing = cutBlkg_minSpacing um"
	      SPACING < cutBlkg_minSpacing
	      BOX_CORNER = FALSE 
	      NON_PARALLEL = TRUE
	      POINT_TOUCH = TRUE
          } (22 )
      }
   }
}
/*check blockage overlap*/ 
/*check shorts between top_level routing and fram_blockages*/
if (cutBlkg_minSpacing > 0 || checkCrossHierShort > 0) {
   if (readCellView > 0) {
       COPY empty {} TEMP = real_blockage
       COPY via2  {} TEMP = top_cut
   } else {
       COPY via2_fram  {} TEMP = real_blockage
       COPY via2_top  {} TEMP = top_cut
   }
   if (ignoreBlockage == 0) {
      BOOLEAN via2_blockage  OR real_blockage {} TEMP=all_blockage
   } else {
      COPY real_blockage {} TEMP=all_blockage
   }
   
   BOOLEAN all_blockage AND top_cut {} TEMP = overlap_shape1
   EXTERNAL all_blockage top_cut {
      SPACING <= 0
      TOUCH = TRUE
   } TEMP = overlap_shape2
   if (checkCrossHierShort > 0) {
      BOOLEAN overlap_shape1 OR overlap_shape2 {
          COMMENT = "$layer_name Short Cross Hierarchy"
      } (22 )
   } else {
      BOOLEAN overlap_shape1 OR overlap_shape2 {
          COMMENT = "$layer_name Overlap   : cut & blockage overlap"
      } (22 )
   }
}
/*check adjacent via number*/
if (cut_adjacentCutRange > 0 && cut_maxNumAdjacentCut > 0) {
    if (router_ignoreSameNetAdjacentViaDRC) {
       EXTERNAL via2  {  
	   SPACING < cut_adjacentCutRange
	   SET_CORNERS_TO_SPACING = FALSE
	   PARALLEL_POINT_PROJECTION = FALSE
	   NON_PARALLEL = TRUE
	   BOX_CORNER = FALSE
	   SHADOW = FALSE
           NODAL = TRUE
       } TEMP=edge_spacing
       EXTERNAL via2  {
	   SPACING < 0
	   CONVEX_TO_EDGE < cut_adjacentCutRange
	   CONVEX_TO_CONVEX < cut_adjacentCutRange
	   BOX_CORNER = FALSE
	   SHADOW = FALSE
           NODAL = TRUE
       } TEMP=corner_spacing
    } else {
       EXTERNAL via2  {  
	   SPACING < cut_adjacentCutRange
	   SET_CORNERS_TO_SPACING = FALSE
	   PARALLEL_POINT_PROJECTION = FALSE
	   NON_PARALLEL = TRUE
	   BOX_CORNER = FALSE
	   SHADOW = FALSE
       } TEMP=edge_spacing
 
       EXTERNAL via2  {
	   SPACING < 0
	   CONVEX_TO_EDGE < cut_adjacentCutRange
	   CONVEX_TO_CONVEX < cut_adjacentCutRange
	   BOX_CORNER = FALSE
	   SHADOW = FALSE
       } TEMP=corner_spacing
    }
    SIZE edge_spacing { UNDERSIZE = 0.001  } TEMP = edge_spacing1
    SIZE edge_spacing1 { OVERSIZE = 0.001  } TEMP = edge_spacing2
    BOOLEAN (edge_spacing NOT edge_spacing2) OR edge_spacing1 { } TEMP=edge_spacing
 
    SIZE corner_spacing { UNDERSIZE = 0.001  } TEMP = corner_spacing1
    SIZE corner_spacing1 { OVERSIZE = 0.001  } TEMP = corner_spacing2
    BOOLEAN (corner_spacing NOT corner_spacing2) OR corner_spacing1 { } TEMP=corner_spacing
  
    BOOLEAN edge_spacing OR corner_spacing { } TEMP = spacing
 
    SIZE via2  { OVERSIZE = 5* 0.001  } TEMP = cut
 
    SELECT cut INTERACT spacing {
        POINT_TOUCH = TRUE
        RANGE = [cut_maxNumAdjacentCut + 1, 9999999999 ]
    } TEMP = enclosed_cut
 
    SELECT via2  INSIDE enclosed_cut {
        COMMENT = "$layer_name AdjContNum: maximum number of the adjacent contacts ( cut_adjacentCutRange um) = cut_maxNumAdjacentCut "
    } (22 )
}
 
/*check enclosed via spacing*/
if (cut_enclosedCutNeighborRange > 0 && cut_enclosedCutNumNeighbor > 0) {
    if (cut_enclosedCutDiagViaExcluded) {
       EXTERNAL via2  {
          SPACING < cut_enclosedCutNeighborRange
          SET_CORNERS_TO_SPACING = FALSE
          PARALLEL_POINT_PROJECTION = FALSE
          NON_PARALLEL = TRUE
          BOX_CORNER = FALSE
          SHADOW = FALSE
       } TEMP = edge_spacing
       SELECT via2  TOUCHING edge_spacing {
          RANGE = [cut_enclosedCutNumNeighbor, 9999999999 ]
       } TEMP = enclosed_cut
    } else {
       /* Work around: for SIZE_RECT FLAG_INTERACTION_COUNT parser bug */
       
@ 308 "adrc/adrc_check_via.ev"
       if (cut_enclosedCutNumNeighbor==1) {
          
@-         SIZE_RECT via2  { 
@-            RANGE1=[0, 10] 
@-            RANGE2=[0, 10] 
@-            RANGE1_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0005 ) 
@-            RANGE2_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0005 ) 
@-            FLAG_INTERACTION_COUNT >  0  
@-            CORNER_METHOD = RADIAL 
@-         } TEMP=enclosed_cut 
       } else if (cut_enclosedCutNumNeighbor==2) {
          
@-         SIZE_RECT via2  { 
@-            RANGE1=[0, 10] 
@-            RANGE2=[0, 10] 
@-            RANGE1_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0005 ) 
@-            RANGE2_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0005 ) 
@-            FLAG_INTERACTION_COUNT >  1  
@-            CORNER_METHOD = RADIAL 
@-         } TEMP=enclosed_cut 
       } else if (cut_enclosedCutNumNeighbor==3) {
          
@-         SIZE_RECT via2  { 
@-            RANGE1=[0, 10] 
@-            RANGE2=[0, 10] 
@-            RANGE1_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0005 ) 
@-            RANGE2_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0005 ) 
@-            FLAG_INTERACTION_COUNT >  2  
@-            CORNER_METHOD = RADIAL 
@-         } TEMP=enclosed_cut 
       } else if (cut_enclosedCutNumNeighbor==4) {
          
@-         SIZE_RECT via2  { 
@-            RANGE1=[0, 10] 
@-            RANGE2=[0, 10] 
@-            RANGE1_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0005 ) 
@-            RANGE2_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0005 ) 
@-            FLAG_INTERACTION_COUNT >  3  
@-            CORNER_METHOD = RADIAL 
@-         } TEMP=enclosed_cut 
       } else if (cut_enclosedCutNumNeighbor==5) {
          
@-         SIZE_RECT via2  { 
@-            RANGE1=[0, 10] 
@-            RANGE2=[0, 10] 
@-            RANGE1_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0005 ) 
@-            RANGE2_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0005 ) 
@-            FLAG_INTERACTION_COUNT >  4  
@-            CORNER_METHOD = RADIAL 
@-         } TEMP=enclosed_cut 
       } else if (cut_enclosedCutNumNeighbor==6) {
          
@-         SIZE_RECT via2  { 
@-            RANGE1=[0, 10] 
@-            RANGE2=[0, 10] 
@-            RANGE1_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0005 ) 
@-            RANGE2_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0005 ) 
@-            FLAG_INTERACTION_COUNT >  5  
@-            CORNER_METHOD = RADIAL 
@-         } TEMP=enclosed_cut 
       } else if (cut_enclosedCutNumNeighbor==7) {
          
@-         SIZE_RECT via2  { 
@-            RANGE1=[0, 10] 
@-            RANGE2=[0, 10] 
@-            RANGE1_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0005 ) 
@-            RANGE2_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0005 ) 
@-            FLAG_INTERACTION_COUNT >  6  
@-            CORNER_METHOD = RADIAL 
@-         } TEMP=enclosed_cut 
       } else if (cut_enclosedCutNumNeighbor==8) {
          
@-         SIZE_RECT via2  { 
@-            RANGE1=[0, 10] 
@-            RANGE2=[0, 10] 
@-            RANGE1_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0005 ) 
@-            RANGE2_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0005 ) 
@-            FLAG_INTERACTION_COUNT >  7  
@-            CORNER_METHOD = RADIAL 
@-         } TEMP=enclosed_cut 
       } else if (cut_enclosedCutNumNeighbor==9) {
          
@-         SIZE_RECT via2  { 
@-            RANGE1=[0, 10] 
@-            RANGE2=[0, 10] 
@-            RANGE1_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0005 ) 
@-            RANGE2_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0005 ) 
@-            FLAG_INTERACTION_COUNT >  8  
@-            CORNER_METHOD = RADIAL 
@-         } TEMP=enclosed_cut 
       } else if (cut_enclosedCutNumNeighbor>9) {
          
@-         SIZE_RECT via2  { 
@-            RANGE1=[0, 10] 
@-            RANGE2=[0, 10] 
@-            RANGE1_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0005 ) 
@-            RANGE2_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0005 ) 
@-            FLAG_INTERACTION_COUNT >  9  
@-            CORNER_METHOD = RADIAL 
@-         } TEMP=enclosed_cut 
       }
    }
    if (router_ignoreSameNetAdjacentViaDRC) {
      /* Good approximation for same net via filter */
      CENTER_TO_CENTER via2  {
        NODAL=TRUE
        SPACING < cut_enclosedCutNeighborRange + 1.41421*cut_size + 0.0005 
        OUTPUT_VECTOR = TRUE
      } TEMP = c2c_spacing
      SIZE via2  { UNDERSIZE = (cut_size/2.0- 0.0005 ) } TEMP=cut_center
      BOOLEAN c2c_spacing NOT cut_center { } TEMP=c2c_spacing
      SIZE cut_center { OVERSIZE = 0.001  } TEMP=cut_center
      BOOLEAN c2c_spacing AND via2   { } TEMP=c2c_filter
      SELECT cut_center INTERACT c2c_filter {
        POINT_TOUCH=TRUE
        RANGE = [cut_enclosedCutNumNeighbor, 9999999999 ]
      } TEMP = target_cut
   
      SELECT enclosed_cut ENCLOSING target_cut { } TEMP = enclosed_cut
    }
  
    if (cut_enclosedCutMinSpacing > 0) {
        EXTERNAL enclosed_cut {
        COMMENT = "$layer_name EncContSpc: minimum spacing between enclosed contacts ( cut_enclosedCutNeighborRange um / cut_enclosedCutNumNeighbor ) = cut_enclosedCutMinSpacing "
            SPACING < cut_enclosedCutMinSpacing
            SET_CORNERS_TO_SPACING = TRUE 
	    BOX_CORNER = FALSE 
	    NON_PARALLEL = TRUE
	    POINT_TOUCH = TRUE
        } (22 )
    }
 
    if (cut_enclosedCutToNeighborMinSpacing > 0) {
       if (router_ignoreSameNetAdjacentViaDRC) {
          CONNECT { enclosed_cut BY via2  }
          EXTERNAL enclosed_cut via2  {
              COMMENT = "$layer_name EncContSpc: minimum spacing between enclosed and neighboring contacts ( cut_enclosedCutNeighborRange um / cut_enclosedCutNumNeighbor ) = cut_enclosedCutToNeighborMinSpacing "
              SPACING < cut_enclosedCutToNeighborMinSpacing
              SET_CORNERS_TO_SPACING = TRUE 
	      BOX_CORNER = FALSE 
	      NON_PARALLEL = TRUE
	      POINT_TOUCH = TRUE
              NODAL = TRUE
          } (22 )
       } else {
          EXTERNAL enclosed_cut via2  {
              COMMENT = "$layer_name EncContSpc: minimum spacing between enclosed and neighboring contacts ( cut_enclosedCutNeighborRange um / cut_enclosedCutNumNeighbor ) = cut_enclosedCutToNeighborMinSpacing "
              SPACING < cut_enclosedCutToNeighborMinSpacing
              SET_CORNERS_TO_SPACING = TRUE 
	      BOX_CORNER = FALSE 
	      NON_PARALLEL = TRUE
	      POINT_TOUCH = TRUE
          } (22 )
       }
    }
}
 
/*check max stack level, upward only*/
if (cut_maxStackLevel > 0 && cut_stackLevelSpacing > 0) {
    if (cut_maxStackLevel == 1) {
      BOOLEAN via2  AND CUT_LAYER1 { } TEMP = neighbors
    }
    else if (cut_maxStackLevel == 2) {
      BOOLEAN (via2  AND CUT_LAYER1) AND CUT_LAYER2 { } TEMP = neighbors
    }
    else if (cut_maxStackLevel == 3) {
      BOOLEAN (via2  AND CUT_LAYER1) AND (CUT_LAYER2 AND CUT_LAYER3)
        { } TEMP = neighbors
    }
    else if (cut_maxStackLevel == 4) {
      BOOLEAN ((via2  AND CUT_LAYER1) AND (CUT_LAYER2 AND CUT_LAYER3))
        AND CUT_LAYER4 { } TEMP = neighbors
    }
    else if (cut_maxStackLevel == 5) {
      BOOLEAN ((via2  AND CUT_LAYER1) AND (CUT_LAYER2 AND CUT_LAYER3))
        AND (CUT_LAYER4 AND CUT_LAYER5) { } TEMP = neighbors
    }
    else if (cut_maxStackLevel == 6) {
      BOOLEAN ((via2  AND CUT_LAYER1) AND (CUT_LAYER2 AND CUT_LAYER3))
        AND ((CUT_LAYER4 AND CUT_LAYER5) AND CUT_LAYER6) { } TEMP = neighbors
    }
    else if (cut_maxStackLevel >= 7) { 
      BOOLEAN ((via2  AND CUT_LAYER1) AND (CUT_LAYER2 AND CUT_LAYER3))
        AND ((CUT_LAYER4 AND CUT_LAYER5) AND (CUT_LAYER6 AND CUT_LAYER7))
       { } TEMP = neighbors
    }
 
    if (!layer_empty(neighbors)) {
      SELECT CUT_LAYER0 INTERACT neighbors {
        LINE_TOUCH = FALSE POINT_TOUCH = FALSE 
      } TEMP = neighbors
      EXTERNAL neighbors {
	spacing <= cut_stackLevelSpacing
      } TEMP = via_arr_ext
      if (!layer_empty (via_arr_ext)) {
	SELECT neighbors OUTSIDE via_arr_ext {
         COMMENT = "$layer_name StackLevel: maximum stack level = cut_maxStackLevel "
          LINE_TOUCH = FALSE
          POINT_TOUCH = FALSE	    
        } (22 )
      }
      else {
        BOOLEAN via2  AND neighbors {
            COMMENT = "$layer_name StackLevel: maximum stack level = cut_maxStackLevel "
        } (22 )
      }
    }
  }
  else if (cut_maxStackLevel > 0) {
    if (cut_maxStackLevel == 1) {
      COPY CUT_LAYER1 { } TEMP = neighbors
    }
    else if (cut_maxStackLevel == 2) {
      BOOLEAN CUT_LAYER1 AND CUT_LAYER2 { } TEMP = neighbors
    }
    else if (cut_maxStackLevel == 3) {
      BOOLEAN CUT_LAYER1 AND (CUT_LAYER2 AND CUT_LAYER3)
        { } TEMP = neighbors
    }
    else if (cut_maxStackLevel == 4) {
      BOOLEAN (CUT_LAYER1 AND CUT_LAYER2) AND (CUT_LAYER3 AND CUT_LAYER4)
        { } TEMP = neighbors
    }
    else if (cut_maxStackLevel == 5) {
      BOOLEAN ((CUT_LAYER1 AND CUT_LAYER2) AND (CUT_LAYER3 AND CUT_LAYER4))
        AND CUT_LAYER5 { } TEMP = neighbors
    }
    else if (cut_maxStackLevel == 6) {
      BOOLEAN ((CUT_LAYER6 AND CUT_LAYER1) AND (CUT_LAYER2 AND CUT_LAYER3))
        AND (CUT_LAYER4 AND CUT_LAYER5) { } TEMP = neighbors
    }
    else if (cut_maxStackLevel >= 7) { 
      BOOLEAN ((CUT_LAYER7 AND CUT_LAYER1) AND (CUT_LAYER2 AND CUT_LAYER3))
        AND ((CUT_LAYER4 AND CUT_LAYER5) AND CUT_LAYER6) { } TEMP = neighbors
    }
 
    if (!layer_empty (neighbors)) {
        BOOLEAN via2  AND neighbors {
            COMMENT = "$layer_name StackLevel: maximum stack level = cut_maxStackLevel "
        } (22 )
    }
}
 
/*Check fat contact*/
if (cut_fatContactMinSpacing > 0 && cut_fatTblDimension == 0) {
    if (cut_fatContactThreshold1 > 0) {
    	SIZE metal2    { UNDER_OVER = cut_fatContactThreshold1 / 2.0 - 0.0005  } TEMP = m_fat
    	BOOLEAN m_fat AND metal2  { } TEMP = m_fat
 
    	SELECT via2  INSIDE  m_fat { } TEMP = v_fat
 
    	EXTERNAL v_fat via2  {
            COMMENT = "$layer_name FatContSpc: fat contact ( cut_fatContactThreshold1 um, lower layer) minimum spacing = cut_fatContactMinSpacing um"
            SPACING < cut_fatContactMinSpacing
	    BOX_CORNER = FALSE 
	    NON_PARALLEL = TRUE
	    POINT_TOUCH = TRUE
        } (22 )
    }
 
    if (cut_fatContactThreshold2 > 0) {
    	SIZE metal3    { UNDER_OVER = cut_fatContactThreshold2 / 2.0 - 0.0005  } TEMP = m_fat
    	BOOLEAN m_fat AND metal3  { } TEMP = m_fat
 
    	SELECT via2  INSIDE  m_fat { } TEMP = v_fat
 
    	EXTERNAL v_fat via2  {
            COMMENT = "$layer_name FatContSpc: fat contact ( cut_fatContactThreshold2 um, upper layer) minimum spacing = cut_fatContactMinSpacing um"
            SPACING < cut_fatContactMinSpacing
	    BOX_CORNER = FALSE 
	    NON_PARALLEL = TRUE
	    POINT_TOUCH = TRUE
        } (22 )
    }
}
/* Avoid empty optimization result parsing error */
if (addEmptyViaCheck) {
   BOOLEAN empty OR empty {
      COMMENT = "$layer_name Empty: Dummy Output"
   } (22 )
   SET addEmptyViaCheck=0;
}
 
/* reset variables */















SET cut_size = 0;
SET cut_minSpacing = 0;
SET cut_sameNetMinSpacing = 0;
SET cut_cornerMinSpacing = 0;
SET cutBlkg_minSpacing = 0;
SET cut_maxNumAdjacentCut = 0;
SET cut_adjacentCutRange = 0;
SET cut_enclosedCutNeighborRange = 0;
SET cut_enclosedCutNumNeighbor = 0;
SET cut_enclosedCutMinSpacing = 0;
SET cut_enclosedCutToNeighborMinSpacing = 0;
SET cut_enclosedCutDiagViaExcluded = 0;
SET cut_maxStackLevel = 0;
SET cut_defaultContactMinSpacing = 0;
SET cut_fatContactThreshold1 = 0;
SET cut_fatContactThreshold2 = 0;
SET cut_fatContactMinSpacing = 0;
SET cut_maxCutSpacing = 0; 
SET cut_fatTblDimension = 0;
SET cut_fatTblThreshold_1 = 0;
SET cut_fatTblThreshold_2 = 0;
SET cut_fatTblNextThreshold_1 = 0;
SET cut_fatTblNextThreshold_2 = 0;
SET cut_fatTblMinCuts = 0;
SET cut_fatTblMinSpacing = 0;
SET cut_fatTblExtensionRange = 0;
SET cut_fatTblExtensionMinCuts = 0;
SET cut_fatTblExtensionMinSpacing = 0;
@ 463 "adrc/adrc.ev" 2











/*via 3*/
SET layer_name = "Via3";












SET cornerSpacingMode = 0;
SET cut_minSpacing = 0.14;
SET cut_fatTblDimension = 0;
@ 1 "adrc/adrc_check_via.ev" 1
/* check size */
if (cut_size > 0) {
    INTERNAL via3  {  
        COMMENT = "$layer_name Size      : contact size = cut_size um" 
	DIMENSION = [cut_size , cut_size]
    } (23 )
}
if (cut_minSpacing > 0) {
   if (ignoreContactCodeSpacing) {
      COPY via3  { } TEMP= default_via3 
   } else {
      SIZE metal3  { UNDER_OVER = cut_fatContactThreshold1 } TEMP = m_fat1
      SIZE metal4  { UNDER_OVER = cut_fatContactThreshold2 } TEMP = m_fat2
      BOOLEAN m_fat1 OR m_fat2 {} TEMP=m_fat
      SELECT via3  OUTSIDE m_fat { } TEMP= default_via3 
   }
}
 
/*check basic spacing*/
if (cut_sameNetMinSpacing > 0 && cut_sameNetMinSpacing < cut_minSpacing) {
  CONNECT { default_via3  BY via3  }
  if (cut_cornerMinSpacing > 0) {
    if (cornerSpacingMode == 1) {
        /* Work around: CONVEX_TO_CONVEX [POINT_PROJECTION] has a bug */
        EXTERNAL default_via3  {
             SPACING <= 0
             CONVEX_TO_CONVEX [POINT_PROJECTION] < cut_cornerMinSpacing
             FLAG_DISCONNECTED = FALSE
             NON_PARALLEL = TRUE
             POINT_TOUCH = TRUE
             BOX_CORNER = FALSE
        } TEMP = sameNet_corner_err1
        EXTERNAL default_via3  {
             SPACING <= 0
             CONVEX_TO_CONVEX < cut_cornerMinSpacing
             FLAG_DISCONNECTED = FALSE
             NON_PARALLEL = TRUE
             POINT_TOUCH = TRUE
             BOX_CORNER = TRUE
        } TEMP = sameNet_corner_err2 
        BOOLEAN sameNet_corner_err1 OR sameNet_corner_err2 {
             COMMENT = "$layer_name SameNetSpc: corner to corner spacing = cut_cornerMinSpacing um "
        } (23 ) 
        EXTERNAL default_via3  {
             COMMENT = "$layer_name SameNetSpc: same-net minimum spacing = cut_sameNetMinSpacing um "
             SPACING < cut_sameNetMinSpacing
             FLAG_DISCONNECTED = FALSE
             SET_CORNERS_TO_SPACING = FALSE
             PARALLEL_POINT_PROJECTION = FALSE
             NON_PARALLEL = TRUE
             TOUCH = FALSE
             POINT_TOUCH = FALSE
        } (23 )
    } else {
        EXTERNAL default_via3  {
            COMMENT = "$layer_name SameNetSpc: same-net minimum spacing = cut_sameNetMinSpacing um (corner to corner spacing = cut_cornerMinSpacing um) "
            SPACING < cut_sameNetMinSpacing
            CONVEX_TO_CONVEX < cut_cornerMinSpacing
            FLAG_DISCONNECTED = FALSE
            NON_PARALLEL = TRUE
            POINT_TOUCH = TRUE
        } (23 )
    }
  } else {
    EXTERNAL default_via3  {
        COMMENT = "$layer_name SameNetSpc: same-net minimum spacing = cut_sameNetMinSpacing um"
        SPACING < cut_sameNetMinSpacing
	BOX_CORNER = FALSE 
        FLAG_DISCONNECTED = FALSE
	NON_PARALLEL = TRUE
	POINT_TOUCH = TRUE
    } (23 )
  }
  if (cut_cornerMinSpacing > 0) {
    if (cornerSpacingMode == 1) {
        /* Work around: CONVEX_TO_CONVEX [POINT_PROJECTION] has a bug */
        EXTERNAL default_via3  {
          SPACING <= 0
          CONVEX_TO_CONVEX [POINT_PROJECTION] < cut_cornerMinSpacing
          NON_PARALLEL = TRUE
          POINT_TOUCH = TRUE
          BOX_CORNER = FALSE
          NODAL = TRUE
        } TEMP = diffNet_corner_err1 
        EXTERNAL default_via3  {
          SPACING <= 0
          CONVEX_TO_CONVEX < cut_cornerMinSpacing
          NON_PARALLEL = TRUE
          POINT_TOUCH = TRUE
          BOX_CORNER = TRUE
          NODAL = TRUE
        } TEMP = diffNet_corner_err2 
        BOOLEAN diffNet_corner_err1 OR diffNet_corner_err2 {
          COMMENT = "$layer_name Spacing   : corner to corner spacing = cut_cornerMinSpacing um "
        } (23 )
        EXTERNAL default_via3  {
          COMMENT = "$layer_name Spacing   : minimum spacing = cut_minSpacing um"
          SPACING < cut_minSpacing
          SET_CORNERS_TO_SPACING = FALSE
          PARALLEL_POINT_PROJECTION = FALSE
          NON_PARALLEL = TRUE
          TOUCH = FALSE
          POINT_TOUCH = FALSE
          NODAL = TRUE
        } (23 )
    } else {
        EXTERNAL default_via3  {
          COMMENT = "$layer_name Spacing   : minimum spacing = cut_minSpacing um (corner to corner spacing = cut_cornerMinSpacing um) "
          SPACING < cut_minSpacing
          CONVEX_TO_CONVEX < cut_cornerMinSpacing
          NON_PARALLEL = TRUE
          POINT_TOUCH = TRUE
          NODAL = TRUE
        } (23 )
    }
  } else {
    EXTERNAL default_via3  {
      COMMENT = "$layer_name Spacing   : minimum spacing = cut_minSpacing um"
      SPACING < cut_minSpacing
      BOX_CORNER = FALSE 
      NON_PARALLEL = TRUE
      POINT_TOUCH = TRUE
      NODAL = TRUE
    } (23 ) 
  }
} else {
   if (cut_minSpacing > 0) {
     if (cut_cornerMinSpacing > 0) {
        if (cornerSpacingMode == 1) {
           /* Work around: CONVEX_TO_CONVEX [POINT_PROJECTION] has a bug */
           EXTERNAL default_via3  {
             SPACING <= 0
             CONVEX_TO_CONVEX [POINT_PROJECTION] < cut_cornerMinSpacing
             NON_PARALLEL = TRUE
             POINT_TOUCH = TRUE
             BOX_CORNER = FALSE 
           } TEMP = corner_err1 
           EXTERNAL default_via3  {
             SPACING <= 0
             CONVEX_TO_CONVEX < cut_cornerMinSpacing
             NON_PARALLEL = TRUE
             POINT_TOUCH = TRUE
             BOX_CORNER = TRUE
           } TEMP = corner_err2 
           BOOLEAN corner_err1 OR corner_err2 {
             COMMENT = "$layer_name Spacing   : corner to corner spacing = cut_cornerMinSpacing um "
           } (23 )
           EXTERNAL default_via3  {
             COMMENT = "$layer_name Spacing   : minimum spacing = cut_minSpacing um"
             SPACING < cut_minSpacing
             SET_CORNERS_TO_SPACING = FALSE
             PARALLEL_POINT_PROJECTION = FALSE
             NON_PARALLEL = TRUE
             TOUCH = FALSE
             POINT_TOUCH = FALSE
           } (23 )
        } else {
           EXTERNAL default_via3  {
             COMMENT = "$layer_name Spacing   : minimum spacing = cut_minSpacing um (corner to corner spacing = cut_cornerMinSpacing um) "
             SPACING < cut_minSpacing
             CONVEX_TO_CONVEX < cut_cornerMinSpacing
             NON_PARALLEL = TRUE
             POINT_TOUCH = TRUE
           } (23 )
        }
    } else {
       EXTERNAL default_via3  {
          COMMENT = "$layer_name Spacing   : minimum spacing = cut_minSpacing um"
          SPACING < cut_minSpacing
	  BOX_CORNER = FALSE 
	  NON_PARALLEL = TRUE
	  POINT_TOUCH = TRUE
       } (23 )
    }
  }
}
 
/*check blockage spacing*/
if (ignoreBlockage == 0) {
   if (!layer_empty (via3_blockage )) {
      if (cutBlkg_minSpacing > 0) {
	  EXTERNAL via3_blockage  via3  {
              COMMENT = "$layer_name Spacing   : contact & blockage minimum spacing = cutBlkg_minSpacing um"
	      SPACING < cutBlkg_minSpacing
	      BOX_CORNER = FALSE 
	      NON_PARALLEL = TRUE
	      POINT_TOUCH = TRUE
          } (23 )
      }
   }
}
/*check blockage overlap*/ 
/*check shorts between top_level routing and fram_blockages*/
if (cutBlkg_minSpacing > 0 || checkCrossHierShort > 0) {
   if (readCellView > 0) {
       COPY empty {} TEMP = real_blockage
       COPY via3  {} TEMP = top_cut
   } else {
       COPY via3_fram  {} TEMP = real_blockage
       COPY via3_top  {} TEMP = top_cut
   }
   if (ignoreBlockage == 0) {
      BOOLEAN via3_blockage  OR real_blockage {} TEMP=all_blockage
   } else {
      COPY real_blockage {} TEMP=all_blockage
   }
   
   BOOLEAN all_blockage AND top_cut {} TEMP = overlap_shape1
   EXTERNAL all_blockage top_cut {
      SPACING <= 0
      TOUCH = TRUE
   } TEMP = overlap_shape2
   if (checkCrossHierShort > 0) {
      BOOLEAN overlap_shape1 OR overlap_shape2 {
          COMMENT = "$layer_name Short Cross Hierarchy"
      } (23 )
   } else {
      BOOLEAN overlap_shape1 OR overlap_shape2 {
          COMMENT = "$layer_name Overlap   : cut & blockage overlap"
      } (23 )
   }
}
/*check adjacent via number*/
if (cut_adjacentCutRange > 0 && cut_maxNumAdjacentCut > 0) {
    if (router_ignoreSameNetAdjacentViaDRC) {
       EXTERNAL via3  {  
	   SPACING < cut_adjacentCutRange
	   SET_CORNERS_TO_SPACING = FALSE
	   PARALLEL_POINT_PROJECTION = FALSE
	   NON_PARALLEL = TRUE
	   BOX_CORNER = FALSE
	   SHADOW = FALSE
           NODAL = TRUE
       } TEMP=edge_spacing
       EXTERNAL via3  {
	   SPACING < 0
	   CONVEX_TO_EDGE < cut_adjacentCutRange
	   CONVEX_TO_CONVEX < cut_adjacentCutRange
	   BOX_CORNER = FALSE
	   SHADOW = FALSE
           NODAL = TRUE
       } TEMP=corner_spacing
    } else {
       EXTERNAL via3  {  
	   SPACING < cut_adjacentCutRange
	   SET_CORNERS_TO_SPACING = FALSE
	   PARALLEL_POINT_PROJECTION = FALSE
	   NON_PARALLEL = TRUE
	   BOX_CORNER = FALSE
	   SHADOW = FALSE
       } TEMP=edge_spacing
 
       EXTERNAL via3  {
	   SPACING < 0
	   CONVEX_TO_EDGE < cut_adjacentCutRange
	   CONVEX_TO_CONVEX < cut_adjacentCutRange
	   BOX_CORNER = FALSE
	   SHADOW = FALSE
       } TEMP=corner_spacing
    }
    SIZE edge_spacing { UNDERSIZE = 0.001  } TEMP = edge_spacing1
    SIZE edge_spacing1 { OVERSIZE = 0.001  } TEMP = edge_spacing2
    BOOLEAN (edge_spacing NOT edge_spacing2) OR edge_spacing1 { } TEMP=edge_spacing
 
    SIZE corner_spacing { UNDERSIZE = 0.001  } TEMP = corner_spacing1
    SIZE corner_spacing1 { OVERSIZE = 0.001  } TEMP = corner_spacing2
    BOOLEAN (corner_spacing NOT corner_spacing2) OR corner_spacing1 { } TEMP=corner_spacing
  
    BOOLEAN edge_spacing OR corner_spacing { } TEMP = spacing
 
    SIZE via3  { OVERSIZE = 5* 0.001  } TEMP = cut
 
    SELECT cut INTERACT spacing {
        POINT_TOUCH = TRUE
        RANGE = [cut_maxNumAdjacentCut + 1, 9999999999 ]
    } TEMP = enclosed_cut
 
    SELECT via3  INSIDE enclosed_cut {
        COMMENT = "$layer_name AdjContNum: maximum number of the adjacent contacts ( cut_adjacentCutRange um) = cut_maxNumAdjacentCut "
    } (23 )
}
 
/*check enclosed via spacing*/
if (cut_enclosedCutNeighborRange > 0 && cut_enclosedCutNumNeighbor > 0) {
    if (cut_enclosedCutDiagViaExcluded) {
       EXTERNAL via3  {
          SPACING < cut_enclosedCutNeighborRange
          SET_CORNERS_TO_SPACING = FALSE
          PARALLEL_POINT_PROJECTION = FALSE
          NON_PARALLEL = TRUE
          BOX_CORNER = FALSE
          SHADOW = FALSE
       } TEMP = edge_spacing
       SELECT via3  TOUCHING edge_spacing {
          RANGE = [cut_enclosedCutNumNeighbor, 9999999999 ]
       } TEMP = enclosed_cut
    } else {
       /* Work around: for SIZE_RECT FLAG_INTERACTION_COUNT parser bug */
       
@ 308 "adrc/adrc_check_via.ev"
       if (cut_enclosedCutNumNeighbor==1) {
          
@-         SIZE_RECT via3  { 
@-            RANGE1=[0, 10] 
@-            RANGE2=[0, 10] 
@-            RANGE1_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0005 ) 
@-            RANGE2_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0005 ) 
@-            FLAG_INTERACTION_COUNT >  0  
@-            CORNER_METHOD = RADIAL 
@-         } TEMP=enclosed_cut 
       } else if (cut_enclosedCutNumNeighbor==2) {
          
@-         SIZE_RECT via3  { 
@-            RANGE1=[0, 10] 
@-            RANGE2=[0, 10] 
@-            RANGE1_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0005 ) 
@-            RANGE2_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0005 ) 
@-            FLAG_INTERACTION_COUNT >  1  
@-            CORNER_METHOD = RADIAL 
@-         } TEMP=enclosed_cut 
       } else if (cut_enclosedCutNumNeighbor==3) {
          
@-         SIZE_RECT via3  { 
@-            RANGE1=[0, 10] 
@-            RANGE2=[0, 10] 
@-            RANGE1_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0005 ) 
@-            RANGE2_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0005 ) 
@-            FLAG_INTERACTION_COUNT >  2  
@-            CORNER_METHOD = RADIAL 
@-         } TEMP=enclosed_cut 
       } else if (cut_enclosedCutNumNeighbor==4) {
          
@-         SIZE_RECT via3  { 
@-            RANGE1=[0, 10] 
@-            RANGE2=[0, 10] 
@-            RANGE1_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0005 ) 
@-            RANGE2_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0005 ) 
@-            FLAG_INTERACTION_COUNT >  3  
@-            CORNER_METHOD = RADIAL 
@-         } TEMP=enclosed_cut 
       } else if (cut_enclosedCutNumNeighbor==5) {
          
@-         SIZE_RECT via3  { 
@-            RANGE1=[0, 10] 
@-            RANGE2=[0, 10] 
@-            RANGE1_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0005 ) 
@-            RANGE2_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0005 ) 
@-            FLAG_INTERACTION_COUNT >  4  
@-            CORNER_METHOD = RADIAL 
@-         } TEMP=enclosed_cut 
       } else if (cut_enclosedCutNumNeighbor==6) {
          
@-         SIZE_RECT via3  { 
@-            RANGE1=[0, 10] 
@-            RANGE2=[0, 10] 
@-            RANGE1_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0005 ) 
@-            RANGE2_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0005 ) 
@-            FLAG_INTERACTION_COUNT >  5  
@-            CORNER_METHOD = RADIAL 
@-         } TEMP=enclosed_cut 
       } else if (cut_enclosedCutNumNeighbor==7) {
          
@-         SIZE_RECT via3  { 
@-            RANGE1=[0, 10] 
@-            RANGE2=[0, 10] 
@-            RANGE1_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0005 ) 
@-            RANGE2_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0005 ) 
@-            FLAG_INTERACTION_COUNT >  6  
@-            CORNER_METHOD = RADIAL 
@-         } TEMP=enclosed_cut 
       } else if (cut_enclosedCutNumNeighbor==8) {
          
@-         SIZE_RECT via3  { 
@-            RANGE1=[0, 10] 
@-            RANGE2=[0, 10] 
@-            RANGE1_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0005 ) 
@-            RANGE2_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0005 ) 
@-            FLAG_INTERACTION_COUNT >  7  
@-            CORNER_METHOD = RADIAL 
@-         } TEMP=enclosed_cut 
       } else if (cut_enclosedCutNumNeighbor==9) {
          
@-         SIZE_RECT via3  { 
@-            RANGE1=[0, 10] 
@-            RANGE2=[0, 10] 
@-            RANGE1_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0005 ) 
@-            RANGE2_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0005 ) 
@-            FLAG_INTERACTION_COUNT >  8  
@-            CORNER_METHOD = RADIAL 
@-         } TEMP=enclosed_cut 
       } else if (cut_enclosedCutNumNeighbor>9) {
          
@-         SIZE_RECT via3  { 
@-            RANGE1=[0, 10] 
@-            RANGE2=[0, 10] 
@-            RANGE1_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0005 ) 
@-            RANGE2_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0005 ) 
@-            FLAG_INTERACTION_COUNT >  9  
@-            CORNER_METHOD = RADIAL 
@-         } TEMP=enclosed_cut 
       }
    }
    if (router_ignoreSameNetAdjacentViaDRC) {
      /* Good approximation for same net via filter */
      CENTER_TO_CENTER via3  {
        NODAL=TRUE
        SPACING < cut_enclosedCutNeighborRange + 1.41421*cut_size + 0.0005 
        OUTPUT_VECTOR = TRUE
      } TEMP = c2c_spacing
      SIZE via3  { UNDERSIZE = (cut_size/2.0- 0.0005 ) } TEMP=cut_center
      BOOLEAN c2c_spacing NOT cut_center { } TEMP=c2c_spacing
      SIZE cut_center { OVERSIZE = 0.001  } TEMP=cut_center
      BOOLEAN c2c_spacing AND via3   { } TEMP=c2c_filter
      SELECT cut_center INTERACT c2c_filter {
        POINT_TOUCH=TRUE
        RANGE = [cut_enclosedCutNumNeighbor, 9999999999 ]
      } TEMP = target_cut
   
      SELECT enclosed_cut ENCLOSING target_cut { } TEMP = enclosed_cut
    }
  
    if (cut_enclosedCutMinSpacing > 0) {
        EXTERNAL enclosed_cut {
        COMMENT = "$layer_name EncContSpc: minimum spacing between enclosed contacts ( cut_enclosedCutNeighborRange um / cut_enclosedCutNumNeighbor ) = cut_enclosedCutMinSpacing "
            SPACING < cut_enclosedCutMinSpacing
            SET_CORNERS_TO_SPACING = TRUE 
	    BOX_CORNER = FALSE 
	    NON_PARALLEL = TRUE
	    POINT_TOUCH = TRUE
        } (23 )
    }
 
    if (cut_enclosedCutToNeighborMinSpacing > 0) {
       if (router_ignoreSameNetAdjacentViaDRC) {
          CONNECT { enclosed_cut BY via3  }
          EXTERNAL enclosed_cut via3  {
              COMMENT = "$layer_name EncContSpc: minimum spacing between enclosed and neighboring contacts ( cut_enclosedCutNeighborRange um / cut_enclosedCutNumNeighbor ) = cut_enclosedCutToNeighborMinSpacing "
              SPACING < cut_enclosedCutToNeighborMinSpacing
              SET_CORNERS_TO_SPACING = TRUE 
	      BOX_CORNER = FALSE 
	      NON_PARALLEL = TRUE
	      POINT_TOUCH = TRUE
              NODAL = TRUE
          } (23 )
       } else {
          EXTERNAL enclosed_cut via3  {
              COMMENT = "$layer_name EncContSpc: minimum spacing between enclosed and neighboring contacts ( cut_enclosedCutNeighborRange um / cut_enclosedCutNumNeighbor ) = cut_enclosedCutToNeighborMinSpacing "
              SPACING < cut_enclosedCutToNeighborMinSpacing
              SET_CORNERS_TO_SPACING = TRUE 
	      BOX_CORNER = FALSE 
	      NON_PARALLEL = TRUE
	      POINT_TOUCH = TRUE
          } (23 )
       }
    }
}
 
/*check max stack level, upward only*/
if (cut_maxStackLevel > 0 && cut_stackLevelSpacing > 0) {
    if (cut_maxStackLevel == 1) {
      BOOLEAN via3  AND CUT_LAYER1 { } TEMP = neighbors
    }
    else if (cut_maxStackLevel == 2) {
      BOOLEAN (via3  AND CUT_LAYER1) AND CUT_LAYER2 { } TEMP = neighbors
    }
    else if (cut_maxStackLevel == 3) {
      BOOLEAN (via3  AND CUT_LAYER1) AND (CUT_LAYER2 AND CUT_LAYER3)
        { } TEMP = neighbors
    }
    else if (cut_maxStackLevel == 4) {
      BOOLEAN ((via3  AND CUT_LAYER1) AND (CUT_LAYER2 AND CUT_LAYER3))
        AND CUT_LAYER4 { } TEMP = neighbors
    }
    else if (cut_maxStackLevel == 5) {
      BOOLEAN ((via3  AND CUT_LAYER1) AND (CUT_LAYER2 AND CUT_LAYER3))
        AND (CUT_LAYER4 AND CUT_LAYER5) { } TEMP = neighbors
    }
    else if (cut_maxStackLevel == 6) {
      BOOLEAN ((via3  AND CUT_LAYER1) AND (CUT_LAYER2 AND CUT_LAYER3))
        AND ((CUT_LAYER4 AND CUT_LAYER5) AND CUT_LAYER6) { } TEMP = neighbors
    }
    else if (cut_maxStackLevel >= 7) { 
      BOOLEAN ((via3  AND CUT_LAYER1) AND (CUT_LAYER2 AND CUT_LAYER3))
        AND ((CUT_LAYER4 AND CUT_LAYER5) AND (CUT_LAYER6 AND CUT_LAYER7))
       { } TEMP = neighbors
    }
 
    if (!layer_empty(neighbors)) {
      SELECT CUT_LAYER0 INTERACT neighbors {
        LINE_TOUCH = FALSE POINT_TOUCH = FALSE 
      } TEMP = neighbors
      EXTERNAL neighbors {
	spacing <= cut_stackLevelSpacing
      } TEMP = via_arr_ext
      if (!layer_empty (via_arr_ext)) {
	SELECT neighbors OUTSIDE via_arr_ext {
         COMMENT = "$layer_name StackLevel: maximum stack level = cut_maxStackLevel "
          LINE_TOUCH = FALSE
          POINT_TOUCH = FALSE	    
        } (23 )
      }
      else {
        BOOLEAN via3  AND neighbors {
            COMMENT = "$layer_name StackLevel: maximum stack level = cut_maxStackLevel "
        } (23 )
      }
    }
  }
  else if (cut_maxStackLevel > 0) {
    if (cut_maxStackLevel == 1) {
      COPY CUT_LAYER1 { } TEMP = neighbors
    }
    else if (cut_maxStackLevel == 2) {
      BOOLEAN CUT_LAYER1 AND CUT_LAYER2 { } TEMP = neighbors
    }
    else if (cut_maxStackLevel == 3) {
      BOOLEAN CUT_LAYER1 AND (CUT_LAYER2 AND CUT_LAYER3)
        { } TEMP = neighbors
    }
    else if (cut_maxStackLevel == 4) {
      BOOLEAN (CUT_LAYER1 AND CUT_LAYER2) AND (CUT_LAYER3 AND CUT_LAYER4)
        { } TEMP = neighbors
    }
    else if (cut_maxStackLevel == 5) {
      BOOLEAN ((CUT_LAYER1 AND CUT_LAYER2) AND (CUT_LAYER3 AND CUT_LAYER4))
        AND CUT_LAYER5 { } TEMP = neighbors
    }
    else if (cut_maxStackLevel == 6) {
      BOOLEAN ((CUT_LAYER6 AND CUT_LAYER1) AND (CUT_LAYER2 AND CUT_LAYER3))
        AND (CUT_LAYER4 AND CUT_LAYER5) { } TEMP = neighbors
    }
    else if (cut_maxStackLevel >= 7) { 
      BOOLEAN ((CUT_LAYER7 AND CUT_LAYER1) AND (CUT_LAYER2 AND CUT_LAYER3))
        AND ((CUT_LAYER4 AND CUT_LAYER5) AND CUT_LAYER6) { } TEMP = neighbors
    }
 
    if (!layer_empty (neighbors)) {
        BOOLEAN via3  AND neighbors {
            COMMENT = "$layer_name StackLevel: maximum stack level = cut_maxStackLevel "
        } (23 )
    }
}
 
/*Check fat contact*/
if (cut_fatContactMinSpacing > 0 && cut_fatTblDimension == 0) {
    if (cut_fatContactThreshold1 > 0) {
    	SIZE metal3    { UNDER_OVER = cut_fatContactThreshold1 / 2.0 - 0.0005  } TEMP = m_fat
    	BOOLEAN m_fat AND metal3  { } TEMP = m_fat
 
    	SELECT via3  INSIDE  m_fat { } TEMP = v_fat
 
    	EXTERNAL v_fat via3  {
            COMMENT = "$layer_name FatContSpc: fat contact ( cut_fatContactThreshold1 um, lower layer) minimum spacing = cut_fatContactMinSpacing um"
            SPACING < cut_fatContactMinSpacing
	    BOX_CORNER = FALSE 
	    NON_PARALLEL = TRUE
	    POINT_TOUCH = TRUE
        } (23 )
    }
 
    if (cut_fatContactThreshold2 > 0) {
    	SIZE metal4    { UNDER_OVER = cut_fatContactThreshold2 / 2.0 - 0.0005  } TEMP = m_fat
    	BOOLEAN m_fat AND metal4  { } TEMP = m_fat
 
    	SELECT via3  INSIDE  m_fat { } TEMP = v_fat
 
    	EXTERNAL v_fat via3  {
            COMMENT = "$layer_name FatContSpc: fat contact ( cut_fatContactThreshold2 um, upper layer) minimum spacing = cut_fatContactMinSpacing um"
            SPACING < cut_fatContactMinSpacing
	    BOX_CORNER = FALSE 
	    NON_PARALLEL = TRUE
	    POINT_TOUCH = TRUE
        } (23 )
    }
}
/* Avoid empty optimization result parsing error */
if (addEmptyViaCheck) {
   BOOLEAN empty OR empty {
      COMMENT = "$layer_name Empty: Dummy Output"
   } (23 )
   SET addEmptyViaCheck=0;
}
 
/* reset variables */















SET cut_size = 0;
SET cut_minSpacing = 0;
SET cut_sameNetMinSpacing = 0;
SET cut_cornerMinSpacing = 0;
SET cutBlkg_minSpacing = 0;
SET cut_maxNumAdjacentCut = 0;
SET cut_adjacentCutRange = 0;
SET cut_enclosedCutNeighborRange = 0;
SET cut_enclosedCutNumNeighbor = 0;
SET cut_enclosedCutMinSpacing = 0;
SET cut_enclosedCutToNeighborMinSpacing = 0;
SET cut_enclosedCutDiagViaExcluded = 0;
SET cut_maxStackLevel = 0;
SET cut_defaultContactMinSpacing = 0;
SET cut_fatContactThreshold1 = 0;
SET cut_fatContactThreshold2 = 0;
SET cut_fatContactMinSpacing = 0;
SET cut_maxCutSpacing = 0; 
SET cut_fatTblDimension = 0;
SET cut_fatTblThreshold_1 = 0;
SET cut_fatTblThreshold_2 = 0;
SET cut_fatTblNextThreshold_1 = 0;
SET cut_fatTblNextThreshold_2 = 0;
SET cut_fatTblMinCuts = 0;
SET cut_fatTblMinSpacing = 0;
SET cut_fatTblExtensionRange = 0;
SET cut_fatTblExtensionMinCuts = 0;
SET cut_fatTblExtensionMinSpacing = 0;
@ 491 "adrc/adrc.ev" 2











/*via 4*/
SET layer_name = "Via4";












SET cornerSpacingMode = 0;
SET cut_minSpacing = 0.14;
SET cut_fatTblDimension = 0;
@ 1 "adrc/adrc_check_via.ev" 1
/* check size */
if (cut_size > 0) {
    INTERNAL via4  {  
        COMMENT = "$layer_name Size      : contact size = cut_size um" 
	DIMENSION = [cut_size , cut_size]
    } (24 )
}
if (cut_minSpacing > 0) {
   if (ignoreContactCodeSpacing) {
      COPY via4  { } TEMP= default_via4 
   } else {
      SIZE metal4  { UNDER_OVER = cut_fatContactThreshold1 } TEMP = m_fat1
      SIZE metal5  { UNDER_OVER = cut_fatContactThreshold2 } TEMP = m_fat2
      BOOLEAN m_fat1 OR m_fat2 {} TEMP=m_fat
      SELECT via4  OUTSIDE m_fat { } TEMP= default_via4 
   }
}
 
/*check basic spacing*/
if (cut_sameNetMinSpacing > 0 && cut_sameNetMinSpacing < cut_minSpacing) {
  CONNECT { default_via4  BY via4  }
  if (cut_cornerMinSpacing > 0) {
    if (cornerSpacingMode == 1) {
        /* Work around: CONVEX_TO_CONVEX [POINT_PROJECTION] has a bug */
        EXTERNAL default_via4  {
             SPACING <= 0
             CONVEX_TO_CONVEX [POINT_PROJECTION] < cut_cornerMinSpacing
             FLAG_DISCONNECTED = FALSE
             NON_PARALLEL = TRUE
             POINT_TOUCH = TRUE
             BOX_CORNER = FALSE
        } TEMP = sameNet_corner_err1
        EXTERNAL default_via4  {
             SPACING <= 0
             CONVEX_TO_CONVEX < cut_cornerMinSpacing
             FLAG_DISCONNECTED = FALSE
             NON_PARALLEL = TRUE
             POINT_TOUCH = TRUE
             BOX_CORNER = TRUE
        } TEMP = sameNet_corner_err2 
        BOOLEAN sameNet_corner_err1 OR sameNet_corner_err2 {
             COMMENT = "$layer_name SameNetSpc: corner to corner spacing = cut_cornerMinSpacing um "
        } (24 ) 
        EXTERNAL default_via4  {
             COMMENT = "$layer_name SameNetSpc: same-net minimum spacing = cut_sameNetMinSpacing um "
             SPACING < cut_sameNetMinSpacing
             FLAG_DISCONNECTED = FALSE
             SET_CORNERS_TO_SPACING = FALSE
             PARALLEL_POINT_PROJECTION = FALSE
             NON_PARALLEL = TRUE
             TOUCH = FALSE
             POINT_TOUCH = FALSE
        } (24 )
    } else {
        EXTERNAL default_via4  {
            COMMENT = "$layer_name SameNetSpc: same-net minimum spacing = cut_sameNetMinSpacing um (corner to corner spacing = cut_cornerMinSpacing um) "
            SPACING < cut_sameNetMinSpacing
            CONVEX_TO_CONVEX < cut_cornerMinSpacing
            FLAG_DISCONNECTED = FALSE
            NON_PARALLEL = TRUE
            POINT_TOUCH = TRUE
        } (24 )
    }
  } else {
    EXTERNAL default_via4  {
        COMMENT = "$layer_name SameNetSpc: same-net minimum spacing = cut_sameNetMinSpacing um"
        SPACING < cut_sameNetMinSpacing
	BOX_CORNER = FALSE 
        FLAG_DISCONNECTED = FALSE
	NON_PARALLEL = TRUE
	POINT_TOUCH = TRUE
    } (24 )
  }
  if (cut_cornerMinSpacing > 0) {
    if (cornerSpacingMode == 1) {
        /* Work around: CONVEX_TO_CONVEX [POINT_PROJECTION] has a bug */
        EXTERNAL default_via4  {
          SPACING <= 0
          CONVEX_TO_CONVEX [POINT_PROJECTION] < cut_cornerMinSpacing
          NON_PARALLEL = TRUE
          POINT_TOUCH = TRUE
          BOX_CORNER = FALSE
          NODAL = TRUE
        } TEMP = diffNet_corner_err1 
        EXTERNAL default_via4  {
          SPACING <= 0
          CONVEX_TO_CONVEX < cut_cornerMinSpacing
          NON_PARALLEL = TRUE
          POINT_TOUCH = TRUE
          BOX_CORNER = TRUE
          NODAL = TRUE
        } TEMP = diffNet_corner_err2 
        BOOLEAN diffNet_corner_err1 OR diffNet_corner_err2 {
          COMMENT = "$layer_name Spacing   : corner to corner spacing = cut_cornerMinSpacing um "
        } (24 )
        EXTERNAL default_via4  {
          COMMENT = "$layer_name Spacing   : minimum spacing = cut_minSpacing um"
          SPACING < cut_minSpacing
          SET_CORNERS_TO_SPACING = FALSE
          PARALLEL_POINT_PROJECTION = FALSE
          NON_PARALLEL = TRUE
          TOUCH = FALSE
          POINT_TOUCH = FALSE
          NODAL = TRUE
        } (24 )
    } else {
        EXTERNAL default_via4  {
          COMMENT = "$layer_name Spacing   : minimum spacing = cut_minSpacing um (corner to corner spacing = cut_cornerMinSpacing um) "
          SPACING < cut_minSpacing
          CONVEX_TO_CONVEX < cut_cornerMinSpacing
          NON_PARALLEL = TRUE
          POINT_TOUCH = TRUE
          NODAL = TRUE
        } (24 )
    }
  } else {
    EXTERNAL default_via4  {
      COMMENT = "$layer_name Spacing   : minimum spacing = cut_minSpacing um"
      SPACING < cut_minSpacing
      BOX_CORNER = FALSE 
      NON_PARALLEL = TRUE
      POINT_TOUCH = TRUE
      NODAL = TRUE
    } (24 ) 
  }
} else {
   if (cut_minSpacing > 0) {
     if (cut_cornerMinSpacing > 0) {
        if (cornerSpacingMode == 1) {
           /* Work around: CONVEX_TO_CONVEX [POINT_PROJECTION] has a bug */
           EXTERNAL default_via4  {
             SPACING <= 0
             CONVEX_TO_CONVEX [POINT_PROJECTION] < cut_cornerMinSpacing
             NON_PARALLEL = TRUE
             POINT_TOUCH = TRUE
             BOX_CORNER = FALSE 
           } TEMP = corner_err1 
           EXTERNAL default_via4  {
             SPACING <= 0
             CONVEX_TO_CONVEX < cut_cornerMinSpacing
             NON_PARALLEL = TRUE
             POINT_TOUCH = TRUE
             BOX_CORNER = TRUE
           } TEMP = corner_err2 
           BOOLEAN corner_err1 OR corner_err2 {
             COMMENT = "$layer_name Spacing   : corner to corner spacing = cut_cornerMinSpacing um "
           } (24 )
           EXTERNAL default_via4  {
             COMMENT = "$layer_name Spacing   : minimum spacing = cut_minSpacing um"
             SPACING < cut_minSpacing
             SET_CORNERS_TO_SPACING = FALSE
             PARALLEL_POINT_PROJECTION = FALSE
             NON_PARALLEL = TRUE
             TOUCH = FALSE
             POINT_TOUCH = FALSE
           } (24 )
        } else {
           EXTERNAL default_via4  {
             COMMENT = "$layer_name Spacing   : minimum spacing = cut_minSpacing um (corner to corner spacing = cut_cornerMinSpacing um) "
             SPACING < cut_minSpacing
             CONVEX_TO_CONVEX < cut_cornerMinSpacing
             NON_PARALLEL = TRUE
             POINT_TOUCH = TRUE
           } (24 )
        }
    } else {
       EXTERNAL default_via4  {
          COMMENT = "$layer_name Spacing   : minimum spacing = cut_minSpacing um"
          SPACING < cut_minSpacing
	  BOX_CORNER = FALSE 
	  NON_PARALLEL = TRUE
	  POINT_TOUCH = TRUE
       } (24 )
    }
  }
}
 
/*check blockage spacing*/
if (ignoreBlockage == 0) {
   if (!layer_empty (via4_blockage )) {
      if (cutBlkg_minSpacing > 0) {
	  EXTERNAL via4_blockage  via4  {
              COMMENT = "$layer_name Spacing   : contact & blockage minimum spacing = cutBlkg_minSpacing um"
	      SPACING < cutBlkg_minSpacing
	      BOX_CORNER = FALSE 
	      NON_PARALLEL = TRUE
	      POINT_TOUCH = TRUE
          } (24 )
      }
   }
}
/*check blockage overlap*/ 
/*check shorts between top_level routing and fram_blockages*/
if (cutBlkg_minSpacing > 0 || checkCrossHierShort > 0) {
   if (readCellView > 0) {
       COPY empty {} TEMP = real_blockage
       COPY via4  {} TEMP = top_cut
   } else {
       COPY via4_fram  {} TEMP = real_blockage
       COPY via4_top  {} TEMP = top_cut
   }
   if (ignoreBlockage == 0) {
      BOOLEAN via4_blockage  OR real_blockage {} TEMP=all_blockage
   } else {
      COPY real_blockage {} TEMP=all_blockage
   }
   
   BOOLEAN all_blockage AND top_cut {} TEMP = overlap_shape1
   EXTERNAL all_blockage top_cut {
      SPACING <= 0
      TOUCH = TRUE
   } TEMP = overlap_shape2
   if (checkCrossHierShort > 0) {
      BOOLEAN overlap_shape1 OR overlap_shape2 {
          COMMENT = "$layer_name Short Cross Hierarchy"
      } (24 )
   } else {
      BOOLEAN overlap_shape1 OR overlap_shape2 {
          COMMENT = "$layer_name Overlap   : cut & blockage overlap"
      } (24 )
   }
}
/*check adjacent via number*/
if (cut_adjacentCutRange > 0 && cut_maxNumAdjacentCut > 0) {
    if (router_ignoreSameNetAdjacentViaDRC) {
       EXTERNAL via4  {  
	   SPACING < cut_adjacentCutRange
	   SET_CORNERS_TO_SPACING = FALSE
	   PARALLEL_POINT_PROJECTION = FALSE
	   NON_PARALLEL = TRUE
	   BOX_CORNER = FALSE
	   SHADOW = FALSE
           NODAL = TRUE
       } TEMP=edge_spacing
       EXTERNAL via4  {
	   SPACING < 0
	   CONVEX_TO_EDGE < cut_adjacentCutRange
	   CONVEX_TO_CONVEX < cut_adjacentCutRange
	   BOX_CORNER = FALSE
	   SHADOW = FALSE
           NODAL = TRUE
       } TEMP=corner_spacing
    } else {
       EXTERNAL via4  {  
	   SPACING < cut_adjacentCutRange
	   SET_CORNERS_TO_SPACING = FALSE
	   PARALLEL_POINT_PROJECTION = FALSE
	   NON_PARALLEL = TRUE
	   BOX_CORNER = FALSE
	   SHADOW = FALSE
       } TEMP=edge_spacing
 
       EXTERNAL via4  {
	   SPACING < 0
	   CONVEX_TO_EDGE < cut_adjacentCutRange
	   CONVEX_TO_CONVEX < cut_adjacentCutRange
	   BOX_CORNER = FALSE
	   SHADOW = FALSE
       } TEMP=corner_spacing
    }
    SIZE edge_spacing { UNDERSIZE = 0.001  } TEMP = edge_spacing1
    SIZE edge_spacing1 { OVERSIZE = 0.001  } TEMP = edge_spacing2
    BOOLEAN (edge_spacing NOT edge_spacing2) OR edge_spacing1 { } TEMP=edge_spacing
 
    SIZE corner_spacing { UNDERSIZE = 0.001  } TEMP = corner_spacing1
    SIZE corner_spacing1 { OVERSIZE = 0.001  } TEMP = corner_spacing2
    BOOLEAN (corner_spacing NOT corner_spacing2) OR corner_spacing1 { } TEMP=corner_spacing
  
    BOOLEAN edge_spacing OR corner_spacing { } TEMP = spacing
 
    SIZE via4  { OVERSIZE = 5* 0.001  } TEMP = cut
 
    SELECT cut INTERACT spacing {
        POINT_TOUCH = TRUE
        RANGE = [cut_maxNumAdjacentCut + 1, 9999999999 ]
    } TEMP = enclosed_cut
 
    SELECT via4  INSIDE enclosed_cut {
        COMMENT = "$layer_name AdjContNum: maximum number of the adjacent contacts ( cut_adjacentCutRange um) = cut_maxNumAdjacentCut "
    } (24 )
}
 
/*check enclosed via spacing*/
if (cut_enclosedCutNeighborRange > 0 && cut_enclosedCutNumNeighbor > 0) {
    if (cut_enclosedCutDiagViaExcluded) {
       EXTERNAL via4  {
          SPACING < cut_enclosedCutNeighborRange
          SET_CORNERS_TO_SPACING = FALSE
          PARALLEL_POINT_PROJECTION = FALSE
          NON_PARALLEL = TRUE
          BOX_CORNER = FALSE
          SHADOW = FALSE
       } TEMP = edge_spacing
       SELECT via4  TOUCHING edge_spacing {
          RANGE = [cut_enclosedCutNumNeighbor, 9999999999 ]
       } TEMP = enclosed_cut
    } else {
       /* Work around: for SIZE_RECT FLAG_INTERACTION_COUNT parser bug */
       
@ 308 "adrc/adrc_check_via.ev"
       if (cut_enclosedCutNumNeighbor==1) {
          
@-         SIZE_RECT via4  { 
@-            RANGE1=[0, 10] 
@-            RANGE2=[0, 10] 
@-            RANGE1_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0005 ) 
@-            RANGE2_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0005 ) 
@-            FLAG_INTERACTION_COUNT >  0  
@-            CORNER_METHOD = RADIAL 
@-         } TEMP=enclosed_cut 
       } else if (cut_enclosedCutNumNeighbor==2) {
          
@-         SIZE_RECT via4  { 
@-            RANGE1=[0, 10] 
@-            RANGE2=[0, 10] 
@-            RANGE1_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0005 ) 
@-            RANGE2_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0005 ) 
@-            FLAG_INTERACTION_COUNT >  1  
@-            CORNER_METHOD = RADIAL 
@-         } TEMP=enclosed_cut 
       } else if (cut_enclosedCutNumNeighbor==3) {
          
@-         SIZE_RECT via4  { 
@-            RANGE1=[0, 10] 
@-            RANGE2=[0, 10] 
@-            RANGE1_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0005 ) 
@-            RANGE2_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0005 ) 
@-            FLAG_INTERACTION_COUNT >  2  
@-            CORNER_METHOD = RADIAL 
@-         } TEMP=enclosed_cut 
       } else if (cut_enclosedCutNumNeighbor==4) {
          
@-         SIZE_RECT via4  { 
@-            RANGE1=[0, 10] 
@-            RANGE2=[0, 10] 
@-            RANGE1_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0005 ) 
@-            RANGE2_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0005 ) 
@-            FLAG_INTERACTION_COUNT >  3  
@-            CORNER_METHOD = RADIAL 
@-         } TEMP=enclosed_cut 
       } else if (cut_enclosedCutNumNeighbor==5) {
          
@-         SIZE_RECT via4  { 
@-            RANGE1=[0, 10] 
@-            RANGE2=[0, 10] 
@-            RANGE1_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0005 ) 
@-            RANGE2_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0005 ) 
@-            FLAG_INTERACTION_COUNT >  4  
@-            CORNER_METHOD = RADIAL 
@-         } TEMP=enclosed_cut 
       } else if (cut_enclosedCutNumNeighbor==6) {
          
@-         SIZE_RECT via4  { 
@-            RANGE1=[0, 10] 
@-            RANGE2=[0, 10] 
@-            RANGE1_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0005 ) 
@-            RANGE2_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0005 ) 
@-            FLAG_INTERACTION_COUNT >  5  
@-            CORNER_METHOD = RADIAL 
@-         } TEMP=enclosed_cut 
       } else if (cut_enclosedCutNumNeighbor==7) {
          
@-         SIZE_RECT via4  { 
@-            RANGE1=[0, 10] 
@-            RANGE2=[0, 10] 
@-            RANGE1_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0005 ) 
@-            RANGE2_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0005 ) 
@-            FLAG_INTERACTION_COUNT >  6  
@-            CORNER_METHOD = RADIAL 
@-         } TEMP=enclosed_cut 
       } else if (cut_enclosedCutNumNeighbor==8) {
          
@-         SIZE_RECT via4  { 
@-            RANGE1=[0, 10] 
@-            RANGE2=[0, 10] 
@-            RANGE1_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0005 ) 
@-            RANGE2_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0005 ) 
@-            FLAG_INTERACTION_COUNT >  7  
@-            CORNER_METHOD = RADIAL 
@-         } TEMP=enclosed_cut 
       } else if (cut_enclosedCutNumNeighbor==9) {
          
@-         SIZE_RECT via4  { 
@-            RANGE1=[0, 10] 
@-            RANGE2=[0, 10] 
@-            RANGE1_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0005 ) 
@-            RANGE2_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0005 ) 
@-            FLAG_INTERACTION_COUNT >  8  
@-            CORNER_METHOD = RADIAL 
@-         } TEMP=enclosed_cut 
       } else if (cut_enclosedCutNumNeighbor>9) {
          
@-         SIZE_RECT via4  { 
@-            RANGE1=[0, 10] 
@-            RANGE2=[0, 10] 
@-            RANGE1_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0005 ) 
@-            RANGE2_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0005 ) 
@-            FLAG_INTERACTION_COUNT >  9  
@-            CORNER_METHOD = RADIAL 
@-         } TEMP=enclosed_cut 
       }
    }
    if (router_ignoreSameNetAdjacentViaDRC) {
      /* Good approximation for same net via filter */
      CENTER_TO_CENTER via4  {
        NODAL=TRUE
        SPACING < cut_enclosedCutNeighborRange + 1.41421*cut_size + 0.0005 
        OUTPUT_VECTOR = TRUE
      } TEMP = c2c_spacing
      SIZE via4  { UNDERSIZE = (cut_size/2.0- 0.0005 ) } TEMP=cut_center
      BOOLEAN c2c_spacing NOT cut_center { } TEMP=c2c_spacing
      SIZE cut_center { OVERSIZE = 0.001  } TEMP=cut_center
      BOOLEAN c2c_spacing AND via4   { } TEMP=c2c_filter
      SELECT cut_center INTERACT c2c_filter {
        POINT_TOUCH=TRUE
        RANGE = [cut_enclosedCutNumNeighbor, 9999999999 ]
      } TEMP = target_cut
   
      SELECT enclosed_cut ENCLOSING target_cut { } TEMP = enclosed_cut
    }
  
    if (cut_enclosedCutMinSpacing > 0) {
        EXTERNAL enclosed_cut {
        COMMENT = "$layer_name EncContSpc: minimum spacing between enclosed contacts ( cut_enclosedCutNeighborRange um / cut_enclosedCutNumNeighbor ) = cut_enclosedCutMinSpacing "
            SPACING < cut_enclosedCutMinSpacing
            SET_CORNERS_TO_SPACING = TRUE 
	    BOX_CORNER = FALSE 
	    NON_PARALLEL = TRUE
	    POINT_TOUCH = TRUE
        } (24 )
    }
 
    if (cut_enclosedCutToNeighborMinSpacing > 0) {
       if (router_ignoreSameNetAdjacentViaDRC) {
          CONNECT { enclosed_cut BY via4  }
          EXTERNAL enclosed_cut via4  {
              COMMENT = "$layer_name EncContSpc: minimum spacing between enclosed and neighboring contacts ( cut_enclosedCutNeighborRange um / cut_enclosedCutNumNeighbor ) = cut_enclosedCutToNeighborMinSpacing "
              SPACING < cut_enclosedCutToNeighborMinSpacing
              SET_CORNERS_TO_SPACING = TRUE 
	      BOX_CORNER = FALSE 
	      NON_PARALLEL = TRUE
	      POINT_TOUCH = TRUE
              NODAL = TRUE
          } (24 )
       } else {
          EXTERNAL enclosed_cut via4  {
              COMMENT = "$layer_name EncContSpc: minimum spacing between enclosed and neighboring contacts ( cut_enclosedCutNeighborRange um / cut_enclosedCutNumNeighbor ) = cut_enclosedCutToNeighborMinSpacing "
              SPACING < cut_enclosedCutToNeighborMinSpacing
              SET_CORNERS_TO_SPACING = TRUE 
	      BOX_CORNER = FALSE 
	      NON_PARALLEL = TRUE
	      POINT_TOUCH = TRUE
          } (24 )
       }
    }
}
 
/*check max stack level, upward only*/
if (cut_maxStackLevel > 0 && cut_stackLevelSpacing > 0) {
    if (cut_maxStackLevel == 1) {
      BOOLEAN via4  AND CUT_LAYER1 { } TEMP = neighbors
    }
    else if (cut_maxStackLevel == 2) {
      BOOLEAN (via4  AND CUT_LAYER1) AND CUT_LAYER2 { } TEMP = neighbors
    }
    else if (cut_maxStackLevel == 3) {
      BOOLEAN (via4  AND CUT_LAYER1) AND (CUT_LAYER2 AND CUT_LAYER3)
        { } TEMP = neighbors
    }
    else if (cut_maxStackLevel == 4) {
      BOOLEAN ((via4  AND CUT_LAYER1) AND (CUT_LAYER2 AND CUT_LAYER3))
        AND CUT_LAYER4 { } TEMP = neighbors
    }
    else if (cut_maxStackLevel == 5) {
      BOOLEAN ((via4  AND CUT_LAYER1) AND (CUT_LAYER2 AND CUT_LAYER3))
        AND (CUT_LAYER4 AND CUT_LAYER5) { } TEMP = neighbors
    }
    else if (cut_maxStackLevel == 6) {
      BOOLEAN ((via4  AND CUT_LAYER1) AND (CUT_LAYER2 AND CUT_LAYER3))
        AND ((CUT_LAYER4 AND CUT_LAYER5) AND CUT_LAYER6) { } TEMP = neighbors
    }
    else if (cut_maxStackLevel >= 7) { 
      BOOLEAN ((via4  AND CUT_LAYER1) AND (CUT_LAYER2 AND CUT_LAYER3))
        AND ((CUT_LAYER4 AND CUT_LAYER5) AND (CUT_LAYER6 AND CUT_LAYER7))
       { } TEMP = neighbors
    }
 
    if (!layer_empty(neighbors)) {
      SELECT CUT_LAYER0 INTERACT neighbors {
        LINE_TOUCH = FALSE POINT_TOUCH = FALSE 
      } TEMP = neighbors
      EXTERNAL neighbors {
	spacing <= cut_stackLevelSpacing
      } TEMP = via_arr_ext
      if (!layer_empty (via_arr_ext)) {
	SELECT neighbors OUTSIDE via_arr_ext {
         COMMENT = "$layer_name StackLevel: maximum stack level = cut_maxStackLevel "
          LINE_TOUCH = FALSE
          POINT_TOUCH = FALSE	    
        } (24 )
      }
      else {
        BOOLEAN via4  AND neighbors {
            COMMENT = "$layer_name StackLevel: maximum stack level = cut_maxStackLevel "
        } (24 )
      }
    }
  }
  else if (cut_maxStackLevel > 0) {
    if (cut_maxStackLevel == 1) {
      COPY CUT_LAYER1 { } TEMP = neighbors
    }
    else if (cut_maxStackLevel == 2) {
      BOOLEAN CUT_LAYER1 AND CUT_LAYER2 { } TEMP = neighbors
    }
    else if (cut_maxStackLevel == 3) {
      BOOLEAN CUT_LAYER1 AND (CUT_LAYER2 AND CUT_LAYER3)
        { } TEMP = neighbors
    }
    else if (cut_maxStackLevel == 4) {
      BOOLEAN (CUT_LAYER1 AND CUT_LAYER2) AND (CUT_LAYER3 AND CUT_LAYER4)
        { } TEMP = neighbors
    }
    else if (cut_maxStackLevel == 5) {
      BOOLEAN ((CUT_LAYER1 AND CUT_LAYER2) AND (CUT_LAYER3 AND CUT_LAYER4))
        AND CUT_LAYER5 { } TEMP = neighbors
    }
    else if (cut_maxStackLevel == 6) {
      BOOLEAN ((CUT_LAYER6 AND CUT_LAYER1) AND (CUT_LAYER2 AND CUT_LAYER3))
        AND (CUT_LAYER4 AND CUT_LAYER5) { } TEMP = neighbors
    }
    else if (cut_maxStackLevel >= 7) { 
      BOOLEAN ((CUT_LAYER7 AND CUT_LAYER1) AND (CUT_LAYER2 AND CUT_LAYER3))
        AND ((CUT_LAYER4 AND CUT_LAYER5) AND CUT_LAYER6) { } TEMP = neighbors
    }
 
    if (!layer_empty (neighbors)) {
        BOOLEAN via4  AND neighbors {
            COMMENT = "$layer_name StackLevel: maximum stack level = cut_maxStackLevel "
        } (24 )
    }
}
 
/*Check fat contact*/
if (cut_fatContactMinSpacing > 0 && cut_fatTblDimension == 0) {
    if (cut_fatContactThreshold1 > 0) {
    	SIZE metal4    { UNDER_OVER = cut_fatContactThreshold1 / 2.0 - 0.0005  } TEMP = m_fat
    	BOOLEAN m_fat AND metal4  { } TEMP = m_fat
 
    	SELECT via4  INSIDE  m_fat { } TEMP = v_fat
 
    	EXTERNAL v_fat via4  {
            COMMENT = "$layer_name FatContSpc: fat contact ( cut_fatContactThreshold1 um, lower layer) minimum spacing = cut_fatContactMinSpacing um"
            SPACING < cut_fatContactMinSpacing
	    BOX_CORNER = FALSE 
	    NON_PARALLEL = TRUE
	    POINT_TOUCH = TRUE
        } (24 )
    }
 
    if (cut_fatContactThreshold2 > 0) {
    	SIZE metal5    { UNDER_OVER = cut_fatContactThreshold2 / 2.0 - 0.0005  } TEMP = m_fat
    	BOOLEAN m_fat AND metal5  { } TEMP = m_fat
 
    	SELECT via4  INSIDE  m_fat { } TEMP = v_fat
 
    	EXTERNAL v_fat via4  {
            COMMENT = "$layer_name FatContSpc: fat contact ( cut_fatContactThreshold2 um, upper layer) minimum spacing = cut_fatContactMinSpacing um"
            SPACING < cut_fatContactMinSpacing
	    BOX_CORNER = FALSE 
	    NON_PARALLEL = TRUE
	    POINT_TOUCH = TRUE
        } (24 )
    }
}
/* Avoid empty optimization result parsing error */
if (addEmptyViaCheck) {
   BOOLEAN empty OR empty {
      COMMENT = "$layer_name Empty: Dummy Output"
   } (24 )
   SET addEmptyViaCheck=0;
}
 
/* reset variables */















SET cut_size = 0;
SET cut_minSpacing = 0;
SET cut_sameNetMinSpacing = 0;
SET cut_cornerMinSpacing = 0;
SET cutBlkg_minSpacing = 0;
SET cut_maxNumAdjacentCut = 0;
SET cut_adjacentCutRange = 0;
SET cut_enclosedCutNeighborRange = 0;
SET cut_enclosedCutNumNeighbor = 0;
SET cut_enclosedCutMinSpacing = 0;
SET cut_enclosedCutToNeighborMinSpacing = 0;
SET cut_enclosedCutDiagViaExcluded = 0;
SET cut_maxStackLevel = 0;
SET cut_defaultContactMinSpacing = 0;
SET cut_fatContactThreshold1 = 0;
SET cut_fatContactThreshold2 = 0;
SET cut_fatContactMinSpacing = 0;
SET cut_maxCutSpacing = 0; 
SET cut_fatTblDimension = 0;
SET cut_fatTblThreshold_1 = 0;
SET cut_fatTblThreshold_2 = 0;
SET cut_fatTblNextThreshold_1 = 0;
SET cut_fatTblNextThreshold_2 = 0;
SET cut_fatTblMinCuts = 0;
SET cut_fatTblMinSpacing = 0;
SET cut_fatTblExtensionRange = 0;
SET cut_fatTblExtensionMinCuts = 0;
SET cut_fatTblExtensionMinSpacing = 0;
@ 519 "adrc/adrc.ev" 2











/*via 5*/
SET layer_name = "Via5";












SET cornerSpacingMode = 0;
SET cut_minSpacing = 0.14;
SET cut_fatTblDimension = 0;
@ 1 "adrc/adrc_check_via.ev" 1
/* check size */
if (cut_size > 0) {
    INTERNAL via5  {  
        COMMENT = "$layer_name Size      : contact size = cut_size um" 
	DIMENSION = [cut_size , cut_size]
    } (25 )
}
if (cut_minSpacing > 0) {
   if (ignoreContactCodeSpacing) {
      COPY via5  { } TEMP= default_via5 
   } else {
      SIZE metal5  { UNDER_OVER = cut_fatContactThreshold1 } TEMP = m_fat1
      SIZE metal6  { UNDER_OVER = cut_fatContactThreshold2 } TEMP = m_fat2
      BOOLEAN m_fat1 OR m_fat2 {} TEMP=m_fat
      SELECT via5  OUTSIDE m_fat { } TEMP= default_via5 
   }
}
 
/*check basic spacing*/
if (cut_sameNetMinSpacing > 0 && cut_sameNetMinSpacing < cut_minSpacing) {
  CONNECT { default_via5  BY via5  }
  if (cut_cornerMinSpacing > 0) {
    if (cornerSpacingMode == 1) {
        /* Work around: CONVEX_TO_CONVEX [POINT_PROJECTION] has a bug */
        EXTERNAL default_via5  {
             SPACING <= 0
             CONVEX_TO_CONVEX [POINT_PROJECTION] < cut_cornerMinSpacing
             FLAG_DISCONNECTED = FALSE
             NON_PARALLEL = TRUE
             POINT_TOUCH = TRUE
             BOX_CORNER = FALSE
        } TEMP = sameNet_corner_err1
        EXTERNAL default_via5  {
             SPACING <= 0
             CONVEX_TO_CONVEX < cut_cornerMinSpacing
             FLAG_DISCONNECTED = FALSE
             NON_PARALLEL = TRUE
             POINT_TOUCH = TRUE
             BOX_CORNER = TRUE
        } TEMP = sameNet_corner_err2 
        BOOLEAN sameNet_corner_err1 OR sameNet_corner_err2 {
             COMMENT = "$layer_name SameNetSpc: corner to corner spacing = cut_cornerMinSpacing um "
        } (25 ) 
        EXTERNAL default_via5  {
             COMMENT = "$layer_name SameNetSpc: same-net minimum spacing = cut_sameNetMinSpacing um "
             SPACING < cut_sameNetMinSpacing
             FLAG_DISCONNECTED = FALSE
             SET_CORNERS_TO_SPACING = FALSE
             PARALLEL_POINT_PROJECTION = FALSE
             NON_PARALLEL = TRUE
             TOUCH = FALSE
             POINT_TOUCH = FALSE
        } (25 )
    } else {
        EXTERNAL default_via5  {
            COMMENT = "$layer_name SameNetSpc: same-net minimum spacing = cut_sameNetMinSpacing um (corner to corner spacing = cut_cornerMinSpacing um) "
            SPACING < cut_sameNetMinSpacing
            CONVEX_TO_CONVEX < cut_cornerMinSpacing
            FLAG_DISCONNECTED = FALSE
            NON_PARALLEL = TRUE
            POINT_TOUCH = TRUE
        } (25 )
    }
  } else {
    EXTERNAL default_via5  {
        COMMENT = "$layer_name SameNetSpc: same-net minimum spacing = cut_sameNetMinSpacing um"
        SPACING < cut_sameNetMinSpacing
	BOX_CORNER = FALSE 
        FLAG_DISCONNECTED = FALSE
	NON_PARALLEL = TRUE
	POINT_TOUCH = TRUE
    } (25 )
  }
  if (cut_cornerMinSpacing > 0) {
    if (cornerSpacingMode == 1) {
        /* Work around: CONVEX_TO_CONVEX [POINT_PROJECTION] has a bug */
        EXTERNAL default_via5  {
          SPACING <= 0
          CONVEX_TO_CONVEX [POINT_PROJECTION] < cut_cornerMinSpacing
          NON_PARALLEL = TRUE
          POINT_TOUCH = TRUE
          BOX_CORNER = FALSE
          NODAL = TRUE
        } TEMP = diffNet_corner_err1 
        EXTERNAL default_via5  {
          SPACING <= 0
          CONVEX_TO_CONVEX < cut_cornerMinSpacing
          NON_PARALLEL = TRUE
          POINT_TOUCH = TRUE
          BOX_CORNER = TRUE
          NODAL = TRUE
        } TEMP = diffNet_corner_err2 
        BOOLEAN diffNet_corner_err1 OR diffNet_corner_err2 {
          COMMENT = "$layer_name Spacing   : corner to corner spacing = cut_cornerMinSpacing um "
        } (25 )
        EXTERNAL default_via5  {
          COMMENT = "$layer_name Spacing   : minimum spacing = cut_minSpacing um"
          SPACING < cut_minSpacing
          SET_CORNERS_TO_SPACING = FALSE
          PARALLEL_POINT_PROJECTION = FALSE
          NON_PARALLEL = TRUE
          TOUCH = FALSE
          POINT_TOUCH = FALSE
          NODAL = TRUE
        } (25 )
    } else {
        EXTERNAL default_via5  {
          COMMENT = "$layer_name Spacing   : minimum spacing = cut_minSpacing um (corner to corner spacing = cut_cornerMinSpacing um) "
          SPACING < cut_minSpacing
          CONVEX_TO_CONVEX < cut_cornerMinSpacing
          NON_PARALLEL = TRUE
          POINT_TOUCH = TRUE
          NODAL = TRUE
        } (25 )
    }
  } else {
    EXTERNAL default_via5  {
      COMMENT = "$layer_name Spacing   : minimum spacing = cut_minSpacing um"
      SPACING < cut_minSpacing
      BOX_CORNER = FALSE 
      NON_PARALLEL = TRUE
      POINT_TOUCH = TRUE
      NODAL = TRUE
    } (25 ) 
  }
} else {
   if (cut_minSpacing > 0) {
     if (cut_cornerMinSpacing > 0) {
        if (cornerSpacingMode == 1) {
           /* Work around: CONVEX_TO_CONVEX [POINT_PROJECTION] has a bug */
           EXTERNAL default_via5  {
             SPACING <= 0
             CONVEX_TO_CONVEX [POINT_PROJECTION] < cut_cornerMinSpacing
             NON_PARALLEL = TRUE
             POINT_TOUCH = TRUE
             BOX_CORNER = FALSE 
           } TEMP = corner_err1 
           EXTERNAL default_via5  {
             SPACING <= 0
             CONVEX_TO_CONVEX < cut_cornerMinSpacing
             NON_PARALLEL = TRUE
             POINT_TOUCH = TRUE
             BOX_CORNER = TRUE
           } TEMP = corner_err2 
           BOOLEAN corner_err1 OR corner_err2 {
             COMMENT = "$layer_name Spacing   : corner to corner spacing = cut_cornerMinSpacing um "
           } (25 )
           EXTERNAL default_via5  {
             COMMENT = "$layer_name Spacing   : minimum spacing = cut_minSpacing um"
             SPACING < cut_minSpacing
             SET_CORNERS_TO_SPACING = FALSE
             PARALLEL_POINT_PROJECTION = FALSE
             NON_PARALLEL = TRUE
             TOUCH = FALSE
             POINT_TOUCH = FALSE
           } (25 )
        } else {
           EXTERNAL default_via5  {
             COMMENT = "$layer_name Spacing   : minimum spacing = cut_minSpacing um (corner to corner spacing = cut_cornerMinSpacing um) "
             SPACING < cut_minSpacing
             CONVEX_TO_CONVEX < cut_cornerMinSpacing
             NON_PARALLEL = TRUE
             POINT_TOUCH = TRUE
           } (25 )
        }
    } else {
       EXTERNAL default_via5  {
          COMMENT = "$layer_name Spacing   : minimum spacing = cut_minSpacing um"
          SPACING < cut_minSpacing
	  BOX_CORNER = FALSE 
	  NON_PARALLEL = TRUE
	  POINT_TOUCH = TRUE
       } (25 )
    }
  }
}
 
/*check blockage spacing*/
if (ignoreBlockage == 0) {
   if (!layer_empty (via5_blockage )) {
      if (cutBlkg_minSpacing > 0) {
	  EXTERNAL via5_blockage  via5  {
              COMMENT = "$layer_name Spacing   : contact & blockage minimum spacing = cutBlkg_minSpacing um"
	      SPACING < cutBlkg_minSpacing
	      BOX_CORNER = FALSE 
	      NON_PARALLEL = TRUE
	      POINT_TOUCH = TRUE
          } (25 )
      }
   }
}
/*check blockage overlap*/ 
/*check shorts between top_level routing and fram_blockages*/
if (cutBlkg_minSpacing > 0 || checkCrossHierShort > 0) {
   if (readCellView > 0) {
       COPY empty {} TEMP = real_blockage
       COPY via5  {} TEMP = top_cut
   } else {
       COPY via5_fram  {} TEMP = real_blockage
       COPY via5_top  {} TEMP = top_cut
   }
   if (ignoreBlockage == 0) {
      BOOLEAN via5_blockage  OR real_blockage {} TEMP=all_blockage
   } else {
      COPY real_blockage {} TEMP=all_blockage
   }
   
   BOOLEAN all_blockage AND top_cut {} TEMP = overlap_shape1
   EXTERNAL all_blockage top_cut {
      SPACING <= 0
      TOUCH = TRUE
   } TEMP = overlap_shape2
   if (checkCrossHierShort > 0) {
      BOOLEAN overlap_shape1 OR overlap_shape2 {
          COMMENT = "$layer_name Short Cross Hierarchy"
      } (25 )
   } else {
      BOOLEAN overlap_shape1 OR overlap_shape2 {
          COMMENT = "$layer_name Overlap   : cut & blockage overlap"
      } (25 )
   }
}
/*check adjacent via number*/
if (cut_adjacentCutRange > 0 && cut_maxNumAdjacentCut > 0) {
    if (router_ignoreSameNetAdjacentViaDRC) {
       EXTERNAL via5  {  
	   SPACING < cut_adjacentCutRange
	   SET_CORNERS_TO_SPACING = FALSE
	   PARALLEL_POINT_PROJECTION = FALSE
	   NON_PARALLEL = TRUE
	   BOX_CORNER = FALSE
	   SHADOW = FALSE
           NODAL = TRUE
       } TEMP=edge_spacing
       EXTERNAL via5  {
	   SPACING < 0
	   CONVEX_TO_EDGE < cut_adjacentCutRange
	   CONVEX_TO_CONVEX < cut_adjacentCutRange
	   BOX_CORNER = FALSE
	   SHADOW = FALSE
           NODAL = TRUE
       } TEMP=corner_spacing
    } else {
       EXTERNAL via5  {  
	   SPACING < cut_adjacentCutRange
	   SET_CORNERS_TO_SPACING = FALSE
	   PARALLEL_POINT_PROJECTION = FALSE
	   NON_PARALLEL = TRUE
	   BOX_CORNER = FALSE
	   SHADOW = FALSE
       } TEMP=edge_spacing
 
       EXTERNAL via5  {
	   SPACING < 0
	   CONVEX_TO_EDGE < cut_adjacentCutRange
	   CONVEX_TO_CONVEX < cut_adjacentCutRange
	   BOX_CORNER = FALSE
	   SHADOW = FALSE
       } TEMP=corner_spacing
    }
    SIZE edge_spacing { UNDERSIZE = 0.001  } TEMP = edge_spacing1
    SIZE edge_spacing1 { OVERSIZE = 0.001  } TEMP = edge_spacing2
    BOOLEAN (edge_spacing NOT edge_spacing2) OR edge_spacing1 { } TEMP=edge_spacing
 
    SIZE corner_spacing { UNDERSIZE = 0.001  } TEMP = corner_spacing1
    SIZE corner_spacing1 { OVERSIZE = 0.001  } TEMP = corner_spacing2
    BOOLEAN (corner_spacing NOT corner_spacing2) OR corner_spacing1 { } TEMP=corner_spacing
  
    BOOLEAN edge_spacing OR corner_spacing { } TEMP = spacing
 
    SIZE via5  { OVERSIZE = 5* 0.001  } TEMP = cut
 
    SELECT cut INTERACT spacing {
        POINT_TOUCH = TRUE
        RANGE = [cut_maxNumAdjacentCut + 1, 9999999999 ]
    } TEMP = enclosed_cut
 
    SELECT via5  INSIDE enclosed_cut {
        COMMENT = "$layer_name AdjContNum: maximum number of the adjacent contacts ( cut_adjacentCutRange um) = cut_maxNumAdjacentCut "
    } (25 )
}
 
/*check enclosed via spacing*/
if (cut_enclosedCutNeighborRange > 0 && cut_enclosedCutNumNeighbor > 0) {
    if (cut_enclosedCutDiagViaExcluded) {
       EXTERNAL via5  {
          SPACING < cut_enclosedCutNeighborRange
          SET_CORNERS_TO_SPACING = FALSE
          PARALLEL_POINT_PROJECTION = FALSE
          NON_PARALLEL = TRUE
          BOX_CORNER = FALSE
          SHADOW = FALSE
       } TEMP = edge_spacing
       SELECT via5  TOUCHING edge_spacing {
          RANGE = [cut_enclosedCutNumNeighbor, 9999999999 ]
       } TEMP = enclosed_cut
    } else {
       /* Work around: for SIZE_RECT FLAG_INTERACTION_COUNT parser bug */
       
@ 308 "adrc/adrc_check_via.ev"
       if (cut_enclosedCutNumNeighbor==1) {
          
@-         SIZE_RECT via5  { 
@-            RANGE1=[0, 10] 
@-            RANGE2=[0, 10] 
@-            RANGE1_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0005 ) 
@-            RANGE2_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0005 ) 
@-            FLAG_INTERACTION_COUNT >  0  
@-            CORNER_METHOD = RADIAL 
@-         } TEMP=enclosed_cut 
       } else if (cut_enclosedCutNumNeighbor==2) {
          
@-         SIZE_RECT via5  { 
@-            RANGE1=[0, 10] 
@-            RANGE2=[0, 10] 
@-            RANGE1_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0005 ) 
@-            RANGE2_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0005 ) 
@-            FLAG_INTERACTION_COUNT >  1  
@-            CORNER_METHOD = RADIAL 
@-         } TEMP=enclosed_cut 
       } else if (cut_enclosedCutNumNeighbor==3) {
          
@-         SIZE_RECT via5  { 
@-            RANGE1=[0, 10] 
@-            RANGE2=[0, 10] 
@-            RANGE1_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0005 ) 
@-            RANGE2_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0005 ) 
@-            FLAG_INTERACTION_COUNT >  2  
@-            CORNER_METHOD = RADIAL 
@-         } TEMP=enclosed_cut 
       } else if (cut_enclosedCutNumNeighbor==4) {
          
@-         SIZE_RECT via5  { 
@-            RANGE1=[0, 10] 
@-            RANGE2=[0, 10] 
@-            RANGE1_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0005 ) 
@-            RANGE2_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0005 ) 
@-            FLAG_INTERACTION_COUNT >  3  
@-            CORNER_METHOD = RADIAL 
@-         } TEMP=enclosed_cut 
       } else if (cut_enclosedCutNumNeighbor==5) {
          
@-         SIZE_RECT via5  { 
@-            RANGE1=[0, 10] 
@-            RANGE2=[0, 10] 
@-            RANGE1_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0005 ) 
@-            RANGE2_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0005 ) 
@-            FLAG_INTERACTION_COUNT >  4  
@-            CORNER_METHOD = RADIAL 
@-         } TEMP=enclosed_cut 
       } else if (cut_enclosedCutNumNeighbor==6) {
          
@-         SIZE_RECT via5  { 
@-            RANGE1=[0, 10] 
@-            RANGE2=[0, 10] 
@-            RANGE1_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0005 ) 
@-            RANGE2_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0005 ) 
@-            FLAG_INTERACTION_COUNT >  5  
@-            CORNER_METHOD = RADIAL 
@-         } TEMP=enclosed_cut 
       } else if (cut_enclosedCutNumNeighbor==7) {
          
@-         SIZE_RECT via5  { 
@-            RANGE1=[0, 10] 
@-            RANGE2=[0, 10] 
@-            RANGE1_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0005 ) 
@-            RANGE2_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0005 ) 
@-            FLAG_INTERACTION_COUNT >  6  
@-            CORNER_METHOD = RADIAL 
@-         } TEMP=enclosed_cut 
       } else if (cut_enclosedCutNumNeighbor==8) {
          
@-         SIZE_RECT via5  { 
@-            RANGE1=[0, 10] 
@-            RANGE2=[0, 10] 
@-            RANGE1_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0005 ) 
@-            RANGE2_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0005 ) 
@-            FLAG_INTERACTION_COUNT >  7  
@-            CORNER_METHOD = RADIAL 
@-         } TEMP=enclosed_cut 
       } else if (cut_enclosedCutNumNeighbor==9) {
          
@-         SIZE_RECT via5  { 
@-            RANGE1=[0, 10] 
@-            RANGE2=[0, 10] 
@-            RANGE1_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0005 ) 
@-            RANGE2_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0005 ) 
@-            FLAG_INTERACTION_COUNT >  8  
@-            CORNER_METHOD = RADIAL 
@-         } TEMP=enclosed_cut 
       } else if (cut_enclosedCutNumNeighbor>9) {
          
@-         SIZE_RECT via5  { 
@-            RANGE1=[0, 10] 
@-            RANGE2=[0, 10] 
@-            RANGE1_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0005 ) 
@-            RANGE2_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0005 ) 
@-            FLAG_INTERACTION_COUNT >  9  
@-            CORNER_METHOD = RADIAL 
@-         } TEMP=enclosed_cut 
       }
    }
    if (router_ignoreSameNetAdjacentViaDRC) {
      /* Good approximation for same net via filter */
      CENTER_TO_CENTER via5  {
        NODAL=TRUE
        SPACING < cut_enclosedCutNeighborRange + 1.41421*cut_size + 0.0005 
        OUTPUT_VECTOR = TRUE
      } TEMP = c2c_spacing
      SIZE via5  { UNDERSIZE = (cut_size/2.0- 0.0005 ) } TEMP=cut_center
      BOOLEAN c2c_spacing NOT cut_center { } TEMP=c2c_spacing
      SIZE cut_center { OVERSIZE = 0.001  } TEMP=cut_center
      BOOLEAN c2c_spacing AND via5   { } TEMP=c2c_filter
      SELECT cut_center INTERACT c2c_filter {
        POINT_TOUCH=TRUE
        RANGE = [cut_enclosedCutNumNeighbor, 9999999999 ]
      } TEMP = target_cut
   
      SELECT enclosed_cut ENCLOSING target_cut { } TEMP = enclosed_cut
    }
  
    if (cut_enclosedCutMinSpacing > 0) {
        EXTERNAL enclosed_cut {
        COMMENT = "$layer_name EncContSpc: minimum spacing between enclosed contacts ( cut_enclosedCutNeighborRange um / cut_enclosedCutNumNeighbor ) = cut_enclosedCutMinSpacing "
            SPACING < cut_enclosedCutMinSpacing
            SET_CORNERS_TO_SPACING = TRUE 
	    BOX_CORNER = FALSE 
	    NON_PARALLEL = TRUE
	    POINT_TOUCH = TRUE
        } (25 )
    }
 
    if (cut_enclosedCutToNeighborMinSpacing > 0) {
       if (router_ignoreSameNetAdjacentViaDRC) {
          CONNECT { enclosed_cut BY via5  }
          EXTERNAL enclosed_cut via5  {
              COMMENT = "$layer_name EncContSpc: minimum spacing between enclosed and neighboring contacts ( cut_enclosedCutNeighborRange um / cut_enclosedCutNumNeighbor ) = cut_enclosedCutToNeighborMinSpacing "
              SPACING < cut_enclosedCutToNeighborMinSpacing
              SET_CORNERS_TO_SPACING = TRUE 
	      BOX_CORNER = FALSE 
	      NON_PARALLEL = TRUE
	      POINT_TOUCH = TRUE
              NODAL = TRUE
          } (25 )
       } else {
          EXTERNAL enclosed_cut via5  {
              COMMENT = "$layer_name EncContSpc: minimum spacing between enclosed and neighboring contacts ( cut_enclosedCutNeighborRange um / cut_enclosedCutNumNeighbor ) = cut_enclosedCutToNeighborMinSpacing "
              SPACING < cut_enclosedCutToNeighborMinSpacing
              SET_CORNERS_TO_SPACING = TRUE 
	      BOX_CORNER = FALSE 
	      NON_PARALLEL = TRUE
	      POINT_TOUCH = TRUE
          } (25 )
       }
    }
}
 
/*check max stack level, upward only*/
if (cut_maxStackLevel > 0 && cut_stackLevelSpacing > 0) {
    if (cut_maxStackLevel == 1) {
      BOOLEAN via5  AND CUT_LAYER1 { } TEMP = neighbors
    }
    else if (cut_maxStackLevel == 2) {
      BOOLEAN (via5  AND CUT_LAYER1) AND CUT_LAYER2 { } TEMP = neighbors
    }
    else if (cut_maxStackLevel == 3) {
      BOOLEAN (via5  AND CUT_LAYER1) AND (CUT_LAYER2 AND CUT_LAYER3)
        { } TEMP = neighbors
    }
    else if (cut_maxStackLevel == 4) {
      BOOLEAN ((via5  AND CUT_LAYER1) AND (CUT_LAYER2 AND CUT_LAYER3))
        AND CUT_LAYER4 { } TEMP = neighbors
    }
    else if (cut_maxStackLevel == 5) {
      BOOLEAN ((via5  AND CUT_LAYER1) AND (CUT_LAYER2 AND CUT_LAYER3))
        AND (CUT_LAYER4 AND CUT_LAYER5) { } TEMP = neighbors
    }
    else if (cut_maxStackLevel == 6) {
      BOOLEAN ((via5  AND CUT_LAYER1) AND (CUT_LAYER2 AND CUT_LAYER3))
        AND ((CUT_LAYER4 AND CUT_LAYER5) AND CUT_LAYER6) { } TEMP = neighbors
    }
    else if (cut_maxStackLevel >= 7) { 
      BOOLEAN ((via5  AND CUT_LAYER1) AND (CUT_LAYER2 AND CUT_LAYER3))
        AND ((CUT_LAYER4 AND CUT_LAYER5) AND (CUT_LAYER6 AND CUT_LAYER7))
       { } TEMP = neighbors
    }
 
    if (!layer_empty(neighbors)) {
      SELECT CUT_LAYER0 INTERACT neighbors {
        LINE_TOUCH = FALSE POINT_TOUCH = FALSE 
      } TEMP = neighbors
      EXTERNAL neighbors {
	spacing <= cut_stackLevelSpacing
      } TEMP = via_arr_ext
      if (!layer_empty (via_arr_ext)) {
	SELECT neighbors OUTSIDE via_arr_ext {
         COMMENT = "$layer_name StackLevel: maximum stack level = cut_maxStackLevel "
          LINE_TOUCH = FALSE
          POINT_TOUCH = FALSE	    
        } (25 )
      }
      else {
        BOOLEAN via5  AND neighbors {
            COMMENT = "$layer_name StackLevel: maximum stack level = cut_maxStackLevel "
        } (25 )
      }
    }
  }
  else if (cut_maxStackLevel > 0) {
    if (cut_maxStackLevel == 1) {
      COPY CUT_LAYER1 { } TEMP = neighbors
    }
    else if (cut_maxStackLevel == 2) {
      BOOLEAN CUT_LAYER1 AND CUT_LAYER2 { } TEMP = neighbors
    }
    else if (cut_maxStackLevel == 3) {
      BOOLEAN CUT_LAYER1 AND (CUT_LAYER2 AND CUT_LAYER3)
        { } TEMP = neighbors
    }
    else if (cut_maxStackLevel == 4) {
      BOOLEAN (CUT_LAYER1 AND CUT_LAYER2) AND (CUT_LAYER3 AND CUT_LAYER4)
        { } TEMP = neighbors
    }
    else if (cut_maxStackLevel == 5) {
      BOOLEAN ((CUT_LAYER1 AND CUT_LAYER2) AND (CUT_LAYER3 AND CUT_LAYER4))
        AND CUT_LAYER5 { } TEMP = neighbors
    }
    else if (cut_maxStackLevel == 6) {
      BOOLEAN ((CUT_LAYER6 AND CUT_LAYER1) AND (CUT_LAYER2 AND CUT_LAYER3))
        AND (CUT_LAYER4 AND CUT_LAYER5) { } TEMP = neighbors
    }
    else if (cut_maxStackLevel >= 7) { 
      BOOLEAN ((CUT_LAYER7 AND CUT_LAYER1) AND (CUT_LAYER2 AND CUT_LAYER3))
        AND ((CUT_LAYER4 AND CUT_LAYER5) AND CUT_LAYER6) { } TEMP = neighbors
    }
 
    if (!layer_empty (neighbors)) {
        BOOLEAN via5  AND neighbors {
            COMMENT = "$layer_name StackLevel: maximum stack level = cut_maxStackLevel "
        } (25 )
    }
}
 
/*Check fat contact*/
if (cut_fatContactMinSpacing > 0 && cut_fatTblDimension == 0) {
    if (cut_fatContactThreshold1 > 0) {
    	SIZE metal5    { UNDER_OVER = cut_fatContactThreshold1 / 2.0 - 0.0005  } TEMP = m_fat
    	BOOLEAN m_fat AND metal5  { } TEMP = m_fat
 
    	SELECT via5  INSIDE  m_fat { } TEMP = v_fat
 
    	EXTERNAL v_fat via5  {
            COMMENT = "$layer_name FatContSpc: fat contact ( cut_fatContactThreshold1 um, lower layer) minimum spacing = cut_fatContactMinSpacing um"
            SPACING < cut_fatContactMinSpacing
	    BOX_CORNER = FALSE 
	    NON_PARALLEL = TRUE
	    POINT_TOUCH = TRUE
        } (25 )
    }
 
    if (cut_fatContactThreshold2 > 0) {
    	SIZE metal6    { UNDER_OVER = cut_fatContactThreshold2 / 2.0 - 0.0005  } TEMP = m_fat
    	BOOLEAN m_fat AND metal6  { } TEMP = m_fat
 
    	SELECT via5  INSIDE  m_fat { } TEMP = v_fat
 
    	EXTERNAL v_fat via5  {
            COMMENT = "$layer_name FatContSpc: fat contact ( cut_fatContactThreshold2 um, upper layer) minimum spacing = cut_fatContactMinSpacing um"
            SPACING < cut_fatContactMinSpacing
	    BOX_CORNER = FALSE 
	    NON_PARALLEL = TRUE
	    POINT_TOUCH = TRUE
        } (25 )
    }
}
/* Avoid empty optimization result parsing error */
if (addEmptyViaCheck) {
   BOOLEAN empty OR empty {
      COMMENT = "$layer_name Empty: Dummy Output"
   } (25 )
   SET addEmptyViaCheck=0;
}
 
/* reset variables */















SET cut_size = 0;
SET cut_minSpacing = 0;
SET cut_sameNetMinSpacing = 0;
SET cut_cornerMinSpacing = 0;
SET cutBlkg_minSpacing = 0;
SET cut_maxNumAdjacentCut = 0;
SET cut_adjacentCutRange = 0;
SET cut_enclosedCutNeighborRange = 0;
SET cut_enclosedCutNumNeighbor = 0;
SET cut_enclosedCutMinSpacing = 0;
SET cut_enclosedCutToNeighborMinSpacing = 0;
SET cut_enclosedCutDiagViaExcluded = 0;
SET cut_maxStackLevel = 0;
SET cut_defaultContactMinSpacing = 0;
SET cut_fatContactThreshold1 = 0;
SET cut_fatContactThreshold2 = 0;
SET cut_fatContactMinSpacing = 0;
SET cut_maxCutSpacing = 0; 
SET cut_fatTblDimension = 0;
SET cut_fatTblThreshold_1 = 0;
SET cut_fatTblThreshold_2 = 0;
SET cut_fatTblNextThreshold_1 = 0;
SET cut_fatTblNextThreshold_2 = 0;
SET cut_fatTblMinCuts = 0;
SET cut_fatTblMinSpacing = 0;
SET cut_fatTblExtensionRange = 0;
SET cut_fatTblExtensionMinCuts = 0;
SET cut_fatTblExtensionMinSpacing = 0;
@ 547 "adrc/adrc.ev" 2











/*via 6*/
SET layer_name = "Via6";












SET cornerSpacingMode = 0;
SET cut_minSpacing = 0.14;
SET cut_fatTblDimension = 0;
@ 1 "adrc/adrc_check_via.ev" 1
/* check size */
if (cut_size > 0) {
    INTERNAL via6  {  
        COMMENT = "$layer_name Size      : contact size = cut_size um" 
	DIMENSION = [cut_size , cut_size]
    } (26 )
}
if (cut_minSpacing > 0) {
   if (ignoreContactCodeSpacing) {
      COPY via6  { } TEMP= default_via6 
   } else {
      SIZE metal6  { UNDER_OVER = cut_fatContactThreshold1 } TEMP = m_fat1
      SIZE metal7  { UNDER_OVER = cut_fatContactThreshold2 } TEMP = m_fat2
      BOOLEAN m_fat1 OR m_fat2 {} TEMP=m_fat
      SELECT via6  OUTSIDE m_fat { } TEMP= default_via6 
   }
}
 
/*check basic spacing*/
if (cut_sameNetMinSpacing > 0 && cut_sameNetMinSpacing < cut_minSpacing) {
  CONNECT { default_via6  BY via6  }
  if (cut_cornerMinSpacing > 0) {
    if (cornerSpacingMode == 1) {
        /* Work around: CONVEX_TO_CONVEX [POINT_PROJECTION] has a bug */
        EXTERNAL default_via6  {
             SPACING <= 0
             CONVEX_TO_CONVEX [POINT_PROJECTION] < cut_cornerMinSpacing
             FLAG_DISCONNECTED = FALSE
             NON_PARALLEL = TRUE
             POINT_TOUCH = TRUE
             BOX_CORNER = FALSE
        } TEMP = sameNet_corner_err1
        EXTERNAL default_via6  {
             SPACING <= 0
             CONVEX_TO_CONVEX < cut_cornerMinSpacing
             FLAG_DISCONNECTED = FALSE
             NON_PARALLEL = TRUE
             POINT_TOUCH = TRUE
             BOX_CORNER = TRUE
        } TEMP = sameNet_corner_err2 
        BOOLEAN sameNet_corner_err1 OR sameNet_corner_err2 {
             COMMENT = "$layer_name SameNetSpc: corner to corner spacing = cut_cornerMinSpacing um "
        } (26 ) 
        EXTERNAL default_via6  {
             COMMENT = "$layer_name SameNetSpc: same-net minimum spacing = cut_sameNetMinSpacing um "
             SPACING < cut_sameNetMinSpacing
             FLAG_DISCONNECTED = FALSE
             SET_CORNERS_TO_SPACING = FALSE
             PARALLEL_POINT_PROJECTION = FALSE
             NON_PARALLEL = TRUE
             TOUCH = FALSE
             POINT_TOUCH = FALSE
        } (26 )
    } else {
        EXTERNAL default_via6  {
            COMMENT = "$layer_name SameNetSpc: same-net minimum spacing = cut_sameNetMinSpacing um (corner to corner spacing = cut_cornerMinSpacing um) "
            SPACING < cut_sameNetMinSpacing
            CONVEX_TO_CONVEX < cut_cornerMinSpacing
            FLAG_DISCONNECTED = FALSE
            NON_PARALLEL = TRUE
            POINT_TOUCH = TRUE
        } (26 )
    }
  } else {
    EXTERNAL default_via6  {
        COMMENT = "$layer_name SameNetSpc: same-net minimum spacing = cut_sameNetMinSpacing um"
        SPACING < cut_sameNetMinSpacing
	BOX_CORNER = FALSE 
        FLAG_DISCONNECTED = FALSE
	NON_PARALLEL = TRUE
	POINT_TOUCH = TRUE
    } (26 )
  }
  if (cut_cornerMinSpacing > 0) {
    if (cornerSpacingMode == 1) {
        /* Work around: CONVEX_TO_CONVEX [POINT_PROJECTION] has a bug */
        EXTERNAL default_via6  {
          SPACING <= 0
          CONVEX_TO_CONVEX [POINT_PROJECTION] < cut_cornerMinSpacing
          NON_PARALLEL = TRUE
          POINT_TOUCH = TRUE
          BOX_CORNER = FALSE
          NODAL = TRUE
        } TEMP = diffNet_corner_err1 
        EXTERNAL default_via6  {
          SPACING <= 0
          CONVEX_TO_CONVEX < cut_cornerMinSpacing
          NON_PARALLEL = TRUE
          POINT_TOUCH = TRUE
          BOX_CORNER = TRUE
          NODAL = TRUE
        } TEMP = diffNet_corner_err2 
        BOOLEAN diffNet_corner_err1 OR diffNet_corner_err2 {
          COMMENT = "$layer_name Spacing   : corner to corner spacing = cut_cornerMinSpacing um "
        } (26 )
        EXTERNAL default_via6  {
          COMMENT = "$layer_name Spacing   : minimum spacing = cut_minSpacing um"
          SPACING < cut_minSpacing
          SET_CORNERS_TO_SPACING = FALSE
          PARALLEL_POINT_PROJECTION = FALSE
          NON_PARALLEL = TRUE
          TOUCH = FALSE
          POINT_TOUCH = FALSE
          NODAL = TRUE
        } (26 )
    } else {
        EXTERNAL default_via6  {
          COMMENT = "$layer_name Spacing   : minimum spacing = cut_minSpacing um (corner to corner spacing = cut_cornerMinSpacing um) "
          SPACING < cut_minSpacing
          CONVEX_TO_CONVEX < cut_cornerMinSpacing
          NON_PARALLEL = TRUE
          POINT_TOUCH = TRUE
          NODAL = TRUE
        } (26 )
    }
  } else {
    EXTERNAL default_via6  {
      COMMENT = "$layer_name Spacing   : minimum spacing = cut_minSpacing um"
      SPACING < cut_minSpacing
      BOX_CORNER = FALSE 
      NON_PARALLEL = TRUE
      POINT_TOUCH = TRUE
      NODAL = TRUE
    } (26 ) 
  }
} else {
   if (cut_minSpacing > 0) {
     if (cut_cornerMinSpacing > 0) {
        if (cornerSpacingMode == 1) {
           /* Work around: CONVEX_TO_CONVEX [POINT_PROJECTION] has a bug */
           EXTERNAL default_via6  {
             SPACING <= 0
             CONVEX_TO_CONVEX [POINT_PROJECTION] < cut_cornerMinSpacing
             NON_PARALLEL = TRUE
             POINT_TOUCH = TRUE
             BOX_CORNER = FALSE 
           } TEMP = corner_err1 
           EXTERNAL default_via6  {
             SPACING <= 0
             CONVEX_TO_CONVEX < cut_cornerMinSpacing
             NON_PARALLEL = TRUE
             POINT_TOUCH = TRUE
             BOX_CORNER = TRUE
           } TEMP = corner_err2 
           BOOLEAN corner_err1 OR corner_err2 {
             COMMENT = "$layer_name Spacing   : corner to corner spacing = cut_cornerMinSpacing um "
           } (26 )
           EXTERNAL default_via6  {
             COMMENT = "$layer_name Spacing   : minimum spacing = cut_minSpacing um"
             SPACING < cut_minSpacing
             SET_CORNERS_TO_SPACING = FALSE
             PARALLEL_POINT_PROJECTION = FALSE
             NON_PARALLEL = TRUE
             TOUCH = FALSE
             POINT_TOUCH = FALSE
           } (26 )
        } else {
           EXTERNAL default_via6  {
             COMMENT = "$layer_name Spacing   : minimum spacing = cut_minSpacing um (corner to corner spacing = cut_cornerMinSpacing um) "
             SPACING < cut_minSpacing
             CONVEX_TO_CONVEX < cut_cornerMinSpacing
             NON_PARALLEL = TRUE
             POINT_TOUCH = TRUE
           } (26 )
        }
    } else {
       EXTERNAL default_via6  {
          COMMENT = "$layer_name Spacing   : minimum spacing = cut_minSpacing um"
          SPACING < cut_minSpacing
	  BOX_CORNER = FALSE 
	  NON_PARALLEL = TRUE
	  POINT_TOUCH = TRUE
       } (26 )
    }
  }
}
 
/*check blockage spacing*/
if (ignoreBlockage == 0) {
   if (!layer_empty (via6_blockage )) {
      if (cutBlkg_minSpacing > 0) {
	  EXTERNAL via6_blockage  via6  {
              COMMENT = "$layer_name Spacing   : contact & blockage minimum spacing = cutBlkg_minSpacing um"
	      SPACING < cutBlkg_minSpacing
	      BOX_CORNER = FALSE 
	      NON_PARALLEL = TRUE
	      POINT_TOUCH = TRUE
          } (26 )
      }
   }
}
/*check blockage overlap*/ 
/*check shorts between top_level routing and fram_blockages*/
if (cutBlkg_minSpacing > 0 || checkCrossHierShort > 0) {
   if (readCellView > 0) {
       COPY empty {} TEMP = real_blockage
       COPY via6  {} TEMP = top_cut
   } else {
       COPY via6_fram  {} TEMP = real_blockage
       COPY via6_top  {} TEMP = top_cut
   }
   if (ignoreBlockage == 0) {
      BOOLEAN via6_blockage  OR real_blockage {} TEMP=all_blockage
   } else {
      COPY real_blockage {} TEMP=all_blockage
   }
   
   BOOLEAN all_blockage AND top_cut {} TEMP = overlap_shape1
   EXTERNAL all_blockage top_cut {
      SPACING <= 0
      TOUCH = TRUE
   } TEMP = overlap_shape2
   if (checkCrossHierShort > 0) {
      BOOLEAN overlap_shape1 OR overlap_shape2 {
          COMMENT = "$layer_name Short Cross Hierarchy"
      } (26 )
   } else {
      BOOLEAN overlap_shape1 OR overlap_shape2 {
          COMMENT = "$layer_name Overlap   : cut & blockage overlap"
      } (26 )
   }
}
/*check adjacent via number*/
if (cut_adjacentCutRange > 0 && cut_maxNumAdjacentCut > 0) {
    if (router_ignoreSameNetAdjacentViaDRC) {
       EXTERNAL via6  {  
	   SPACING < cut_adjacentCutRange
	   SET_CORNERS_TO_SPACING = FALSE
	   PARALLEL_POINT_PROJECTION = FALSE
	   NON_PARALLEL = TRUE
	   BOX_CORNER = FALSE
	   SHADOW = FALSE
           NODAL = TRUE
       } TEMP=edge_spacing
       EXTERNAL via6  {
	   SPACING < 0
	   CONVEX_TO_EDGE < cut_adjacentCutRange
	   CONVEX_TO_CONVEX < cut_adjacentCutRange
	   BOX_CORNER = FALSE
	   SHADOW = FALSE
           NODAL = TRUE
       } TEMP=corner_spacing
    } else {
       EXTERNAL via6  {  
	   SPACING < cut_adjacentCutRange
	   SET_CORNERS_TO_SPACING = FALSE
	   PARALLEL_POINT_PROJECTION = FALSE
	   NON_PARALLEL = TRUE
	   BOX_CORNER = FALSE
	   SHADOW = FALSE
       } TEMP=edge_spacing
 
       EXTERNAL via6  {
	   SPACING < 0
	   CONVEX_TO_EDGE < cut_adjacentCutRange
	   CONVEX_TO_CONVEX < cut_adjacentCutRange
	   BOX_CORNER = FALSE
	   SHADOW = FALSE
       } TEMP=corner_spacing
    }
    SIZE edge_spacing { UNDERSIZE = 0.001  } TEMP = edge_spacing1
    SIZE edge_spacing1 { OVERSIZE = 0.001  } TEMP = edge_spacing2
    BOOLEAN (edge_spacing NOT edge_spacing2) OR edge_spacing1 { } TEMP=edge_spacing
 
    SIZE corner_spacing { UNDERSIZE = 0.001  } TEMP = corner_spacing1
    SIZE corner_spacing1 { OVERSIZE = 0.001  } TEMP = corner_spacing2
    BOOLEAN (corner_spacing NOT corner_spacing2) OR corner_spacing1 { } TEMP=corner_spacing
  
    BOOLEAN edge_spacing OR corner_spacing { } TEMP = spacing
 
    SIZE via6  { OVERSIZE = 5* 0.001  } TEMP = cut
 
    SELECT cut INTERACT spacing {
        POINT_TOUCH = TRUE
        RANGE = [cut_maxNumAdjacentCut + 1, 9999999999 ]
    } TEMP = enclosed_cut
 
    SELECT via6  INSIDE enclosed_cut {
        COMMENT = "$layer_name AdjContNum: maximum number of the adjacent contacts ( cut_adjacentCutRange um) = cut_maxNumAdjacentCut "
    } (26 )
}
 
/*check enclosed via spacing*/
if (cut_enclosedCutNeighborRange > 0 && cut_enclosedCutNumNeighbor > 0) {
    if (cut_enclosedCutDiagViaExcluded) {
       EXTERNAL via6  {
          SPACING < cut_enclosedCutNeighborRange
          SET_CORNERS_TO_SPACING = FALSE
          PARALLEL_POINT_PROJECTION = FALSE
          NON_PARALLEL = TRUE
          BOX_CORNER = FALSE
          SHADOW = FALSE
       } TEMP = edge_spacing
       SELECT via6  TOUCHING edge_spacing {
          RANGE = [cut_enclosedCutNumNeighbor, 9999999999 ]
       } TEMP = enclosed_cut
    } else {
       /* Work around: for SIZE_RECT FLAG_INTERACTION_COUNT parser bug */
       
@ 308 "adrc/adrc_check_via.ev"
       if (cut_enclosedCutNumNeighbor==1) {
          
@-         SIZE_RECT via6  { 
@-            RANGE1=[0, 10] 
@-            RANGE2=[0, 10] 
@-            RANGE1_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0005 ) 
@-            RANGE2_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0005 ) 
@-            FLAG_INTERACTION_COUNT >  0  
@-            CORNER_METHOD = RADIAL 
@-         } TEMP=enclosed_cut 
       } else if (cut_enclosedCutNumNeighbor==2) {
          
@-         SIZE_RECT via6  { 
@-            RANGE1=[0, 10] 
@-            RANGE2=[0, 10] 
@-            RANGE1_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0005 ) 
@-            RANGE2_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0005 ) 
@-            FLAG_INTERACTION_COUNT >  1  
@-            CORNER_METHOD = RADIAL 
@-         } TEMP=enclosed_cut 
       } else if (cut_enclosedCutNumNeighbor==3) {
          
@-         SIZE_RECT via6  { 
@-            RANGE1=[0, 10] 
@-            RANGE2=[0, 10] 
@-            RANGE1_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0005 ) 
@-            RANGE2_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0005 ) 
@-            FLAG_INTERACTION_COUNT >  2  
@-            CORNER_METHOD = RADIAL 
@-         } TEMP=enclosed_cut 
       } else if (cut_enclosedCutNumNeighbor==4) {
          
@-         SIZE_RECT via6  { 
@-            RANGE1=[0, 10] 
@-            RANGE2=[0, 10] 
@-            RANGE1_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0005 ) 
@-            RANGE2_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0005 ) 
@-            FLAG_INTERACTION_COUNT >  3  
@-            CORNER_METHOD = RADIAL 
@-         } TEMP=enclosed_cut 
       } else if (cut_enclosedCutNumNeighbor==5) {
          
@-         SIZE_RECT via6  { 
@-            RANGE1=[0, 10] 
@-            RANGE2=[0, 10] 
@-            RANGE1_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0005 ) 
@-            RANGE2_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0005 ) 
@-            FLAG_INTERACTION_COUNT >  4  
@-            CORNER_METHOD = RADIAL 
@-         } TEMP=enclosed_cut 
       } else if (cut_enclosedCutNumNeighbor==6) {
          
@-         SIZE_RECT via6  { 
@-            RANGE1=[0, 10] 
@-            RANGE2=[0, 10] 
@-            RANGE1_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0005 ) 
@-            RANGE2_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0005 ) 
@-            FLAG_INTERACTION_COUNT >  5  
@-            CORNER_METHOD = RADIAL 
@-         } TEMP=enclosed_cut 
       } else if (cut_enclosedCutNumNeighbor==7) {
          
@-         SIZE_RECT via6  { 
@-            RANGE1=[0, 10] 
@-            RANGE2=[0, 10] 
@-            RANGE1_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0005 ) 
@-            RANGE2_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0005 ) 
@-            FLAG_INTERACTION_COUNT >  6  
@-            CORNER_METHOD = RADIAL 
@-         } TEMP=enclosed_cut 
       } else if (cut_enclosedCutNumNeighbor==8) {
          
@-         SIZE_RECT via6  { 
@-            RANGE1=[0, 10] 
@-            RANGE2=[0, 10] 
@-            RANGE1_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0005 ) 
@-            RANGE2_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0005 ) 
@-            FLAG_INTERACTION_COUNT >  7  
@-            CORNER_METHOD = RADIAL 
@-         } TEMP=enclosed_cut 
       } else if (cut_enclosedCutNumNeighbor==9) {
          
@-         SIZE_RECT via6  { 
@-            RANGE1=[0, 10] 
@-            RANGE2=[0, 10] 
@-            RANGE1_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0005 ) 
@-            RANGE2_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0005 ) 
@-            FLAG_INTERACTION_COUNT >  8  
@-            CORNER_METHOD = RADIAL 
@-         } TEMP=enclosed_cut 
       } else if (cut_enclosedCutNumNeighbor>9) {
          
@-         SIZE_RECT via6  { 
@-            RANGE1=[0, 10] 
@-            RANGE2=[0, 10] 
@-            RANGE1_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0005 ) 
@-            RANGE2_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0005 ) 
@-            FLAG_INTERACTION_COUNT >  9  
@-            CORNER_METHOD = RADIAL 
@-         } TEMP=enclosed_cut 
       }
    }
    if (router_ignoreSameNetAdjacentViaDRC) {
      /* Good approximation for same net via filter */
      CENTER_TO_CENTER via6  {
        NODAL=TRUE
        SPACING < cut_enclosedCutNeighborRange + 1.41421*cut_size + 0.0005 
        OUTPUT_VECTOR = TRUE
      } TEMP = c2c_spacing
      SIZE via6  { UNDERSIZE = (cut_size/2.0- 0.0005 ) } TEMP=cut_center
      BOOLEAN c2c_spacing NOT cut_center { } TEMP=c2c_spacing
      SIZE cut_center { OVERSIZE = 0.001  } TEMP=cut_center
      BOOLEAN c2c_spacing AND via6   { } TEMP=c2c_filter
      SELECT cut_center INTERACT c2c_filter {
        POINT_TOUCH=TRUE
        RANGE = [cut_enclosedCutNumNeighbor, 9999999999 ]
      } TEMP = target_cut
   
      SELECT enclosed_cut ENCLOSING target_cut { } TEMP = enclosed_cut
    }
  
    if (cut_enclosedCutMinSpacing > 0) {
        EXTERNAL enclosed_cut {
        COMMENT = "$layer_name EncContSpc: minimum spacing between enclosed contacts ( cut_enclosedCutNeighborRange um / cut_enclosedCutNumNeighbor ) = cut_enclosedCutMinSpacing "
            SPACING < cut_enclosedCutMinSpacing
            SET_CORNERS_TO_SPACING = TRUE 
	    BOX_CORNER = FALSE 
	    NON_PARALLEL = TRUE
	    POINT_TOUCH = TRUE
        } (26 )
    }
 
    if (cut_enclosedCutToNeighborMinSpacing > 0) {
       if (router_ignoreSameNetAdjacentViaDRC) {
          CONNECT { enclosed_cut BY via6  }
          EXTERNAL enclosed_cut via6  {
              COMMENT = "$layer_name EncContSpc: minimum spacing between enclosed and neighboring contacts ( cut_enclosedCutNeighborRange um / cut_enclosedCutNumNeighbor ) = cut_enclosedCutToNeighborMinSpacing "
              SPACING < cut_enclosedCutToNeighborMinSpacing
              SET_CORNERS_TO_SPACING = TRUE 
	      BOX_CORNER = FALSE 
	      NON_PARALLEL = TRUE
	      POINT_TOUCH = TRUE
              NODAL = TRUE
          } (26 )
       } else {
          EXTERNAL enclosed_cut via6  {
              COMMENT = "$layer_name EncContSpc: minimum spacing between enclosed and neighboring contacts ( cut_enclosedCutNeighborRange um / cut_enclosedCutNumNeighbor ) = cut_enclosedCutToNeighborMinSpacing "
              SPACING < cut_enclosedCutToNeighborMinSpacing
              SET_CORNERS_TO_SPACING = TRUE 
	      BOX_CORNER = FALSE 
	      NON_PARALLEL = TRUE
	      POINT_TOUCH = TRUE
          } (26 )
       }
    }
}
 
/*check max stack level, upward only*/
if (cut_maxStackLevel > 0 && cut_stackLevelSpacing > 0) {
    if (cut_maxStackLevel == 1) {
      BOOLEAN via6  AND CUT_LAYER1 { } TEMP = neighbors
    }
    else if (cut_maxStackLevel == 2) {
      BOOLEAN (via6  AND CUT_LAYER1) AND CUT_LAYER2 { } TEMP = neighbors
    }
    else if (cut_maxStackLevel == 3) {
      BOOLEAN (via6  AND CUT_LAYER1) AND (CUT_LAYER2 AND CUT_LAYER3)
        { } TEMP = neighbors
    }
    else if (cut_maxStackLevel == 4) {
      BOOLEAN ((via6  AND CUT_LAYER1) AND (CUT_LAYER2 AND CUT_LAYER3))
        AND CUT_LAYER4 { } TEMP = neighbors
    }
    else if (cut_maxStackLevel == 5) {
      BOOLEAN ((via6  AND CUT_LAYER1) AND (CUT_LAYER2 AND CUT_LAYER3))
        AND (CUT_LAYER4 AND CUT_LAYER5) { } TEMP = neighbors
    }
    else if (cut_maxStackLevel == 6) {
      BOOLEAN ((via6  AND CUT_LAYER1) AND (CUT_LAYER2 AND CUT_LAYER3))
        AND ((CUT_LAYER4 AND CUT_LAYER5) AND CUT_LAYER6) { } TEMP = neighbors
    }
    else if (cut_maxStackLevel >= 7) { 
      BOOLEAN ((via6  AND CUT_LAYER1) AND (CUT_LAYER2 AND CUT_LAYER3))
        AND ((CUT_LAYER4 AND CUT_LAYER5) AND (CUT_LAYER6 AND CUT_LAYER7))
       { } TEMP = neighbors
    }
 
    if (!layer_empty(neighbors)) {
      SELECT CUT_LAYER0 INTERACT neighbors {
        LINE_TOUCH = FALSE POINT_TOUCH = FALSE 
      } TEMP = neighbors
      EXTERNAL neighbors {
	spacing <= cut_stackLevelSpacing
      } TEMP = via_arr_ext
      if (!layer_empty (via_arr_ext)) {
	SELECT neighbors OUTSIDE via_arr_ext {
         COMMENT = "$layer_name StackLevel: maximum stack level = cut_maxStackLevel "
          LINE_TOUCH = FALSE
          POINT_TOUCH = FALSE	    
        } (26 )
      }
      else {
        BOOLEAN via6  AND neighbors {
            COMMENT = "$layer_name StackLevel: maximum stack level = cut_maxStackLevel "
        } (26 )
      }
    }
  }
  else if (cut_maxStackLevel > 0) {
    if (cut_maxStackLevel == 1) {
      COPY CUT_LAYER1 { } TEMP = neighbors
    }
    else if (cut_maxStackLevel == 2) {
      BOOLEAN CUT_LAYER1 AND CUT_LAYER2 { } TEMP = neighbors
    }
    else if (cut_maxStackLevel == 3) {
      BOOLEAN CUT_LAYER1 AND (CUT_LAYER2 AND CUT_LAYER3)
        { } TEMP = neighbors
    }
    else if (cut_maxStackLevel == 4) {
      BOOLEAN (CUT_LAYER1 AND CUT_LAYER2) AND (CUT_LAYER3 AND CUT_LAYER4)
        { } TEMP = neighbors
    }
    else if (cut_maxStackLevel == 5) {
      BOOLEAN ((CUT_LAYER1 AND CUT_LAYER2) AND (CUT_LAYER3 AND CUT_LAYER4))
        AND CUT_LAYER5 { } TEMP = neighbors
    }
    else if (cut_maxStackLevel == 6) {
      BOOLEAN ((CUT_LAYER6 AND CUT_LAYER1) AND (CUT_LAYER2 AND CUT_LAYER3))
        AND (CUT_LAYER4 AND CUT_LAYER5) { } TEMP = neighbors
    }
    else if (cut_maxStackLevel >= 7) { 
      BOOLEAN ((CUT_LAYER7 AND CUT_LAYER1) AND (CUT_LAYER2 AND CUT_LAYER3))
        AND ((CUT_LAYER4 AND CUT_LAYER5) AND CUT_LAYER6) { } TEMP = neighbors
    }
 
    if (!layer_empty (neighbors)) {
        BOOLEAN via6  AND neighbors {
            COMMENT = "$layer_name StackLevel: maximum stack level = cut_maxStackLevel "
        } (26 )
    }
}
 
/*Check fat contact*/
if (cut_fatContactMinSpacing > 0 && cut_fatTblDimension == 0) {
    if (cut_fatContactThreshold1 > 0) {
    	SIZE metal6    { UNDER_OVER = cut_fatContactThreshold1 / 2.0 - 0.0005  } TEMP = m_fat
    	BOOLEAN m_fat AND metal6  { } TEMP = m_fat
 
    	SELECT via6  INSIDE  m_fat { } TEMP = v_fat
 
    	EXTERNAL v_fat via6  {
            COMMENT = "$layer_name FatContSpc: fat contact ( cut_fatContactThreshold1 um, lower layer) minimum spacing = cut_fatContactMinSpacing um"
            SPACING < cut_fatContactMinSpacing
	    BOX_CORNER = FALSE 
	    NON_PARALLEL = TRUE
	    POINT_TOUCH = TRUE
        } (26 )
    }
 
    if (cut_fatContactThreshold2 > 0) {
    	SIZE metal7    { UNDER_OVER = cut_fatContactThreshold2 / 2.0 - 0.0005  } TEMP = m_fat
    	BOOLEAN m_fat AND metal7  { } TEMP = m_fat
 
    	SELECT via6  INSIDE  m_fat { } TEMP = v_fat
 
    	EXTERNAL v_fat via6  {
            COMMENT = "$layer_name FatContSpc: fat contact ( cut_fatContactThreshold2 um, upper layer) minimum spacing = cut_fatContactMinSpacing um"
            SPACING < cut_fatContactMinSpacing
	    BOX_CORNER = FALSE 
	    NON_PARALLEL = TRUE
	    POINT_TOUCH = TRUE
        } (26 )
    }
}
/* Avoid empty optimization result parsing error */
if (addEmptyViaCheck) {
   BOOLEAN empty OR empty {
      COMMENT = "$layer_name Empty: Dummy Output"
   } (26 )
   SET addEmptyViaCheck=0;
}
 
/* reset variables */















SET cut_size = 0;
SET cut_minSpacing = 0;
SET cut_sameNetMinSpacing = 0;
SET cut_cornerMinSpacing = 0;
SET cutBlkg_minSpacing = 0;
SET cut_maxNumAdjacentCut = 0;
SET cut_adjacentCutRange = 0;
SET cut_enclosedCutNeighborRange = 0;
SET cut_enclosedCutNumNeighbor = 0;
SET cut_enclosedCutMinSpacing = 0;
SET cut_enclosedCutToNeighborMinSpacing = 0;
SET cut_enclosedCutDiagViaExcluded = 0;
SET cut_maxStackLevel = 0;
SET cut_defaultContactMinSpacing = 0;
SET cut_fatContactThreshold1 = 0;
SET cut_fatContactThreshold2 = 0;
SET cut_fatContactMinSpacing = 0;
SET cut_maxCutSpacing = 0; 
SET cut_fatTblDimension = 0;
SET cut_fatTblThreshold_1 = 0;
SET cut_fatTblThreshold_2 = 0;
SET cut_fatTblNextThreshold_1 = 0;
SET cut_fatTblNextThreshold_2 = 0;
SET cut_fatTblMinCuts = 0;
SET cut_fatTblMinSpacing = 0;
SET cut_fatTblExtensionRange = 0;
SET cut_fatTblExtensionMinCuts = 0;
SET cut_fatTblExtensionMinSpacing = 0;
@ 575 "adrc/adrc.ev" 2











/*via 7*/
SET layer_name = "Via7";












SET cornerSpacingMode = 0;
SET cut_minSpacing = 0.16;
SET cut_fatTblDimension = 0;
@ 1 "adrc/adrc_check_via.ev" 1
/* check size */
if (cut_size > 0) {
    INTERNAL via7  {  
        COMMENT = "$layer_name Size      : contact size = cut_size um" 
	DIMENSION = [cut_size , cut_size]
    } (27 )
}
if (cut_minSpacing > 0) {
   if (ignoreContactCodeSpacing) {
      COPY via7  { } TEMP= default_via7 
   } else {
      SIZE metal7  { UNDER_OVER = cut_fatContactThreshold1 } TEMP = m_fat1
      SIZE metal8  { UNDER_OVER = cut_fatContactThreshold2 } TEMP = m_fat2
      BOOLEAN m_fat1 OR m_fat2 {} TEMP=m_fat
      SELECT via7  OUTSIDE m_fat { } TEMP= default_via7 
   }
}
 
/*check basic spacing*/
if (cut_sameNetMinSpacing > 0 && cut_sameNetMinSpacing < cut_minSpacing) {
  CONNECT { default_via7  BY via7  }
  if (cut_cornerMinSpacing > 0) {
    if (cornerSpacingMode == 1) {
        /* Work around: CONVEX_TO_CONVEX [POINT_PROJECTION] has a bug */
        EXTERNAL default_via7  {
             SPACING <= 0
             CONVEX_TO_CONVEX [POINT_PROJECTION] < cut_cornerMinSpacing
             FLAG_DISCONNECTED = FALSE
             NON_PARALLEL = TRUE
             POINT_TOUCH = TRUE
             BOX_CORNER = FALSE
        } TEMP = sameNet_corner_err1
        EXTERNAL default_via7  {
             SPACING <= 0
             CONVEX_TO_CONVEX < cut_cornerMinSpacing
             FLAG_DISCONNECTED = FALSE
             NON_PARALLEL = TRUE
             POINT_TOUCH = TRUE
             BOX_CORNER = TRUE
        } TEMP = sameNet_corner_err2 
        BOOLEAN sameNet_corner_err1 OR sameNet_corner_err2 {
             COMMENT = "$layer_name SameNetSpc: corner to corner spacing = cut_cornerMinSpacing um "
        } (27 ) 
        EXTERNAL default_via7  {
             COMMENT = "$layer_name SameNetSpc: same-net minimum spacing = cut_sameNetMinSpacing um "
             SPACING < cut_sameNetMinSpacing
             FLAG_DISCONNECTED = FALSE
             SET_CORNERS_TO_SPACING = FALSE
             PARALLEL_POINT_PROJECTION = FALSE
             NON_PARALLEL = TRUE
             TOUCH = FALSE
             POINT_TOUCH = FALSE
        } (27 )
    } else {
        EXTERNAL default_via7  {
            COMMENT = "$layer_name SameNetSpc: same-net minimum spacing = cut_sameNetMinSpacing um (corner to corner spacing = cut_cornerMinSpacing um) "
            SPACING < cut_sameNetMinSpacing
            CONVEX_TO_CONVEX < cut_cornerMinSpacing
            FLAG_DISCONNECTED = FALSE
            NON_PARALLEL = TRUE
            POINT_TOUCH = TRUE
        } (27 )
    }
  } else {
    EXTERNAL default_via7  {
        COMMENT = "$layer_name SameNetSpc: same-net minimum spacing = cut_sameNetMinSpacing um"
        SPACING < cut_sameNetMinSpacing
	BOX_CORNER = FALSE 
        FLAG_DISCONNECTED = FALSE
	NON_PARALLEL = TRUE
	POINT_TOUCH = TRUE
    } (27 )
  }
  if (cut_cornerMinSpacing > 0) {
    if (cornerSpacingMode == 1) {
        /* Work around: CONVEX_TO_CONVEX [POINT_PROJECTION] has a bug */
        EXTERNAL default_via7  {
          SPACING <= 0
          CONVEX_TO_CONVEX [POINT_PROJECTION] < cut_cornerMinSpacing
          NON_PARALLEL = TRUE
          POINT_TOUCH = TRUE
          BOX_CORNER = FALSE
          NODAL = TRUE
        } TEMP = diffNet_corner_err1 
        EXTERNAL default_via7  {
          SPACING <= 0
          CONVEX_TO_CONVEX < cut_cornerMinSpacing
          NON_PARALLEL = TRUE
          POINT_TOUCH = TRUE
          BOX_CORNER = TRUE
          NODAL = TRUE
        } TEMP = diffNet_corner_err2 
        BOOLEAN diffNet_corner_err1 OR diffNet_corner_err2 {
          COMMENT = "$layer_name Spacing   : corner to corner spacing = cut_cornerMinSpacing um "
        } (27 )
        EXTERNAL default_via7  {
          COMMENT = "$layer_name Spacing   : minimum spacing = cut_minSpacing um"
          SPACING < cut_minSpacing
          SET_CORNERS_TO_SPACING = FALSE
          PARALLEL_POINT_PROJECTION = FALSE
          NON_PARALLEL = TRUE
          TOUCH = FALSE
          POINT_TOUCH = FALSE
          NODAL = TRUE
        } (27 )
    } else {
        EXTERNAL default_via7  {
          COMMENT = "$layer_name Spacing   : minimum spacing = cut_minSpacing um (corner to corner spacing = cut_cornerMinSpacing um) "
          SPACING < cut_minSpacing
          CONVEX_TO_CONVEX < cut_cornerMinSpacing
          NON_PARALLEL = TRUE
          POINT_TOUCH = TRUE
          NODAL = TRUE
        } (27 )
    }
  } else {
    EXTERNAL default_via7  {
      COMMENT = "$layer_name Spacing   : minimum spacing = cut_minSpacing um"
      SPACING < cut_minSpacing
      BOX_CORNER = FALSE 
      NON_PARALLEL = TRUE
      POINT_TOUCH = TRUE
      NODAL = TRUE
    } (27 ) 
  }
} else {
   if (cut_minSpacing > 0) {
     if (cut_cornerMinSpacing > 0) {
        if (cornerSpacingMode == 1) {
           /* Work around: CONVEX_TO_CONVEX [POINT_PROJECTION] has a bug */
           EXTERNAL default_via7  {
             SPACING <= 0
             CONVEX_TO_CONVEX [POINT_PROJECTION] < cut_cornerMinSpacing
             NON_PARALLEL = TRUE
             POINT_TOUCH = TRUE
             BOX_CORNER = FALSE 
           } TEMP = corner_err1 
           EXTERNAL default_via7  {
             SPACING <= 0
             CONVEX_TO_CONVEX < cut_cornerMinSpacing
             NON_PARALLEL = TRUE
             POINT_TOUCH = TRUE
             BOX_CORNER = TRUE
           } TEMP = corner_err2 
           BOOLEAN corner_err1 OR corner_err2 {
             COMMENT = "$layer_name Spacing   : corner to corner spacing = cut_cornerMinSpacing um "
           } (27 )
           EXTERNAL default_via7  {
             COMMENT = "$layer_name Spacing   : minimum spacing = cut_minSpacing um"
             SPACING < cut_minSpacing
             SET_CORNERS_TO_SPACING = FALSE
             PARALLEL_POINT_PROJECTION = FALSE
             NON_PARALLEL = TRUE
             TOUCH = FALSE
             POINT_TOUCH = FALSE
           } (27 )
        } else {
           EXTERNAL default_via7  {
             COMMENT = "$layer_name Spacing   : minimum spacing = cut_minSpacing um (corner to corner spacing = cut_cornerMinSpacing um) "
             SPACING < cut_minSpacing
             CONVEX_TO_CONVEX < cut_cornerMinSpacing
             NON_PARALLEL = TRUE
             POINT_TOUCH = TRUE
           } (27 )
        }
    } else {
       EXTERNAL default_via7  {
          COMMENT = "$layer_name Spacing   : minimum spacing = cut_minSpacing um"
          SPACING < cut_minSpacing
	  BOX_CORNER = FALSE 
	  NON_PARALLEL = TRUE
	  POINT_TOUCH = TRUE
       } (27 )
    }
  }
}
 
/*check blockage spacing*/
if (ignoreBlockage == 0) {
   if (!layer_empty (via7_blockage )) {
      if (cutBlkg_minSpacing > 0) {
	  EXTERNAL via7_blockage  via7  {
              COMMENT = "$layer_name Spacing   : contact & blockage minimum spacing = cutBlkg_minSpacing um"
	      SPACING < cutBlkg_minSpacing
	      BOX_CORNER = FALSE 
	      NON_PARALLEL = TRUE
	      POINT_TOUCH = TRUE
          } (27 )
      }
   }
}
/*check blockage overlap*/ 
/*check shorts between top_level routing and fram_blockages*/
if (cutBlkg_minSpacing > 0 || checkCrossHierShort > 0) {
   if (readCellView > 0) {
       COPY empty {} TEMP = real_blockage
       COPY via7  {} TEMP = top_cut
   } else {
       COPY via7_fram  {} TEMP = real_blockage
       COPY via7_top  {} TEMP = top_cut
   }
   if (ignoreBlockage == 0) {
      BOOLEAN via7_blockage  OR real_blockage {} TEMP=all_blockage
   } else {
      COPY real_blockage {} TEMP=all_blockage
   }
   
   BOOLEAN all_blockage AND top_cut {} TEMP = overlap_shape1
   EXTERNAL all_blockage top_cut {
      SPACING <= 0
      TOUCH = TRUE
   } TEMP = overlap_shape2
   if (checkCrossHierShort > 0) {
      BOOLEAN overlap_shape1 OR overlap_shape2 {
          COMMENT = "$layer_name Short Cross Hierarchy"
      } (27 )
   } else {
      BOOLEAN overlap_shape1 OR overlap_shape2 {
          COMMENT = "$layer_name Overlap   : cut & blockage overlap"
      } (27 )
   }
}
/*check adjacent via number*/
if (cut_adjacentCutRange > 0 && cut_maxNumAdjacentCut > 0) {
    if (router_ignoreSameNetAdjacentViaDRC) {
       EXTERNAL via7  {  
	   SPACING < cut_adjacentCutRange
	   SET_CORNERS_TO_SPACING = FALSE
	   PARALLEL_POINT_PROJECTION = FALSE
	   NON_PARALLEL = TRUE
	   BOX_CORNER = FALSE
	   SHADOW = FALSE
           NODAL = TRUE
       } TEMP=edge_spacing
       EXTERNAL via7  {
	   SPACING < 0
	   CONVEX_TO_EDGE < cut_adjacentCutRange
	   CONVEX_TO_CONVEX < cut_adjacentCutRange
	   BOX_CORNER = FALSE
	   SHADOW = FALSE
           NODAL = TRUE
       } TEMP=corner_spacing
    } else {
       EXTERNAL via7  {  
	   SPACING < cut_adjacentCutRange
	   SET_CORNERS_TO_SPACING = FALSE
	   PARALLEL_POINT_PROJECTION = FALSE
	   NON_PARALLEL = TRUE
	   BOX_CORNER = FALSE
	   SHADOW = FALSE
       } TEMP=edge_spacing
 
       EXTERNAL via7  {
	   SPACING < 0
	   CONVEX_TO_EDGE < cut_adjacentCutRange
	   CONVEX_TO_CONVEX < cut_adjacentCutRange
	   BOX_CORNER = FALSE
	   SHADOW = FALSE
       } TEMP=corner_spacing
    }
    SIZE edge_spacing { UNDERSIZE = 0.001  } TEMP = edge_spacing1
    SIZE edge_spacing1 { OVERSIZE = 0.001  } TEMP = edge_spacing2
    BOOLEAN (edge_spacing NOT edge_spacing2) OR edge_spacing1 { } TEMP=edge_spacing
 
    SIZE corner_spacing { UNDERSIZE = 0.001  } TEMP = corner_spacing1
    SIZE corner_spacing1 { OVERSIZE = 0.001  } TEMP = corner_spacing2
    BOOLEAN (corner_spacing NOT corner_spacing2) OR corner_spacing1 { } TEMP=corner_spacing
  
    BOOLEAN edge_spacing OR corner_spacing { } TEMP = spacing
 
    SIZE via7  { OVERSIZE = 5* 0.001  } TEMP = cut
 
    SELECT cut INTERACT spacing {
        POINT_TOUCH = TRUE
        RANGE = [cut_maxNumAdjacentCut + 1, 9999999999 ]
    } TEMP = enclosed_cut
 
    SELECT via7  INSIDE enclosed_cut {
        COMMENT = "$layer_name AdjContNum: maximum number of the adjacent contacts ( cut_adjacentCutRange um) = cut_maxNumAdjacentCut "
    } (27 )
}
 
/*check enclosed via spacing*/
if (cut_enclosedCutNeighborRange > 0 && cut_enclosedCutNumNeighbor > 0) {
    if (cut_enclosedCutDiagViaExcluded) {
       EXTERNAL via7  {
          SPACING < cut_enclosedCutNeighborRange
          SET_CORNERS_TO_SPACING = FALSE
          PARALLEL_POINT_PROJECTION = FALSE
          NON_PARALLEL = TRUE
          BOX_CORNER = FALSE
          SHADOW = FALSE
       } TEMP = edge_spacing
       SELECT via7  TOUCHING edge_spacing {
          RANGE = [cut_enclosedCutNumNeighbor, 9999999999 ]
       } TEMP = enclosed_cut
    } else {
       /* Work around: for SIZE_RECT FLAG_INTERACTION_COUNT parser bug */
       
@ 308 "adrc/adrc_check_via.ev"
       if (cut_enclosedCutNumNeighbor==1) {
          
@-         SIZE_RECT via7  { 
@-            RANGE1=[0, 10] 
@-            RANGE2=[0, 10] 
@-            RANGE1_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0005 ) 
@-            RANGE2_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0005 ) 
@-            FLAG_INTERACTION_COUNT >  0  
@-            CORNER_METHOD = RADIAL 
@-         } TEMP=enclosed_cut 
       } else if (cut_enclosedCutNumNeighbor==2) {
          
@-         SIZE_RECT via7  { 
@-            RANGE1=[0, 10] 
@-            RANGE2=[0, 10] 
@-            RANGE1_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0005 ) 
@-            RANGE2_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0005 ) 
@-            FLAG_INTERACTION_COUNT >  1  
@-            CORNER_METHOD = RADIAL 
@-         } TEMP=enclosed_cut 
       } else if (cut_enclosedCutNumNeighbor==3) {
          
@-         SIZE_RECT via7  { 
@-            RANGE1=[0, 10] 
@-            RANGE2=[0, 10] 
@-            RANGE1_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0005 ) 
@-            RANGE2_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0005 ) 
@-            FLAG_INTERACTION_COUNT >  2  
@-            CORNER_METHOD = RADIAL 
@-         } TEMP=enclosed_cut 
       } else if (cut_enclosedCutNumNeighbor==4) {
          
@-         SIZE_RECT via7  { 
@-            RANGE1=[0, 10] 
@-            RANGE2=[0, 10] 
@-            RANGE1_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0005 ) 
@-            RANGE2_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0005 ) 
@-            FLAG_INTERACTION_COUNT >  3  
@-            CORNER_METHOD = RADIAL 
@-         } TEMP=enclosed_cut 
       } else if (cut_enclosedCutNumNeighbor==5) {
          
@-         SIZE_RECT via7  { 
@-            RANGE1=[0, 10] 
@-            RANGE2=[0, 10] 
@-            RANGE1_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0005 ) 
@-            RANGE2_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0005 ) 
@-            FLAG_INTERACTION_COUNT >  4  
@-            CORNER_METHOD = RADIAL 
@-         } TEMP=enclosed_cut 
       } else if (cut_enclosedCutNumNeighbor==6) {
          
@-         SIZE_RECT via7  { 
@-            RANGE1=[0, 10] 
@-            RANGE2=[0, 10] 
@-            RANGE1_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0005 ) 
@-            RANGE2_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0005 ) 
@-            FLAG_INTERACTION_COUNT >  5  
@-            CORNER_METHOD = RADIAL 
@-         } TEMP=enclosed_cut 
       } else if (cut_enclosedCutNumNeighbor==7) {
          
@-         SIZE_RECT via7  { 
@-            RANGE1=[0, 10] 
@-            RANGE2=[0, 10] 
@-            RANGE1_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0005 ) 
@-            RANGE2_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0005 ) 
@-            FLAG_INTERACTION_COUNT >  6  
@-            CORNER_METHOD = RADIAL 
@-         } TEMP=enclosed_cut 
       } else if (cut_enclosedCutNumNeighbor==8) {
          
@-         SIZE_RECT via7  { 
@-            RANGE1=[0, 10] 
@-            RANGE2=[0, 10] 
@-            RANGE1_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0005 ) 
@-            RANGE2_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0005 ) 
@-            FLAG_INTERACTION_COUNT >  7  
@-            CORNER_METHOD = RADIAL 
@-         } TEMP=enclosed_cut 
       } else if (cut_enclosedCutNumNeighbor==9) {
          
@-         SIZE_RECT via7  { 
@-            RANGE1=[0, 10] 
@-            RANGE2=[0, 10] 
@-            RANGE1_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0005 ) 
@-            RANGE2_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0005 ) 
@-            FLAG_INTERACTION_COUNT >  8  
@-            CORNER_METHOD = RADIAL 
@-         } TEMP=enclosed_cut 
       } else if (cut_enclosedCutNumNeighbor>9) {
          
@-         SIZE_RECT via7  { 
@-            RANGE1=[0, 10] 
@-            RANGE2=[0, 10] 
@-            RANGE1_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0005 ) 
@-            RANGE2_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0005 ) 
@-            FLAG_INTERACTION_COUNT >  9  
@-            CORNER_METHOD = RADIAL 
@-         } TEMP=enclosed_cut 
       }
    }
    if (router_ignoreSameNetAdjacentViaDRC) {
      /* Good approximation for same net via filter */
      CENTER_TO_CENTER via7  {
        NODAL=TRUE
        SPACING < cut_enclosedCutNeighborRange + 1.41421*cut_size + 0.0005 
        OUTPUT_VECTOR = TRUE
      } TEMP = c2c_spacing
      SIZE via7  { UNDERSIZE = (cut_size/2.0- 0.0005 ) } TEMP=cut_center
      BOOLEAN c2c_spacing NOT cut_center { } TEMP=c2c_spacing
      SIZE cut_center { OVERSIZE = 0.001  } TEMP=cut_center
      BOOLEAN c2c_spacing AND via7   { } TEMP=c2c_filter
      SELECT cut_center INTERACT c2c_filter {
        POINT_TOUCH=TRUE
        RANGE = [cut_enclosedCutNumNeighbor, 9999999999 ]
      } TEMP = target_cut
   
      SELECT enclosed_cut ENCLOSING target_cut { } TEMP = enclosed_cut
    }
  
    if (cut_enclosedCutMinSpacing > 0) {
        EXTERNAL enclosed_cut {
        COMMENT = "$layer_name EncContSpc: minimum spacing between enclosed contacts ( cut_enclosedCutNeighborRange um / cut_enclosedCutNumNeighbor ) = cut_enclosedCutMinSpacing "
            SPACING < cut_enclosedCutMinSpacing
            SET_CORNERS_TO_SPACING = TRUE 
	    BOX_CORNER = FALSE 
	    NON_PARALLEL = TRUE
	    POINT_TOUCH = TRUE
        } (27 )
    }
 
    if (cut_enclosedCutToNeighborMinSpacing > 0) {
       if (router_ignoreSameNetAdjacentViaDRC) {
          CONNECT { enclosed_cut BY via7  }
          EXTERNAL enclosed_cut via7  {
              COMMENT = "$layer_name EncContSpc: minimum spacing between enclosed and neighboring contacts ( cut_enclosedCutNeighborRange um / cut_enclosedCutNumNeighbor ) = cut_enclosedCutToNeighborMinSpacing "
              SPACING < cut_enclosedCutToNeighborMinSpacing
              SET_CORNERS_TO_SPACING = TRUE 
	      BOX_CORNER = FALSE 
	      NON_PARALLEL = TRUE
	      POINT_TOUCH = TRUE
              NODAL = TRUE
          } (27 )
       } else {
          EXTERNAL enclosed_cut via7  {
              COMMENT = "$layer_name EncContSpc: minimum spacing between enclosed and neighboring contacts ( cut_enclosedCutNeighborRange um / cut_enclosedCutNumNeighbor ) = cut_enclosedCutToNeighborMinSpacing "
              SPACING < cut_enclosedCutToNeighborMinSpacing
              SET_CORNERS_TO_SPACING = TRUE 
	      BOX_CORNER = FALSE 
	      NON_PARALLEL = TRUE
	      POINT_TOUCH = TRUE
          } (27 )
       }
    }
}
 
/*check max stack level, upward only*/
if (cut_maxStackLevel > 0 && cut_stackLevelSpacing > 0) {
    if (cut_maxStackLevel == 1) {
      BOOLEAN via7  AND CUT_LAYER1 { } TEMP = neighbors
    }
    else if (cut_maxStackLevel == 2) {
      BOOLEAN (via7  AND CUT_LAYER1) AND CUT_LAYER2 { } TEMP = neighbors
    }
    else if (cut_maxStackLevel == 3) {
      BOOLEAN (via7  AND CUT_LAYER1) AND (CUT_LAYER2 AND CUT_LAYER3)
        { } TEMP = neighbors
    }
    else if (cut_maxStackLevel == 4) {
      BOOLEAN ((via7  AND CUT_LAYER1) AND (CUT_LAYER2 AND CUT_LAYER3))
        AND CUT_LAYER4 { } TEMP = neighbors
    }
    else if (cut_maxStackLevel == 5) {
      BOOLEAN ((via7  AND CUT_LAYER1) AND (CUT_LAYER2 AND CUT_LAYER3))
        AND (CUT_LAYER4 AND CUT_LAYER5) { } TEMP = neighbors
    }
    else if (cut_maxStackLevel == 6) {
      BOOLEAN ((via7  AND CUT_LAYER1) AND (CUT_LAYER2 AND CUT_LAYER3))
        AND ((CUT_LAYER4 AND CUT_LAYER5) AND CUT_LAYER6) { } TEMP = neighbors
    }
    else if (cut_maxStackLevel >= 7) { 
      BOOLEAN ((via7  AND CUT_LAYER1) AND (CUT_LAYER2 AND CUT_LAYER3))
        AND ((CUT_LAYER4 AND CUT_LAYER5) AND (CUT_LAYER6 AND CUT_LAYER7))
       { } TEMP = neighbors
    }
 
    if (!layer_empty(neighbors)) {
      SELECT CUT_LAYER0 INTERACT neighbors {
        LINE_TOUCH = FALSE POINT_TOUCH = FALSE 
      } TEMP = neighbors
      EXTERNAL neighbors {
	spacing <= cut_stackLevelSpacing
      } TEMP = via_arr_ext
      if (!layer_empty (via_arr_ext)) {
	SELECT neighbors OUTSIDE via_arr_ext {
         COMMENT = "$layer_name StackLevel: maximum stack level = cut_maxStackLevel "
          LINE_TOUCH = FALSE
          POINT_TOUCH = FALSE	    
        } (27 )
      }
      else {
        BOOLEAN via7  AND neighbors {
            COMMENT = "$layer_name StackLevel: maximum stack level = cut_maxStackLevel "
        } (27 )
      }
    }
  }
  else if (cut_maxStackLevel > 0) {
    if (cut_maxStackLevel == 1) {
      COPY CUT_LAYER1 { } TEMP = neighbors
    }
    else if (cut_maxStackLevel == 2) {
      BOOLEAN CUT_LAYER1 AND CUT_LAYER2 { } TEMP = neighbors
    }
    else if (cut_maxStackLevel == 3) {
      BOOLEAN CUT_LAYER1 AND (CUT_LAYER2 AND CUT_LAYER3)
        { } TEMP = neighbors
    }
    else if (cut_maxStackLevel == 4) {
      BOOLEAN (CUT_LAYER1 AND CUT_LAYER2) AND (CUT_LAYER3 AND CUT_LAYER4)
        { } TEMP = neighbors
    }
    else if (cut_maxStackLevel == 5) {
      BOOLEAN ((CUT_LAYER1 AND CUT_LAYER2) AND (CUT_LAYER3 AND CUT_LAYER4))
        AND CUT_LAYER5 { } TEMP = neighbors
    }
    else if (cut_maxStackLevel == 6) {
      BOOLEAN ((CUT_LAYER6 AND CUT_LAYER1) AND (CUT_LAYER2 AND CUT_LAYER3))
        AND (CUT_LAYER4 AND CUT_LAYER5) { } TEMP = neighbors
    }
    else if (cut_maxStackLevel >= 7) { 
      BOOLEAN ((CUT_LAYER7 AND CUT_LAYER1) AND (CUT_LAYER2 AND CUT_LAYER3))
        AND ((CUT_LAYER4 AND CUT_LAYER5) AND CUT_LAYER6) { } TEMP = neighbors
    }
 
    if (!layer_empty (neighbors)) {
        BOOLEAN via7  AND neighbors {
            COMMENT = "$layer_name StackLevel: maximum stack level = cut_maxStackLevel "
        } (27 )
    }
}
 
/*Check fat contact*/
if (cut_fatContactMinSpacing > 0 && cut_fatTblDimension == 0) {
    if (cut_fatContactThreshold1 > 0) {
    	SIZE metal7    { UNDER_OVER = cut_fatContactThreshold1 / 2.0 - 0.0005  } TEMP = m_fat
    	BOOLEAN m_fat AND metal7  { } TEMP = m_fat
 
    	SELECT via7  INSIDE  m_fat { } TEMP = v_fat
 
    	EXTERNAL v_fat via7  {
            COMMENT = "$layer_name FatContSpc: fat contact ( cut_fatContactThreshold1 um, lower layer) minimum spacing = cut_fatContactMinSpacing um"
            SPACING < cut_fatContactMinSpacing
	    BOX_CORNER = FALSE 
	    NON_PARALLEL = TRUE
	    POINT_TOUCH = TRUE
        } (27 )
    }
 
    if (cut_fatContactThreshold2 > 0) {
    	SIZE metal8    { UNDER_OVER = cut_fatContactThreshold2 / 2.0 - 0.0005  } TEMP = m_fat
    	BOOLEAN m_fat AND metal8  { } TEMP = m_fat
 
    	SELECT via7  INSIDE  m_fat { } TEMP = v_fat
 
    	EXTERNAL v_fat via7  {
            COMMENT = "$layer_name FatContSpc: fat contact ( cut_fatContactThreshold2 um, upper layer) minimum spacing = cut_fatContactMinSpacing um"
            SPACING < cut_fatContactMinSpacing
	    BOX_CORNER = FALSE 
	    NON_PARALLEL = TRUE
	    POINT_TOUCH = TRUE
        } (27 )
    }
}
/* Avoid empty optimization result parsing error */
if (addEmptyViaCheck) {
   BOOLEAN empty OR empty {
      COMMENT = "$layer_name Empty: Dummy Output"
   } (27 )
   SET addEmptyViaCheck=0;
}
 
/* reset variables */















SET cut_size = 0;
SET cut_minSpacing = 0;
SET cut_sameNetMinSpacing = 0;
SET cut_cornerMinSpacing = 0;
SET cutBlkg_minSpacing = 0;
SET cut_maxNumAdjacentCut = 0;
SET cut_adjacentCutRange = 0;
SET cut_enclosedCutNeighborRange = 0;
SET cut_enclosedCutNumNeighbor = 0;
SET cut_enclosedCutMinSpacing = 0;
SET cut_enclosedCutToNeighborMinSpacing = 0;
SET cut_enclosedCutDiagViaExcluded = 0;
SET cut_maxStackLevel = 0;
SET cut_defaultContactMinSpacing = 0;
SET cut_fatContactThreshold1 = 0;
SET cut_fatContactThreshold2 = 0;
SET cut_fatContactMinSpacing = 0;
SET cut_maxCutSpacing = 0; 
SET cut_fatTblDimension = 0;
SET cut_fatTblThreshold_1 = 0;
SET cut_fatTblThreshold_2 = 0;
SET cut_fatTblNextThreshold_1 = 0;
SET cut_fatTblNextThreshold_2 = 0;
SET cut_fatTblMinCuts = 0;
SET cut_fatTblMinSpacing = 0;
SET cut_fatTblExtensionRange = 0;
SET cut_fatTblExtensionMinCuts = 0;
SET cut_fatTblExtensionMinSpacing = 0;
@ 603 "adrc/adrc.ev" 2











/*via 8*/
SET layer_name = "Via8";












SET cornerSpacingMode = 0;
SET cut_minSpacing = 0.34;
SET cut_fatTblDimension = 0;
@ 1 "adrc/adrc_check_via.ev" 1
/* check size */
if (cut_size > 0) {
    INTERNAL via8  {  
        COMMENT = "$layer_name Size      : contact size = cut_size um" 
	DIMENSION = [cut_size , cut_size]
    } (28 )
}
if (cut_minSpacing > 0) {
   if (ignoreContactCodeSpacing) {
      COPY via8  { } TEMP= default_via8 
   } else {
      SIZE metal8  { UNDER_OVER = cut_fatContactThreshold1 } TEMP = m_fat1
      SIZE metal9  { UNDER_OVER = cut_fatContactThreshold2 } TEMP = m_fat2
      BOOLEAN m_fat1 OR m_fat2 {} TEMP=m_fat
      SELECT via8  OUTSIDE m_fat { } TEMP= default_via8 
   }
}
 
/*check basic spacing*/
if (cut_sameNetMinSpacing > 0 && cut_sameNetMinSpacing < cut_minSpacing) {
  CONNECT { default_via8  BY via8  }
  if (cut_cornerMinSpacing > 0) {
    if (cornerSpacingMode == 1) {
        /* Work around: CONVEX_TO_CONVEX [POINT_PROJECTION] has a bug */
        EXTERNAL default_via8  {
             SPACING <= 0
             CONVEX_TO_CONVEX [POINT_PROJECTION] < cut_cornerMinSpacing
             FLAG_DISCONNECTED = FALSE
             NON_PARALLEL = TRUE
             POINT_TOUCH = TRUE
             BOX_CORNER = FALSE
        } TEMP = sameNet_corner_err1
        EXTERNAL default_via8  {
             SPACING <= 0
             CONVEX_TO_CONVEX < cut_cornerMinSpacing
             FLAG_DISCONNECTED = FALSE
             NON_PARALLEL = TRUE
             POINT_TOUCH = TRUE
             BOX_CORNER = TRUE
        } TEMP = sameNet_corner_err2 
        BOOLEAN sameNet_corner_err1 OR sameNet_corner_err2 {
             COMMENT = "$layer_name SameNetSpc: corner to corner spacing = cut_cornerMinSpacing um "
        } (28 ) 
        EXTERNAL default_via8  {
             COMMENT = "$layer_name SameNetSpc: same-net minimum spacing = cut_sameNetMinSpacing um "
             SPACING < cut_sameNetMinSpacing
             FLAG_DISCONNECTED = FALSE
             SET_CORNERS_TO_SPACING = FALSE
             PARALLEL_POINT_PROJECTION = FALSE
             NON_PARALLEL = TRUE
             TOUCH = FALSE
             POINT_TOUCH = FALSE
        } (28 )
    } else {
        EXTERNAL default_via8  {
            COMMENT = "$layer_name SameNetSpc: same-net minimum spacing = cut_sameNetMinSpacing um (corner to corner spacing = cut_cornerMinSpacing um) "
            SPACING < cut_sameNetMinSpacing
            CONVEX_TO_CONVEX < cut_cornerMinSpacing
            FLAG_DISCONNECTED = FALSE
            NON_PARALLEL = TRUE
            POINT_TOUCH = TRUE
        } (28 )
    }
  } else {
    EXTERNAL default_via8  {
        COMMENT = "$layer_name SameNetSpc: same-net minimum spacing = cut_sameNetMinSpacing um"
        SPACING < cut_sameNetMinSpacing
	BOX_CORNER = FALSE 
        FLAG_DISCONNECTED = FALSE
	NON_PARALLEL = TRUE
	POINT_TOUCH = TRUE
    } (28 )
  }
  if (cut_cornerMinSpacing > 0) {
    if (cornerSpacingMode == 1) {
        /* Work around: CONVEX_TO_CONVEX [POINT_PROJECTION] has a bug */
        EXTERNAL default_via8  {
          SPACING <= 0
          CONVEX_TO_CONVEX [POINT_PROJECTION] < cut_cornerMinSpacing
          NON_PARALLEL = TRUE
          POINT_TOUCH = TRUE
          BOX_CORNER = FALSE
          NODAL = TRUE
        } TEMP = diffNet_corner_err1 
        EXTERNAL default_via8  {
          SPACING <= 0
          CONVEX_TO_CONVEX < cut_cornerMinSpacing
          NON_PARALLEL = TRUE
          POINT_TOUCH = TRUE
          BOX_CORNER = TRUE
          NODAL = TRUE
        } TEMP = diffNet_corner_err2 
        BOOLEAN diffNet_corner_err1 OR diffNet_corner_err2 {
          COMMENT = "$layer_name Spacing   : corner to corner spacing = cut_cornerMinSpacing um "
        } (28 )
        EXTERNAL default_via8  {
          COMMENT = "$layer_name Spacing   : minimum spacing = cut_minSpacing um"
          SPACING < cut_minSpacing
          SET_CORNERS_TO_SPACING = FALSE
          PARALLEL_POINT_PROJECTION = FALSE
          NON_PARALLEL = TRUE
          TOUCH = FALSE
          POINT_TOUCH = FALSE
          NODAL = TRUE
        } (28 )
    } else {
        EXTERNAL default_via8  {
          COMMENT = "$layer_name Spacing   : minimum spacing = cut_minSpacing um (corner to corner spacing = cut_cornerMinSpacing um) "
          SPACING < cut_minSpacing
          CONVEX_TO_CONVEX < cut_cornerMinSpacing
          NON_PARALLEL = TRUE
          POINT_TOUCH = TRUE
          NODAL = TRUE
        } (28 )
    }
  } else {
    EXTERNAL default_via8  {
      COMMENT = "$layer_name Spacing   : minimum spacing = cut_minSpacing um"
      SPACING < cut_minSpacing
      BOX_CORNER = FALSE 
      NON_PARALLEL = TRUE
      POINT_TOUCH = TRUE
      NODAL = TRUE
    } (28 ) 
  }
} else {
   if (cut_minSpacing > 0) {
     if (cut_cornerMinSpacing > 0) {
        if (cornerSpacingMode == 1) {
           /* Work around: CONVEX_TO_CONVEX [POINT_PROJECTION] has a bug */
           EXTERNAL default_via8  {
             SPACING <= 0
             CONVEX_TO_CONVEX [POINT_PROJECTION] < cut_cornerMinSpacing
             NON_PARALLEL = TRUE
             POINT_TOUCH = TRUE
             BOX_CORNER = FALSE 
           } TEMP = corner_err1 
           EXTERNAL default_via8  {
             SPACING <= 0
             CONVEX_TO_CONVEX < cut_cornerMinSpacing
             NON_PARALLEL = TRUE
             POINT_TOUCH = TRUE
             BOX_CORNER = TRUE
           } TEMP = corner_err2 
           BOOLEAN corner_err1 OR corner_err2 {
             COMMENT = "$layer_name Spacing   : corner to corner spacing = cut_cornerMinSpacing um "
           } (28 )
           EXTERNAL default_via8  {
             COMMENT = "$layer_name Spacing   : minimum spacing = cut_minSpacing um"
             SPACING < cut_minSpacing
             SET_CORNERS_TO_SPACING = FALSE
             PARALLEL_POINT_PROJECTION = FALSE
             NON_PARALLEL = TRUE
             TOUCH = FALSE
             POINT_TOUCH = FALSE
           } (28 )
        } else {
           EXTERNAL default_via8  {
             COMMENT = "$layer_name Spacing   : minimum spacing = cut_minSpacing um (corner to corner spacing = cut_cornerMinSpacing um) "
             SPACING < cut_minSpacing
             CONVEX_TO_CONVEX < cut_cornerMinSpacing
             NON_PARALLEL = TRUE
             POINT_TOUCH = TRUE
           } (28 )
        }
    } else {
       EXTERNAL default_via8  {
          COMMENT = "$layer_name Spacing   : minimum spacing = cut_minSpacing um"
          SPACING < cut_minSpacing
	  BOX_CORNER = FALSE 
	  NON_PARALLEL = TRUE
	  POINT_TOUCH = TRUE
       } (28 )
    }
  }
}
 
/*check blockage spacing*/
if (ignoreBlockage == 0) {
   if (!layer_empty (via8_blockage )) {
      if (cutBlkg_minSpacing > 0) {
	  EXTERNAL via8_blockage  via8  {
              COMMENT = "$layer_name Spacing   : contact & blockage minimum spacing = cutBlkg_minSpacing um"
	      SPACING < cutBlkg_minSpacing
	      BOX_CORNER = FALSE 
	      NON_PARALLEL = TRUE
	      POINT_TOUCH = TRUE
          } (28 )
      }
   }
}
/*check blockage overlap*/ 
/*check shorts between top_level routing and fram_blockages*/
if (cutBlkg_minSpacing > 0 || checkCrossHierShort > 0) {
   if (readCellView > 0) {
       COPY empty {} TEMP = real_blockage
       COPY via8  {} TEMP = top_cut
   } else {
       COPY via8_fram  {} TEMP = real_blockage
       COPY via8_top  {} TEMP = top_cut
   }
   if (ignoreBlockage == 0) {
      BOOLEAN via8_blockage  OR real_blockage {} TEMP=all_blockage
   } else {
      COPY real_blockage {} TEMP=all_blockage
   }
   
   BOOLEAN all_blockage AND top_cut {} TEMP = overlap_shape1
   EXTERNAL all_blockage top_cut {
      SPACING <= 0
      TOUCH = TRUE
   } TEMP = overlap_shape2
   if (checkCrossHierShort > 0) {
      BOOLEAN overlap_shape1 OR overlap_shape2 {
          COMMENT = "$layer_name Short Cross Hierarchy"
      } (28 )
   } else {
      BOOLEAN overlap_shape1 OR overlap_shape2 {
          COMMENT = "$layer_name Overlap   : cut & blockage overlap"
      } (28 )
   }
}
/*check adjacent via number*/
if (cut_adjacentCutRange > 0 && cut_maxNumAdjacentCut > 0) {
    if (router_ignoreSameNetAdjacentViaDRC) {
       EXTERNAL via8  {  
	   SPACING < cut_adjacentCutRange
	   SET_CORNERS_TO_SPACING = FALSE
	   PARALLEL_POINT_PROJECTION = FALSE
	   NON_PARALLEL = TRUE
	   BOX_CORNER = FALSE
	   SHADOW = FALSE
           NODAL = TRUE
       } TEMP=edge_spacing
       EXTERNAL via8  {
	   SPACING < 0
	   CONVEX_TO_EDGE < cut_adjacentCutRange
	   CONVEX_TO_CONVEX < cut_adjacentCutRange
	   BOX_CORNER = FALSE
	   SHADOW = FALSE
           NODAL = TRUE
       } TEMP=corner_spacing
    } else {
       EXTERNAL via8  {  
	   SPACING < cut_adjacentCutRange
	   SET_CORNERS_TO_SPACING = FALSE
	   PARALLEL_POINT_PROJECTION = FALSE
	   NON_PARALLEL = TRUE
	   BOX_CORNER = FALSE
	   SHADOW = FALSE
       } TEMP=edge_spacing
 
       EXTERNAL via8  {
	   SPACING < 0
	   CONVEX_TO_EDGE < cut_adjacentCutRange
	   CONVEX_TO_CONVEX < cut_adjacentCutRange
	   BOX_CORNER = FALSE
	   SHADOW = FALSE
       } TEMP=corner_spacing
    }
    SIZE edge_spacing { UNDERSIZE = 0.001  } TEMP = edge_spacing1
    SIZE edge_spacing1 { OVERSIZE = 0.001  } TEMP = edge_spacing2
    BOOLEAN (edge_spacing NOT edge_spacing2) OR edge_spacing1 { } TEMP=edge_spacing
 
    SIZE corner_spacing { UNDERSIZE = 0.001  } TEMP = corner_spacing1
    SIZE corner_spacing1 { OVERSIZE = 0.001  } TEMP = corner_spacing2
    BOOLEAN (corner_spacing NOT corner_spacing2) OR corner_spacing1 { } TEMP=corner_spacing
  
    BOOLEAN edge_spacing OR corner_spacing { } TEMP = spacing
 
    SIZE via8  { OVERSIZE = 5* 0.001  } TEMP = cut
 
    SELECT cut INTERACT spacing {
        POINT_TOUCH = TRUE
        RANGE = [cut_maxNumAdjacentCut + 1, 9999999999 ]
    } TEMP = enclosed_cut
 
    SELECT via8  INSIDE enclosed_cut {
        COMMENT = "$layer_name AdjContNum: maximum number of the adjacent contacts ( cut_adjacentCutRange um) = cut_maxNumAdjacentCut "
    } (28 )
}
 
/*check enclosed via spacing*/
if (cut_enclosedCutNeighborRange > 0 && cut_enclosedCutNumNeighbor > 0) {
    if (cut_enclosedCutDiagViaExcluded) {
       EXTERNAL via8  {
          SPACING < cut_enclosedCutNeighborRange
          SET_CORNERS_TO_SPACING = FALSE
          PARALLEL_POINT_PROJECTION = FALSE
          NON_PARALLEL = TRUE
          BOX_CORNER = FALSE
          SHADOW = FALSE
       } TEMP = edge_spacing
       SELECT via8  TOUCHING edge_spacing {
          RANGE = [cut_enclosedCutNumNeighbor, 9999999999 ]
       } TEMP = enclosed_cut
    } else {
       /* Work around: for SIZE_RECT FLAG_INTERACTION_COUNT parser bug */
       
@ 308 "adrc/adrc_check_via.ev"
       if (cut_enclosedCutNumNeighbor==1) {
          
@-         SIZE_RECT via8  { 
@-            RANGE1=[0, 10] 
@-            RANGE2=[0, 10] 
@-            RANGE1_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0005 ) 
@-            RANGE2_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0005 ) 
@-            FLAG_INTERACTION_COUNT >  0  
@-            CORNER_METHOD = RADIAL 
@-         } TEMP=enclosed_cut 
       } else if (cut_enclosedCutNumNeighbor==2) {
          
@-         SIZE_RECT via8  { 
@-            RANGE1=[0, 10] 
@-            RANGE2=[0, 10] 
@-            RANGE1_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0005 ) 
@-            RANGE2_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0005 ) 
@-            FLAG_INTERACTION_COUNT >  1  
@-            CORNER_METHOD = RADIAL 
@-         } TEMP=enclosed_cut 
       } else if (cut_enclosedCutNumNeighbor==3) {
          
@-         SIZE_RECT via8  { 
@-            RANGE1=[0, 10] 
@-            RANGE2=[0, 10] 
@-            RANGE1_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0005 ) 
@-            RANGE2_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0005 ) 
@-            FLAG_INTERACTION_COUNT >  2  
@-            CORNER_METHOD = RADIAL 
@-         } TEMP=enclosed_cut 
       } else if (cut_enclosedCutNumNeighbor==4) {
          
@-         SIZE_RECT via8  { 
@-            RANGE1=[0, 10] 
@-            RANGE2=[0, 10] 
@-            RANGE1_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0005 ) 
@-            RANGE2_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0005 ) 
@-            FLAG_INTERACTION_COUNT >  3  
@-            CORNER_METHOD = RADIAL 
@-         } TEMP=enclosed_cut 
       } else if (cut_enclosedCutNumNeighbor==5) {
          
@-         SIZE_RECT via8  { 
@-            RANGE1=[0, 10] 
@-            RANGE2=[0, 10] 
@-            RANGE1_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0005 ) 
@-            RANGE2_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0005 ) 
@-            FLAG_INTERACTION_COUNT >  4  
@-            CORNER_METHOD = RADIAL 
@-         } TEMP=enclosed_cut 
       } else if (cut_enclosedCutNumNeighbor==6) {
          
@-         SIZE_RECT via8  { 
@-            RANGE1=[0, 10] 
@-            RANGE2=[0, 10] 
@-            RANGE1_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0005 ) 
@-            RANGE2_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0005 ) 
@-            FLAG_INTERACTION_COUNT >  5  
@-            CORNER_METHOD = RADIAL 
@-         } TEMP=enclosed_cut 
       } else if (cut_enclosedCutNumNeighbor==7) {
          
@-         SIZE_RECT via8  { 
@-            RANGE1=[0, 10] 
@-            RANGE2=[0, 10] 
@-            RANGE1_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0005 ) 
@-            RANGE2_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0005 ) 
@-            FLAG_INTERACTION_COUNT >  6  
@-            CORNER_METHOD = RADIAL 
@-         } TEMP=enclosed_cut 
       } else if (cut_enclosedCutNumNeighbor==8) {
          
@-         SIZE_RECT via8  { 
@-            RANGE1=[0, 10] 
@-            RANGE2=[0, 10] 
@-            RANGE1_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0005 ) 
@-            RANGE2_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0005 ) 
@-            FLAG_INTERACTION_COUNT >  7  
@-            CORNER_METHOD = RADIAL 
@-         } TEMP=enclosed_cut 
       } else if (cut_enclosedCutNumNeighbor==9) {
          
@-         SIZE_RECT via8  { 
@-            RANGE1=[0, 10] 
@-            RANGE2=[0, 10] 
@-            RANGE1_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0005 ) 
@-            RANGE2_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0005 ) 
@-            FLAG_INTERACTION_COUNT >  8  
@-            CORNER_METHOD = RADIAL 
@-         } TEMP=enclosed_cut 
       } else if (cut_enclosedCutNumNeighbor>9) {
          
@-         SIZE_RECT via8  { 
@-            RANGE1=[0, 10] 
@-            RANGE2=[0, 10] 
@-            RANGE1_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0005 ) 
@-            RANGE2_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0005 ) 
@-            FLAG_INTERACTION_COUNT >  9  
@-            CORNER_METHOD = RADIAL 
@-         } TEMP=enclosed_cut 
       }
    }
    if (router_ignoreSameNetAdjacentViaDRC) {
      /* Good approximation for same net via filter */
      CENTER_TO_CENTER via8  {
        NODAL=TRUE
        SPACING < cut_enclosedCutNeighborRange + 1.41421*cut_size + 0.0005 
        OUTPUT_VECTOR = TRUE
      } TEMP = c2c_spacing
      SIZE via8  { UNDERSIZE = (cut_size/2.0- 0.0005 ) } TEMP=cut_center
      BOOLEAN c2c_spacing NOT cut_center { } TEMP=c2c_spacing
      SIZE cut_center { OVERSIZE = 0.001  } TEMP=cut_center
      BOOLEAN c2c_spacing AND via8   { } TEMP=c2c_filter
      SELECT cut_center INTERACT c2c_filter {
        POINT_TOUCH=TRUE
        RANGE = [cut_enclosedCutNumNeighbor, 9999999999 ]
      } TEMP = target_cut
   
      SELECT enclosed_cut ENCLOSING target_cut { } TEMP = enclosed_cut
    }
  
    if (cut_enclosedCutMinSpacing > 0) {
        EXTERNAL enclosed_cut {
        COMMENT = "$layer_name EncContSpc: minimum spacing between enclosed contacts ( cut_enclosedCutNeighborRange um / cut_enclosedCutNumNeighbor ) = cut_enclosedCutMinSpacing "
            SPACING < cut_enclosedCutMinSpacing
            SET_CORNERS_TO_SPACING = TRUE 
	    BOX_CORNER = FALSE 
	    NON_PARALLEL = TRUE
	    POINT_TOUCH = TRUE
        } (28 )
    }
 
    if (cut_enclosedCutToNeighborMinSpacing > 0) {
       if (router_ignoreSameNetAdjacentViaDRC) {
          CONNECT { enclosed_cut BY via8  }
          EXTERNAL enclosed_cut via8  {
              COMMENT = "$layer_name EncContSpc: minimum spacing between enclosed and neighboring contacts ( cut_enclosedCutNeighborRange um / cut_enclosedCutNumNeighbor ) = cut_enclosedCutToNeighborMinSpacing "
              SPACING < cut_enclosedCutToNeighborMinSpacing
              SET_CORNERS_TO_SPACING = TRUE 
	      BOX_CORNER = FALSE 
	      NON_PARALLEL = TRUE
	      POINT_TOUCH = TRUE
              NODAL = TRUE
          } (28 )
       } else {
          EXTERNAL enclosed_cut via8  {
              COMMENT = "$layer_name EncContSpc: minimum spacing between enclosed and neighboring contacts ( cut_enclosedCutNeighborRange um / cut_enclosedCutNumNeighbor ) = cut_enclosedCutToNeighborMinSpacing "
              SPACING < cut_enclosedCutToNeighborMinSpacing
              SET_CORNERS_TO_SPACING = TRUE 
	      BOX_CORNER = FALSE 
	      NON_PARALLEL = TRUE
	      POINT_TOUCH = TRUE
          } (28 )
       }
    }
}
 
/*check max stack level, upward only*/
if (cut_maxStackLevel > 0 && cut_stackLevelSpacing > 0) {
    if (cut_maxStackLevel == 1) {
      BOOLEAN via8  AND CUT_LAYER1 { } TEMP = neighbors
    }
    else if (cut_maxStackLevel == 2) {
      BOOLEAN (via8  AND CUT_LAYER1) AND CUT_LAYER2 { } TEMP = neighbors
    }
    else if (cut_maxStackLevel == 3) {
      BOOLEAN (via8  AND CUT_LAYER1) AND (CUT_LAYER2 AND CUT_LAYER3)
        { } TEMP = neighbors
    }
    else if (cut_maxStackLevel == 4) {
      BOOLEAN ((via8  AND CUT_LAYER1) AND (CUT_LAYER2 AND CUT_LAYER3))
        AND CUT_LAYER4 { } TEMP = neighbors
    }
    else if (cut_maxStackLevel == 5) {
      BOOLEAN ((via8  AND CUT_LAYER1) AND (CUT_LAYER2 AND CUT_LAYER3))
        AND (CUT_LAYER4 AND CUT_LAYER5) { } TEMP = neighbors
    }
    else if (cut_maxStackLevel == 6) {
      BOOLEAN ((via8  AND CUT_LAYER1) AND (CUT_LAYER2 AND CUT_LAYER3))
        AND ((CUT_LAYER4 AND CUT_LAYER5) AND CUT_LAYER6) { } TEMP = neighbors
    }
    else if (cut_maxStackLevel >= 7) { 
      BOOLEAN ((via8  AND CUT_LAYER1) AND (CUT_LAYER2 AND CUT_LAYER3))
        AND ((CUT_LAYER4 AND CUT_LAYER5) AND (CUT_LAYER6 AND CUT_LAYER7))
       { } TEMP = neighbors
    }
 
    if (!layer_empty(neighbors)) {
      SELECT CUT_LAYER0 INTERACT neighbors {
        LINE_TOUCH = FALSE POINT_TOUCH = FALSE 
      } TEMP = neighbors
      EXTERNAL neighbors {
	spacing <= cut_stackLevelSpacing
      } TEMP = via_arr_ext
      if (!layer_empty (via_arr_ext)) {
	SELECT neighbors OUTSIDE via_arr_ext {
         COMMENT = "$layer_name StackLevel: maximum stack level = cut_maxStackLevel "
          LINE_TOUCH = FALSE
          POINT_TOUCH = FALSE	    
        } (28 )
      }
      else {
        BOOLEAN via8  AND neighbors {
            COMMENT = "$layer_name StackLevel: maximum stack level = cut_maxStackLevel "
        } (28 )
      }
    }
  }
  else if (cut_maxStackLevel > 0) {
    if (cut_maxStackLevel == 1) {
      COPY CUT_LAYER1 { } TEMP = neighbors
    }
    else if (cut_maxStackLevel == 2) {
      BOOLEAN CUT_LAYER1 AND CUT_LAYER2 { } TEMP = neighbors
    }
    else if (cut_maxStackLevel == 3) {
      BOOLEAN CUT_LAYER1 AND (CUT_LAYER2 AND CUT_LAYER3)
        { } TEMP = neighbors
    }
    else if (cut_maxStackLevel == 4) {
      BOOLEAN (CUT_LAYER1 AND CUT_LAYER2) AND (CUT_LAYER3 AND CUT_LAYER4)
        { } TEMP = neighbors
    }
    else if (cut_maxStackLevel == 5) {
      BOOLEAN ((CUT_LAYER1 AND CUT_LAYER2) AND (CUT_LAYER3 AND CUT_LAYER4))
        AND CUT_LAYER5 { } TEMP = neighbors
    }
    else if (cut_maxStackLevel == 6) {
      BOOLEAN ((CUT_LAYER6 AND CUT_LAYER1) AND (CUT_LAYER2 AND CUT_LAYER3))
        AND (CUT_LAYER4 AND CUT_LAYER5) { } TEMP = neighbors
    }
    else if (cut_maxStackLevel >= 7) { 
      BOOLEAN ((CUT_LAYER7 AND CUT_LAYER1) AND (CUT_LAYER2 AND CUT_LAYER3))
        AND ((CUT_LAYER4 AND CUT_LAYER5) AND CUT_LAYER6) { } TEMP = neighbors
    }
 
    if (!layer_empty (neighbors)) {
        BOOLEAN via8  AND neighbors {
            COMMENT = "$layer_name StackLevel: maximum stack level = cut_maxStackLevel "
        } (28 )
    }
}
 
/*Check fat contact*/
if (cut_fatContactMinSpacing > 0 && cut_fatTblDimension == 0) {
    if (cut_fatContactThreshold1 > 0) {
    	SIZE metal8    { UNDER_OVER = cut_fatContactThreshold1 / 2.0 - 0.0005  } TEMP = m_fat
    	BOOLEAN m_fat AND metal8  { } TEMP = m_fat
 
    	SELECT via8  INSIDE  m_fat { } TEMP = v_fat
 
    	EXTERNAL v_fat via8  {
            COMMENT = "$layer_name FatContSpc: fat contact ( cut_fatContactThreshold1 um, lower layer) minimum spacing = cut_fatContactMinSpacing um"
            SPACING < cut_fatContactMinSpacing
	    BOX_CORNER = FALSE 
	    NON_PARALLEL = TRUE
	    POINT_TOUCH = TRUE
        } (28 )
    }
 
    if (cut_fatContactThreshold2 > 0) {
    	SIZE metal9    { UNDER_OVER = cut_fatContactThreshold2 / 2.0 - 0.0005  } TEMP = m_fat
    	BOOLEAN m_fat AND metal9  { } TEMP = m_fat
 
    	SELECT via8  INSIDE  m_fat { } TEMP = v_fat
 
    	EXTERNAL v_fat via8  {
            COMMENT = "$layer_name FatContSpc: fat contact ( cut_fatContactThreshold2 um, upper layer) minimum spacing = cut_fatContactMinSpacing um"
            SPACING < cut_fatContactMinSpacing
	    BOX_CORNER = FALSE 
	    NON_PARALLEL = TRUE
	    POINT_TOUCH = TRUE
        } (28 )
    }
}
/* Avoid empty optimization result parsing error */
if (addEmptyViaCheck) {
   BOOLEAN empty OR empty {
      COMMENT = "$layer_name Empty: Dummy Output"
   } (28 )
   SET addEmptyViaCheck=0;
}
 
/* reset variables */















SET cut_size = 0;
SET cut_minSpacing = 0;
SET cut_sameNetMinSpacing = 0;
SET cut_cornerMinSpacing = 0;
SET cutBlkg_minSpacing = 0;
SET cut_maxNumAdjacentCut = 0;
SET cut_adjacentCutRange = 0;
SET cut_enclosedCutNeighborRange = 0;
SET cut_enclosedCutNumNeighbor = 0;
SET cut_enclosedCutMinSpacing = 0;
SET cut_enclosedCutToNeighborMinSpacing = 0;
SET cut_enclosedCutDiagViaExcluded = 0;
SET cut_maxStackLevel = 0;
SET cut_defaultContactMinSpacing = 0;
SET cut_fatContactThreshold1 = 0;
SET cut_fatContactThreshold2 = 0;
SET cut_fatContactMinSpacing = 0;
SET cut_maxCutSpacing = 0; 
SET cut_fatTblDimension = 0;
SET cut_fatTblThreshold_1 = 0;
SET cut_fatTblThreshold_2 = 0;
SET cut_fatTblNextThreshold_1 = 0;
SET cut_fatTblNextThreshold_2 = 0;
SET cut_fatTblMinCuts = 0;
SET cut_fatTblMinSpacing = 0;
SET cut_fatTblExtensionRange = 0;
SET cut_fatTblExtensionMinCuts = 0;
SET cut_fatTblExtensionMinSpacing = 0;
@ 631 "adrc/adrc.ev" 2











/*Via/Via design rules*/

/*Via/Metal design rules*/
SET diff_endOfLineMode = 0;

/*via 1 / metal 1*/
SET layer_name = "V1/M1";






if (!layer_empty (via1 )) {
    if (!layer_empty (metal1 )) {
        
@ 1 "adrc/adrc_check_diff.ev" 1
/*check spacing*/
if (diff_minSpacing > 0 && diff_netMinSpacing > 0) {
    if (diff_cornerMinSpacing > 0) {
        if (cornerSpacingMode == 1) {
            /* Work around: CONVEX_TO_CONVEX [POINT_PROJECTION] has a bug */
            EXTERNAL via1  metal1  {
                SPACING <= 0
                CONVEX_TO_CONVEX [POINT_PROJECTION] < diff_cornerMinSpacing
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                BOX_CORNER = FALSE
                NODAL = TRUE
            } TEMP = diffNet_corner_err1
            EXTERNAL via1  metal1  {
                SPACING <= 0
                CONVEX_TO_CONVEX < diff_cornerMinSpacing
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                BOX_CORNER = TRUE
                NODAL = TRUE
            } TEMP = diffNet_corner_err2
            BOOLEAN diffNet_corner_err1 OR diffNet_corner_err2 {
                COMMENT = "$layer_name Spacing   : corner to corner spacing = diff_cornerMinSpacing um "
            } (11 )
            EXTERNAL via1  metal1  {
                COMMENT = "$layer_name Spacing   : minimum spacing = diff_netMinSpacing um"
                SPACING < diff_netMinSpacing
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                NON_PARALLEL = TRUE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
                NODAL = TRUE
            } (11 )
        } else {
            EXTERNAL via1  metal1  {
                COMMENT = "$layer_name Spacing  : minimum spacing = diff_netMinSpacing um (corner to corner spacing = diff_cornerMinSpacing um)"
                SPACING < diff_netMinSpacing
                CONVEX_TO_CONVEX < diff_cornerMinSpacing
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                TOUCH = TRUE
                NODAL = TRUE
            } (11 )
        }
    } else {
        EXTERNAL via1  metal1  {
            COMMENT = "$layer_name Spacing  : minimum spacing = diff_netMinSpacing um"
            SPACING < diff_netMinSpacing
            NON_PARALLEL = TRUE
            POINT_TOUCH = TRUE
            TOUCH = TRUE
            NODAL = TRUE
        } (11 )
    }
    if (diff_cornerMinSpacing > 0) {
        if (cornerSpacingMode == 1) {
            /* Work around: CONVEX_TO_CONVEX [POINT_PROJECTION] has a bug */
            EXTERNAL via1  metal1  {
                SPACING <= 0
                CONVEX_TO_CONVEX [POINT_PROJECTION] < diff_cornerMinSpacing
                FLAG_DISCONNECTED = FALSE
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                BOX_CORNER = FALSE
            } TEMP = sameNet_corner_err1
            EXTERNAL via1  metal1  {
                SPACING <= 0
                CONVEX_TO_CONVEX < diff_cornerMinSpacing
                FLAG_DISCONNECTED = FALSE
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                BOX_CORNER = TRUE
            } TEMP = sameNet_corner_err2
            BOOLEAN sameNet_corner_err1 OR sameNet_corner_err2 {
                COMMENT = "$layer_name Spacing   : corner to corner spacing = diff_cornerMinSpacing um "
            } (11 )
            EXTERNAL via1  metal1  {
                COMMENT = "$layer_name Spacing   : minimum spacing = diff_minSpacing um"
                SPACING < diff_minSpacing
                FLAG_DISCONNECTED = FALSE
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                NON_PARALLEL = TRUE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
            } (11 )
        } else {
            EXTERNAL via1  metal1  {
                COMMENT = "$layer_name Spacing  : minimum spacing = diff_minSpacing um (corner to corner spacing = diff_cornerMinSpacing um)"
                SPACING < diff_minSpacing
                CONVEX_TO_CONVEX < diff_cornerMinSpacing
                FLAG_DISCONNECTED = FALSE
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                TOUCH = TRUE
            } (11 )
        }
    } else {
        EXTERNAL via1  metal1  {
            COMMENT = "$layer_name Spacing  : minimum spacing = diff_minSpacing um"
            SPACING < diff_minSpacing
            FLAG_DISCONNECTED = FALSE
            NON_PARALLEL = TRUE
            POINT_TOUCH = TRUE
            TOUCH = TRUE
        } (11 )
    }
} else {
    if (diff_netMinSpacing > 0) {
        if (diff_cornerMinSpacing > 0) {
            if (cornerSpacingMode == 1) {
                /* Work around: CONVEX_TO_CONVEX [POINT_PROJECTION] has a bug */
                EXTERNAL via1  metal1  {
                    SPACING <= 0
                    CONVEX_TO_CONVEX [POINT_PROJECTION] < diff_cornerMinSpacing
                    NON_PARALLEL = TRUE
                    POINT_TOUCH = TRUE
                    BOX_CORNER = FALSE
                    NODAL = TRUE
                } TEMP = corner_err1
                EXTERNAL via1  metal1  {
                    SPACING <= 0
                    CONVEX_TO_CONVEX < diff_cornerMinSpacing
                    NON_PARALLEL = TRUE
                    POINT_TOUCH = TRUE
                    BOX_CORNER = TRUE
                    NODAL = TRUE
                } TEMP = corner_err2
                BOOLEAN corner_err1 OR corner_err2 {
                    COMMENT = "$layer_name Spacing   : corner to corner spacing = diff_cornerMinSpacing um "
                } (11 )
                EXTERNAL via1  metal1  {
                    COMMENT = "$layer_name Spacing   : minimum spacing = diff_netMinSpacing um"
                    SPACING < diff_netMinSpacing
                    SET_CORNERS_TO_SPACING = FALSE
                    PARALLEL_POINT_PROJECTION = FALSE
                    NON_PARALLEL = TRUE
                    TOUCH = FALSE
                    POINT_TOUCH = FALSE
                    NODAL = TRUE
                } (11 )
            } else {
                EXTERNAL via1  metal1  {
                    COMMENT = "$layer_name Spacing  : minimum spacing = diff_netMinSpacing um (corner to corner spacing = diff_cornerMinSpacing um)"
                    SPACING < diff_netMinSpacing
                    CONVEX_TO_CONVEX < diff_cornerMinSpacing
                    NON_PARALLEL = TRUE
                    POINT_TOUCH = TRUE
                    TOUCH = TRUE
                    NODAL = TRUE
                } (11 )
            }
        } else {
            EXTERNAL via1  metal1  {
                COMMENT = "$layer_name Spacing  : minimum spacing = diff_netMinSpacing um"
                SPACING < diff_netMinSpacing
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                TOUCH = TRUE
                NODAL = TRUE
            } (11 )
        }
    } else if (diff_minSpacing > 0) {
        if (diff_cornerMinSpacing > 0) {
            if (cornerSpacingMode == 1) {
                /* Work around: CONVEX_TO_CONVEX [POINT_PROJECTION] has a bug */
                EXTERNAL via1  metal1  {
                    SPACING <= 0
                    CONVEX_TO_CONVEX [POINT_PROJECTION] < diff_cornerMinSpacing
                    NON_PARALLEL = TRUE
                    POINT_TOUCH = TRUE
                    BOX_CORNER = FALSE
                } TEMP = corner_err1
                EXTERNAL via1  metal1  {
                    SPACING <= 0
                    CONVEX_TO_CONVEX < diff_cornerMinSpacing
                    NON_PARALLEL = TRUE
                    POINT_TOUCH = TRUE
                    BOX_CORNER = TRUE
                } TEMP = corner_err2
                BOOLEAN corner_err1 OR corner_err2 {
                    COMMENT = "$layer_name Spacing   : corner to corner spacing = diff_cornerMinSpacing um "
                } (11 )
                EXTERNAL via1  metal1  {
                    COMMENT = "$layer_name Spacing   : minimum spacing = diff_minSpacing um"
                    SPACING < diff_minSpacing
                    SET_CORNERS_TO_SPACING = FALSE
                    PARALLEL_POINT_PROJECTION = FALSE
                    NON_PARALLEL = TRUE
                    TOUCH = FALSE
                    POINT_TOUCH = FALSE
                } (11 )
            } else {
                EXTERNAL via1  metal1  {
                    COMMENT = "$layer_name Spacing  : minimum spacing = diff_minSpacing um (corner to corner spacing = diff_cornerMinSpacing um)"
                    SPACING < diff_minSpacing
                    CONVEX_TO_CONVEX < diff_cornerMinSpacing
                    NON_PARALLEL = TRUE
                    POINT_TOUCH = TRUE
                    TOUCH = TRUE
                } (11 )
            }
        } else {
            EXTERNAL via1  metal1  {
                COMMENT = "$layer_name Spacing  : minimum spacing = diff_minSpacing um"
                SPACING < diff_minSpacing
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                TOUCH = TRUE
            } (11 )
        }
    }
}
 
/*check enclosure*/
if (diff_minEnclosure > 0) {
    ENCLOSE via1  BY metal1  {
        COMMENT = "$layer_name Enclosure: minimum enclosure ( diff_minEnclosure )"
        SPACING < diff_minEnclosure
	NON_PARALLEL = TRUE
	POINT_TOUCH = TRUE
	TOUCH = TRUE
    } (11 )
    BOOLEAN via1  NOT metal1  {
        COMMENT = "$layer_name Enclosure: minimum enclosure ( diff_minEnclosure )"
    } (11 )
}
 
/*check end_of_line enclosure*/
if (diff_endOfLineEnclosure > 0) {
    if (diff_minEnclosure  == 0) {
       BOOLEAN via1  NOT metal1  {
           COMMENT = "$layer_name EndOfLine: end-of-line minimum enclosure ( diff_endOfLineEnclosure )"
       } (11 )
    }
    if (diff_endOfLineMode == 0) {
        ENCLOSE via1  BY metal1  {
	    SPACING < diff_endOfLineEnclosure
	    SET_CORNERS_TO_SPACING = FALSE
	    PARALLEL_POINT_PROJECTION = FALSE
	    SHADOW_OTHER_LAYER = TRUE  
	    TOUCH = TRUE
	    POINT_TOUCH = FALSE
	    NON_PARALLEL = TRUE
            OUTPUT_EDGES = TRUE
        } TEMP = violation
 
        SELECT_EDGE via1  TOUCHING violation {  } TEMP = edges
        SELECT_VECTOR edges { ANGLE_RANGE = [0, 0] } TEMP = h_edges
        SELECT_VECTOR edges { ANGLE_RANGE = [90, 90] } TEMP = v_edges
        SELECT h_edges INTERACT v_edges { POINT_TOUCH = TRUE } TEMP = h_edges
 
        SELECT via1  ENCLOSING h_edges {
            COMMENT = "$layer_name EndOfLine: end-of-line minimum enclosure ( diff_endOfLineEnclosure )"
        } (11 )
    }
    else {
    }
}
 
/*check stackable*/
if (diff_not_stackable > 0) {
     BOOLEAN via1  AND metal1  {
        COMMENT = "$layer_name Stackable: not stackable"
    } (11 )
}
/*check fat metal via keep-out area*/
if (diff_fatTblViaKeepoutThreshold > 0 && diff_fatTblViaKeepoutMinSize > 0 && diff_fatTblViaKeepoutEnclosure > 0) {
    if (diff_fatTblViaKeepoutThreshold > 0) {
        if ((diff_fatTblViaKeepoutThreshold / 2.0) > 0.0005 ) {
           SIZE metal1  { UNDER_OVER = diff_fatTblViaKeepoutThreshold / 2.0 - 0.0005  } TEMP = fat_candidate
           if (diff_fatTblViaKeepoutNextThreshold > 0) {
              SIZE fat_candidate { UNDER_OVER = diff_fatTblViaKeepoutNextThreshold / 2.0 - 0.0005  } TEMP = fat_next
              BOOLEAN fat_candidate NOT fat_next { } TEMP = fat
              BOOLEAN fat AND metal1  { } TEMP = fat
              SET diff_fatTblViaKeepoutNextThreshold = 0;
           } else {
              BOOLEAN fat_candidate AND metal1  {  } TEMP = fat
           }
        } else {
           COPY metal1  { } TEMP = fat
           COPY metal1  { } TEMP = fat_candidate 
        }
    }
    VERTEX fat_candidate {
       CONVEX = TRUE
       SIZE = 0.001 
    } TEMP = fat_corners
    VERTEX fat {
       CONVEX = TRUE
       SIZE = 0.001 
    } TEMP = wire_corners
    SELECT wire_corners INTERACT fat_corners { } TEMP = wire_corners
    SELECT_EDGE fat INTERACT wire_corners { } TEMP = edge_corners
    SELECT_VECTOR edge_corners {
       LENGTH_RANGE = [0, diff_fatTblViaKeepoutMinSize- 0.0005 ]
    } TEMP = edge_tmp1
    BOOLEAN edge_corners NOT edge_tmp1 { } TEMP = edge_tmp2
    SELECT wire_corners OUTSIDE edge_tmp1 {  } TEMP = real_corners
    BOOLEAN edge_tmp2 AND real_corners { } TEMP = real_edge
    SIZE real_edge {
       VSIZE_HEAD = diff_fatTblViaKeepoutMinSize-2* 0.001 
       VSIZE_TAIL = diff_fatTblViaKeepoutMinSize-2* 0.001 
       VSIZE_INSIDE = diff_fatTblViaKeepoutEnclosure- 0.001 
    } TEMP = forb_corners
    SELECT via1  INSIDE fat { } TEMP = v_fat
    /* Work around: need an accurate via_cluster */
    SELECT via_cluster INSIDE fat { } TEMP = v_fat_cluster
    SELECT v_fat INTERACT forb_corners { } TEMP = bad_vias
    BOOLEAN v_fat NOT bad_vias { } TEMP = good_vias
    SELECT v_fat_cluster OUTSIDE good_vias { } TEMP = bad_v_fat_cluster
    SELECT v_fat INTERACT bad_v_fat_cluster {
       COMMENT = "$layer_name ViaKepOut: fat metal ( diff_fatTblViaKeepoutThreshold um) contact keep-out area ( diff_fatTblViaKeepoutMinSize um, diff_fatTblViaKeepoutEnclosure um) "
    } (11 )
}
 
/* reset variables */



 
SET diff_minSpacing = 0;
SET diff_netMinSpacing = 0;
SET diff_cornerMinSpacing = 0;
SET diff_minEnclosure = 0;
SET diff_endOfLineEnclosure = 0;
SET diff_not_stackable = 0;
SET diff_fatTblViaKeepoutThreshold = 0;
SET diff_fatTblViaKeepoutNextThreshold = 0;
SET diff_fatTblViaKeepoutMinSize = 0;
SET diff_fatTblViaKeepoutEnclosure = 0;
@ 657 "adrc/adrc.ev" 2

    }
}
DISCONNECT


/*via 2 / metal 2*/
SET layer_name = "V2/M2";





LOAD_CONNECT_DB all_layer

if (!layer_empty (via2 )) {
    if (!layer_empty (metal2 )) {
        
@ 1 "adrc/adrc_check_diff.ev" 1
/*check spacing*/
if (diff_minSpacing > 0 && diff_netMinSpacing > 0) {
    if (diff_cornerMinSpacing > 0) {
        if (cornerSpacingMode == 1) {
            /* Work around: CONVEX_TO_CONVEX [POINT_PROJECTION] has a bug */
            EXTERNAL via2  metal2  {
                SPACING <= 0
                CONVEX_TO_CONVEX [POINT_PROJECTION] < diff_cornerMinSpacing
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                BOX_CORNER = FALSE
                NODAL = TRUE
            } TEMP = diffNet_corner_err1
            EXTERNAL via2  metal2  {
                SPACING <= 0
                CONVEX_TO_CONVEX < diff_cornerMinSpacing
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                BOX_CORNER = TRUE
                NODAL = TRUE
            } TEMP = diffNet_corner_err2
            BOOLEAN diffNet_corner_err1 OR diffNet_corner_err2 {
                COMMENT = "$layer_name Spacing   : corner to corner spacing = diff_cornerMinSpacing um "
            } (12 )
            EXTERNAL via2  metal2  {
                COMMENT = "$layer_name Spacing   : minimum spacing = diff_netMinSpacing um"
                SPACING < diff_netMinSpacing
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                NON_PARALLEL = TRUE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
                NODAL = TRUE
            } (12 )
        } else {
            EXTERNAL via2  metal2  {
                COMMENT = "$layer_name Spacing  : minimum spacing = diff_netMinSpacing um (corner to corner spacing = diff_cornerMinSpacing um)"
                SPACING < diff_netMinSpacing
                CONVEX_TO_CONVEX < diff_cornerMinSpacing
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                TOUCH = TRUE
                NODAL = TRUE
            } (12 )
        }
    } else {
        EXTERNAL via2  metal2  {
            COMMENT = "$layer_name Spacing  : minimum spacing = diff_netMinSpacing um"
            SPACING < diff_netMinSpacing
            NON_PARALLEL = TRUE
            POINT_TOUCH = TRUE
            TOUCH = TRUE
            NODAL = TRUE
        } (12 )
    }
    if (diff_cornerMinSpacing > 0) {
        if (cornerSpacingMode == 1) {
            /* Work around: CONVEX_TO_CONVEX [POINT_PROJECTION] has a bug */
            EXTERNAL via2  metal2  {
                SPACING <= 0
                CONVEX_TO_CONVEX [POINT_PROJECTION] < diff_cornerMinSpacing
                FLAG_DISCONNECTED = FALSE
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                BOX_CORNER = FALSE
            } TEMP = sameNet_corner_err1
            EXTERNAL via2  metal2  {
                SPACING <= 0
                CONVEX_TO_CONVEX < diff_cornerMinSpacing
                FLAG_DISCONNECTED = FALSE
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                BOX_CORNER = TRUE
            } TEMP = sameNet_corner_err2
            BOOLEAN sameNet_corner_err1 OR sameNet_corner_err2 {
                COMMENT = "$layer_name Spacing   : corner to corner spacing = diff_cornerMinSpacing um "
            } (12 )
            EXTERNAL via2  metal2  {
                COMMENT = "$layer_name Spacing   : minimum spacing = diff_minSpacing um"
                SPACING < diff_minSpacing
                FLAG_DISCONNECTED = FALSE
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                NON_PARALLEL = TRUE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
            } (12 )
        } else {
            EXTERNAL via2  metal2  {
                COMMENT = "$layer_name Spacing  : minimum spacing = diff_minSpacing um (corner to corner spacing = diff_cornerMinSpacing um)"
                SPACING < diff_minSpacing
                CONVEX_TO_CONVEX < diff_cornerMinSpacing
                FLAG_DISCONNECTED = FALSE
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                TOUCH = TRUE
            } (12 )
        }
    } else {
        EXTERNAL via2  metal2  {
            COMMENT = "$layer_name Spacing  : minimum spacing = diff_minSpacing um"
            SPACING < diff_minSpacing
            FLAG_DISCONNECTED = FALSE
            NON_PARALLEL = TRUE
            POINT_TOUCH = TRUE
            TOUCH = TRUE
        } (12 )
    }
} else {
    if (diff_netMinSpacing > 0) {
        if (diff_cornerMinSpacing > 0) {
            if (cornerSpacingMode == 1) {
                /* Work around: CONVEX_TO_CONVEX [POINT_PROJECTION] has a bug */
                EXTERNAL via2  metal2  {
                    SPACING <= 0
                    CONVEX_TO_CONVEX [POINT_PROJECTION] < diff_cornerMinSpacing
                    NON_PARALLEL = TRUE
                    POINT_TOUCH = TRUE
                    BOX_CORNER = FALSE
                    NODAL = TRUE
                } TEMP = corner_err1
                EXTERNAL via2  metal2  {
                    SPACING <= 0
                    CONVEX_TO_CONVEX < diff_cornerMinSpacing
                    NON_PARALLEL = TRUE
                    POINT_TOUCH = TRUE
                    BOX_CORNER = TRUE
                    NODAL = TRUE
                } TEMP = corner_err2
                BOOLEAN corner_err1 OR corner_err2 {
                    COMMENT = "$layer_name Spacing   : corner to corner spacing = diff_cornerMinSpacing um "
                } (12 )
                EXTERNAL via2  metal2  {
                    COMMENT = "$layer_name Spacing   : minimum spacing = diff_netMinSpacing um"
                    SPACING < diff_netMinSpacing
                    SET_CORNERS_TO_SPACING = FALSE
                    PARALLEL_POINT_PROJECTION = FALSE
                    NON_PARALLEL = TRUE
                    TOUCH = FALSE
                    POINT_TOUCH = FALSE
                    NODAL = TRUE
                } (12 )
            } else {
                EXTERNAL via2  metal2  {
                    COMMENT = "$layer_name Spacing  : minimum spacing = diff_netMinSpacing um (corner to corner spacing = diff_cornerMinSpacing um)"
                    SPACING < diff_netMinSpacing
                    CONVEX_TO_CONVEX < diff_cornerMinSpacing
                    NON_PARALLEL = TRUE
                    POINT_TOUCH = TRUE
                    TOUCH = TRUE
                    NODAL = TRUE
                } (12 )
            }
        } else {
            EXTERNAL via2  metal2  {
                COMMENT = "$layer_name Spacing  : minimum spacing = diff_netMinSpacing um"
                SPACING < diff_netMinSpacing
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                TOUCH = TRUE
                NODAL = TRUE
            } (12 )
        }
    } else if (diff_minSpacing > 0) {
        if (diff_cornerMinSpacing > 0) {
            if (cornerSpacingMode == 1) {
                /* Work around: CONVEX_TO_CONVEX [POINT_PROJECTION] has a bug */
                EXTERNAL via2  metal2  {
                    SPACING <= 0
                    CONVEX_TO_CONVEX [POINT_PROJECTION] < diff_cornerMinSpacing
                    NON_PARALLEL = TRUE
                    POINT_TOUCH = TRUE
                    BOX_CORNER = FALSE
                } TEMP = corner_err1
                EXTERNAL via2  metal2  {
                    SPACING <= 0
                    CONVEX_TO_CONVEX < diff_cornerMinSpacing
                    NON_PARALLEL = TRUE
                    POINT_TOUCH = TRUE
                    BOX_CORNER = TRUE
                } TEMP = corner_err2
                BOOLEAN corner_err1 OR corner_err2 {
                    COMMENT = "$layer_name Spacing   : corner to corner spacing = diff_cornerMinSpacing um "
                } (12 )
                EXTERNAL via2  metal2  {
                    COMMENT = "$layer_name Spacing   : minimum spacing = diff_minSpacing um"
                    SPACING < diff_minSpacing
                    SET_CORNERS_TO_SPACING = FALSE
                    PARALLEL_POINT_PROJECTION = FALSE
                    NON_PARALLEL = TRUE
                    TOUCH = FALSE
                    POINT_TOUCH = FALSE
                } (12 )
            } else {
                EXTERNAL via2  metal2  {
                    COMMENT = "$layer_name Spacing  : minimum spacing = diff_minSpacing um (corner to corner spacing = diff_cornerMinSpacing um)"
                    SPACING < diff_minSpacing
                    CONVEX_TO_CONVEX < diff_cornerMinSpacing
                    NON_PARALLEL = TRUE
                    POINT_TOUCH = TRUE
                    TOUCH = TRUE
                } (12 )
            }
        } else {
            EXTERNAL via2  metal2  {
                COMMENT = "$layer_name Spacing  : minimum spacing = diff_minSpacing um"
                SPACING < diff_minSpacing
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                TOUCH = TRUE
            } (12 )
        }
    }
}
 
/*check enclosure*/
if (diff_minEnclosure > 0) {
    ENCLOSE via2  BY metal2  {
        COMMENT = "$layer_name Enclosure: minimum enclosure ( diff_minEnclosure )"
        SPACING < diff_minEnclosure
	NON_PARALLEL = TRUE
	POINT_TOUCH = TRUE
	TOUCH = TRUE
    } (12 )
    BOOLEAN via2  NOT metal2  {
        COMMENT = "$layer_name Enclosure: minimum enclosure ( diff_minEnclosure )"
    } (12 )
}
 
/*check end_of_line enclosure*/
if (diff_endOfLineEnclosure > 0) {
    if (diff_minEnclosure  == 0) {
       BOOLEAN via2  NOT metal2  {
           COMMENT = "$layer_name EndOfLine: end-of-line minimum enclosure ( diff_endOfLineEnclosure )"
       } (12 )
    }
    if (diff_endOfLineMode == 0) {
        ENCLOSE via2  BY metal2  {
	    SPACING < diff_endOfLineEnclosure
	    SET_CORNERS_TO_SPACING = FALSE
	    PARALLEL_POINT_PROJECTION = FALSE
	    SHADOW_OTHER_LAYER = TRUE  
	    TOUCH = TRUE
	    POINT_TOUCH = FALSE
	    NON_PARALLEL = TRUE
            OUTPUT_EDGES = TRUE
        } TEMP = violation
 
        SELECT_EDGE via2  TOUCHING violation {  } TEMP = edges
        SELECT_VECTOR edges { ANGLE_RANGE = [0, 0] } TEMP = h_edges
        SELECT_VECTOR edges { ANGLE_RANGE = [90, 90] } TEMP = v_edges
        SELECT h_edges INTERACT v_edges { POINT_TOUCH = TRUE } TEMP = h_edges
 
        SELECT via2  ENCLOSING h_edges {
            COMMENT = "$layer_name EndOfLine: end-of-line minimum enclosure ( diff_endOfLineEnclosure )"
        } (12 )
    }
    else {
    }
}
 
/*check stackable*/
if (diff_not_stackable > 0) {
     BOOLEAN via2  AND metal2  {
        COMMENT = "$layer_name Stackable: not stackable"
    } (12 )
}
/*check fat metal via keep-out area*/
if (diff_fatTblViaKeepoutThreshold > 0 && diff_fatTblViaKeepoutMinSize > 0 && diff_fatTblViaKeepoutEnclosure > 0) {
    if (diff_fatTblViaKeepoutThreshold > 0) {
        if ((diff_fatTblViaKeepoutThreshold / 2.0) > 0.0005 ) {
           SIZE metal2  { UNDER_OVER = diff_fatTblViaKeepoutThreshold / 2.0 - 0.0005  } TEMP = fat_candidate
           if (diff_fatTblViaKeepoutNextThreshold > 0) {
              SIZE fat_candidate { UNDER_OVER = diff_fatTblViaKeepoutNextThreshold / 2.0 - 0.0005  } TEMP = fat_next
              BOOLEAN fat_candidate NOT fat_next { } TEMP = fat
              BOOLEAN fat AND metal2  { } TEMP = fat
              SET diff_fatTblViaKeepoutNextThreshold = 0;
           } else {
              BOOLEAN fat_candidate AND metal2  {  } TEMP = fat
           }
        } else {
           COPY metal2  { } TEMP = fat
           COPY metal2  { } TEMP = fat_candidate 
        }
    }
    VERTEX fat_candidate {
       CONVEX = TRUE
       SIZE = 0.001 
    } TEMP = fat_corners
    VERTEX fat {
       CONVEX = TRUE
       SIZE = 0.001 
    } TEMP = wire_corners
    SELECT wire_corners INTERACT fat_corners { } TEMP = wire_corners
    SELECT_EDGE fat INTERACT wire_corners { } TEMP = edge_corners
    SELECT_VECTOR edge_corners {
       LENGTH_RANGE = [0, diff_fatTblViaKeepoutMinSize- 0.0005 ]
    } TEMP = edge_tmp1
    BOOLEAN edge_corners NOT edge_tmp1 { } TEMP = edge_tmp2
    SELECT wire_corners OUTSIDE edge_tmp1 {  } TEMP = real_corners
    BOOLEAN edge_tmp2 AND real_corners { } TEMP = real_edge
    SIZE real_edge {
       VSIZE_HEAD = diff_fatTblViaKeepoutMinSize-2* 0.001 
       VSIZE_TAIL = diff_fatTblViaKeepoutMinSize-2* 0.001 
       VSIZE_INSIDE = diff_fatTblViaKeepoutEnclosure- 0.001 
    } TEMP = forb_corners
    SELECT via2  INSIDE fat { } TEMP = v_fat
    /* Work around: need an accurate via_cluster */
    SELECT via_cluster INSIDE fat { } TEMP = v_fat_cluster
    SELECT v_fat INTERACT forb_corners { } TEMP = bad_vias
    BOOLEAN v_fat NOT bad_vias { } TEMP = good_vias
    SELECT v_fat_cluster OUTSIDE good_vias { } TEMP = bad_v_fat_cluster
    SELECT v_fat INTERACT bad_v_fat_cluster {
       COMMENT = "$layer_name ViaKepOut: fat metal ( diff_fatTblViaKeepoutThreshold um) contact keep-out area ( diff_fatTblViaKeepoutMinSize um, diff_fatTblViaKeepoutEnclosure um) "
    } (12 )
}
 
/* reset variables */



 
SET diff_minSpacing = 0;
SET diff_netMinSpacing = 0;
SET diff_cornerMinSpacing = 0;
SET diff_minEnclosure = 0;
SET diff_endOfLineEnclosure = 0;
SET diff_not_stackable = 0;
SET diff_fatTblViaKeepoutThreshold = 0;
SET diff_fatTblViaKeepoutNextThreshold = 0;
SET diff_fatTblViaKeepoutMinSize = 0;
SET diff_fatTblViaKeepoutEnclosure = 0;
@ 674 "adrc/adrc.ev" 2

    }
}
DISCONNECT


/*via 3 / metal 3*/
SET layer_name = "V3/M3";





LOAD_CONNECT_DB all_layer

if (!layer_empty (via3 )) {
    if (!layer_empty (metal3 )) {
        
@ 1 "adrc/adrc_check_diff.ev" 1
/*check spacing*/
if (diff_minSpacing > 0 && diff_netMinSpacing > 0) {
    if (diff_cornerMinSpacing > 0) {
        if (cornerSpacingMode == 1) {
            /* Work around: CONVEX_TO_CONVEX [POINT_PROJECTION] has a bug */
            EXTERNAL via3  metal3  {
                SPACING <= 0
                CONVEX_TO_CONVEX [POINT_PROJECTION] < diff_cornerMinSpacing
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                BOX_CORNER = FALSE
                NODAL = TRUE
            } TEMP = diffNet_corner_err1
            EXTERNAL via3  metal3  {
                SPACING <= 0
                CONVEX_TO_CONVEX < diff_cornerMinSpacing
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                BOX_CORNER = TRUE
                NODAL = TRUE
            } TEMP = diffNet_corner_err2
            BOOLEAN diffNet_corner_err1 OR diffNet_corner_err2 {
                COMMENT = "$layer_name Spacing   : corner to corner spacing = diff_cornerMinSpacing um "
            } (13 )
            EXTERNAL via3  metal3  {
                COMMENT = "$layer_name Spacing   : minimum spacing = diff_netMinSpacing um"
                SPACING < diff_netMinSpacing
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                NON_PARALLEL = TRUE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
                NODAL = TRUE
            } (13 )
        } else {
            EXTERNAL via3  metal3  {
                COMMENT = "$layer_name Spacing  : minimum spacing = diff_netMinSpacing um (corner to corner spacing = diff_cornerMinSpacing um)"
                SPACING < diff_netMinSpacing
                CONVEX_TO_CONVEX < diff_cornerMinSpacing
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                TOUCH = TRUE
                NODAL = TRUE
            } (13 )
        }
    } else {
        EXTERNAL via3  metal3  {
            COMMENT = "$layer_name Spacing  : minimum spacing = diff_netMinSpacing um"
            SPACING < diff_netMinSpacing
            NON_PARALLEL = TRUE
            POINT_TOUCH = TRUE
            TOUCH = TRUE
            NODAL = TRUE
        } (13 )
    }
    if (diff_cornerMinSpacing > 0) {
        if (cornerSpacingMode == 1) {
            /* Work around: CONVEX_TO_CONVEX [POINT_PROJECTION] has a bug */
            EXTERNAL via3  metal3  {
                SPACING <= 0
                CONVEX_TO_CONVEX [POINT_PROJECTION] < diff_cornerMinSpacing
                FLAG_DISCONNECTED = FALSE
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                BOX_CORNER = FALSE
            } TEMP = sameNet_corner_err1
            EXTERNAL via3  metal3  {
                SPACING <= 0
                CONVEX_TO_CONVEX < diff_cornerMinSpacing
                FLAG_DISCONNECTED = FALSE
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                BOX_CORNER = TRUE
            } TEMP = sameNet_corner_err2
            BOOLEAN sameNet_corner_err1 OR sameNet_corner_err2 {
                COMMENT = "$layer_name Spacing   : corner to corner spacing = diff_cornerMinSpacing um "
            } (13 )
            EXTERNAL via3  metal3  {
                COMMENT = "$layer_name Spacing   : minimum spacing = diff_minSpacing um"
                SPACING < diff_minSpacing
                FLAG_DISCONNECTED = FALSE
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                NON_PARALLEL = TRUE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
            } (13 )
        } else {
            EXTERNAL via3  metal3  {
                COMMENT = "$layer_name Spacing  : minimum spacing = diff_minSpacing um (corner to corner spacing = diff_cornerMinSpacing um)"
                SPACING < diff_minSpacing
                CONVEX_TO_CONVEX < diff_cornerMinSpacing
                FLAG_DISCONNECTED = FALSE
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                TOUCH = TRUE
            } (13 )
        }
    } else {
        EXTERNAL via3  metal3  {
            COMMENT = "$layer_name Spacing  : minimum spacing = diff_minSpacing um"
            SPACING < diff_minSpacing
            FLAG_DISCONNECTED = FALSE
            NON_PARALLEL = TRUE
            POINT_TOUCH = TRUE
            TOUCH = TRUE
        } (13 )
    }
} else {
    if (diff_netMinSpacing > 0) {
        if (diff_cornerMinSpacing > 0) {
            if (cornerSpacingMode == 1) {
                /* Work around: CONVEX_TO_CONVEX [POINT_PROJECTION] has a bug */
                EXTERNAL via3  metal3  {
                    SPACING <= 0
                    CONVEX_TO_CONVEX [POINT_PROJECTION] < diff_cornerMinSpacing
                    NON_PARALLEL = TRUE
                    POINT_TOUCH = TRUE
                    BOX_CORNER = FALSE
                    NODAL = TRUE
                } TEMP = corner_err1
                EXTERNAL via3  metal3  {
                    SPACING <= 0
                    CONVEX_TO_CONVEX < diff_cornerMinSpacing
                    NON_PARALLEL = TRUE
                    POINT_TOUCH = TRUE
                    BOX_CORNER = TRUE
                    NODAL = TRUE
                } TEMP = corner_err2
                BOOLEAN corner_err1 OR corner_err2 {
                    COMMENT = "$layer_name Spacing   : corner to corner spacing = diff_cornerMinSpacing um "
                } (13 )
                EXTERNAL via3  metal3  {
                    COMMENT = "$layer_name Spacing   : minimum spacing = diff_netMinSpacing um"
                    SPACING < diff_netMinSpacing
                    SET_CORNERS_TO_SPACING = FALSE
                    PARALLEL_POINT_PROJECTION = FALSE
                    NON_PARALLEL = TRUE
                    TOUCH = FALSE
                    POINT_TOUCH = FALSE
                    NODAL = TRUE
                } (13 )
            } else {
                EXTERNAL via3  metal3  {
                    COMMENT = "$layer_name Spacing  : minimum spacing = diff_netMinSpacing um (corner to corner spacing = diff_cornerMinSpacing um)"
                    SPACING < diff_netMinSpacing
                    CONVEX_TO_CONVEX < diff_cornerMinSpacing
                    NON_PARALLEL = TRUE
                    POINT_TOUCH = TRUE
                    TOUCH = TRUE
                    NODAL = TRUE
                } (13 )
            }
        } else {
            EXTERNAL via3  metal3  {
                COMMENT = "$layer_name Spacing  : minimum spacing = diff_netMinSpacing um"
                SPACING < diff_netMinSpacing
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                TOUCH = TRUE
                NODAL = TRUE
            } (13 )
        }
    } else if (diff_minSpacing > 0) {
        if (diff_cornerMinSpacing > 0) {
            if (cornerSpacingMode == 1) {
                /* Work around: CONVEX_TO_CONVEX [POINT_PROJECTION] has a bug */
                EXTERNAL via3  metal3  {
                    SPACING <= 0
                    CONVEX_TO_CONVEX [POINT_PROJECTION] < diff_cornerMinSpacing
                    NON_PARALLEL = TRUE
                    POINT_TOUCH = TRUE
                    BOX_CORNER = FALSE
                } TEMP = corner_err1
                EXTERNAL via3  metal3  {
                    SPACING <= 0
                    CONVEX_TO_CONVEX < diff_cornerMinSpacing
                    NON_PARALLEL = TRUE
                    POINT_TOUCH = TRUE
                    BOX_CORNER = TRUE
                } TEMP = corner_err2
                BOOLEAN corner_err1 OR corner_err2 {
                    COMMENT = "$layer_name Spacing   : corner to corner spacing = diff_cornerMinSpacing um "
                } (13 )
                EXTERNAL via3  metal3  {
                    COMMENT = "$layer_name Spacing   : minimum spacing = diff_minSpacing um"
                    SPACING < diff_minSpacing
                    SET_CORNERS_TO_SPACING = FALSE
                    PARALLEL_POINT_PROJECTION = FALSE
                    NON_PARALLEL = TRUE
                    TOUCH = FALSE
                    POINT_TOUCH = FALSE
                } (13 )
            } else {
                EXTERNAL via3  metal3  {
                    COMMENT = "$layer_name Spacing  : minimum spacing = diff_minSpacing um (corner to corner spacing = diff_cornerMinSpacing um)"
                    SPACING < diff_minSpacing
                    CONVEX_TO_CONVEX < diff_cornerMinSpacing
                    NON_PARALLEL = TRUE
                    POINT_TOUCH = TRUE
                    TOUCH = TRUE
                } (13 )
            }
        } else {
            EXTERNAL via3  metal3  {
                COMMENT = "$layer_name Spacing  : minimum spacing = diff_minSpacing um"
                SPACING < diff_minSpacing
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                TOUCH = TRUE
            } (13 )
        }
    }
}
 
/*check enclosure*/
if (diff_minEnclosure > 0) {
    ENCLOSE via3  BY metal3  {
        COMMENT = "$layer_name Enclosure: minimum enclosure ( diff_minEnclosure )"
        SPACING < diff_minEnclosure
	NON_PARALLEL = TRUE
	POINT_TOUCH = TRUE
	TOUCH = TRUE
    } (13 )
    BOOLEAN via3  NOT metal3  {
        COMMENT = "$layer_name Enclosure: minimum enclosure ( diff_minEnclosure )"
    } (13 )
}
 
/*check end_of_line enclosure*/
if (diff_endOfLineEnclosure > 0) {
    if (diff_minEnclosure  == 0) {
       BOOLEAN via3  NOT metal3  {
           COMMENT = "$layer_name EndOfLine: end-of-line minimum enclosure ( diff_endOfLineEnclosure )"
       } (13 )
    }
    if (diff_endOfLineMode == 0) {
        ENCLOSE via3  BY metal3  {
	    SPACING < diff_endOfLineEnclosure
	    SET_CORNERS_TO_SPACING = FALSE
	    PARALLEL_POINT_PROJECTION = FALSE
	    SHADOW_OTHER_LAYER = TRUE  
	    TOUCH = TRUE
	    POINT_TOUCH = FALSE
	    NON_PARALLEL = TRUE
            OUTPUT_EDGES = TRUE
        } TEMP = violation
 
        SELECT_EDGE via3  TOUCHING violation {  } TEMP = edges
        SELECT_VECTOR edges { ANGLE_RANGE = [0, 0] } TEMP = h_edges
        SELECT_VECTOR edges { ANGLE_RANGE = [90, 90] } TEMP = v_edges
        SELECT h_edges INTERACT v_edges { POINT_TOUCH = TRUE } TEMP = h_edges
 
        SELECT via3  ENCLOSING h_edges {
            COMMENT = "$layer_name EndOfLine: end-of-line minimum enclosure ( diff_endOfLineEnclosure )"
        } (13 )
    }
    else {
    }
}
 
/*check stackable*/
if (diff_not_stackable > 0) {
     BOOLEAN via3  AND metal3  {
        COMMENT = "$layer_name Stackable: not stackable"
    } (13 )
}
/*check fat metal via keep-out area*/
if (diff_fatTblViaKeepoutThreshold > 0 && diff_fatTblViaKeepoutMinSize > 0 && diff_fatTblViaKeepoutEnclosure > 0) {
    if (diff_fatTblViaKeepoutThreshold > 0) {
        if ((diff_fatTblViaKeepoutThreshold / 2.0) > 0.0005 ) {
           SIZE metal3  { UNDER_OVER = diff_fatTblViaKeepoutThreshold / 2.0 - 0.0005  } TEMP = fat_candidate
           if (diff_fatTblViaKeepoutNextThreshold > 0) {
              SIZE fat_candidate { UNDER_OVER = diff_fatTblViaKeepoutNextThreshold / 2.0 - 0.0005  } TEMP = fat_next
              BOOLEAN fat_candidate NOT fat_next { } TEMP = fat
              BOOLEAN fat AND metal3  { } TEMP = fat
              SET diff_fatTblViaKeepoutNextThreshold = 0;
           } else {
              BOOLEAN fat_candidate AND metal3  {  } TEMP = fat
           }
        } else {
           COPY metal3  { } TEMP = fat
           COPY metal3  { } TEMP = fat_candidate 
        }
    }
    VERTEX fat_candidate {
       CONVEX = TRUE
       SIZE = 0.001 
    } TEMP = fat_corners
    VERTEX fat {
       CONVEX = TRUE
       SIZE = 0.001 
    } TEMP = wire_corners
    SELECT wire_corners INTERACT fat_corners { } TEMP = wire_corners
    SELECT_EDGE fat INTERACT wire_corners { } TEMP = edge_corners
    SELECT_VECTOR edge_corners {
       LENGTH_RANGE = [0, diff_fatTblViaKeepoutMinSize- 0.0005 ]
    } TEMP = edge_tmp1
    BOOLEAN edge_corners NOT edge_tmp1 { } TEMP = edge_tmp2
    SELECT wire_corners OUTSIDE edge_tmp1 {  } TEMP = real_corners
    BOOLEAN edge_tmp2 AND real_corners { } TEMP = real_edge
    SIZE real_edge {
       VSIZE_HEAD = diff_fatTblViaKeepoutMinSize-2* 0.001 
       VSIZE_TAIL = diff_fatTblViaKeepoutMinSize-2* 0.001 
       VSIZE_INSIDE = diff_fatTblViaKeepoutEnclosure- 0.001 
    } TEMP = forb_corners
    SELECT via3  INSIDE fat { } TEMP = v_fat
    /* Work around: need an accurate via_cluster */
    SELECT via_cluster INSIDE fat { } TEMP = v_fat_cluster
    SELECT v_fat INTERACT forb_corners { } TEMP = bad_vias
    BOOLEAN v_fat NOT bad_vias { } TEMP = good_vias
    SELECT v_fat_cluster OUTSIDE good_vias { } TEMP = bad_v_fat_cluster
    SELECT v_fat INTERACT bad_v_fat_cluster {
       COMMENT = "$layer_name ViaKepOut: fat metal ( diff_fatTblViaKeepoutThreshold um) contact keep-out area ( diff_fatTblViaKeepoutMinSize um, diff_fatTblViaKeepoutEnclosure um) "
    } (13 )
}
 
/* reset variables */



 
SET diff_minSpacing = 0;
SET diff_netMinSpacing = 0;
SET diff_cornerMinSpacing = 0;
SET diff_minEnclosure = 0;
SET diff_endOfLineEnclosure = 0;
SET diff_not_stackable = 0;
SET diff_fatTblViaKeepoutThreshold = 0;
SET diff_fatTblViaKeepoutNextThreshold = 0;
SET diff_fatTblViaKeepoutMinSize = 0;
SET diff_fatTblViaKeepoutEnclosure = 0;
@ 691 "adrc/adrc.ev" 2

    }
}
DISCONNECT


/*via 4 / metal 4*/
SET layer_name = "V4/M4";





LOAD_CONNECT_DB all_layer

if (!layer_empty (via4 )) {
    if (!layer_empty (metal4 )) {
        
@ 1 "adrc/adrc_check_diff.ev" 1
/*check spacing*/
if (diff_minSpacing > 0 && diff_netMinSpacing > 0) {
    if (diff_cornerMinSpacing > 0) {
        if (cornerSpacingMode == 1) {
            /* Work around: CONVEX_TO_CONVEX [POINT_PROJECTION] has a bug */
            EXTERNAL via4  metal4  {
                SPACING <= 0
                CONVEX_TO_CONVEX [POINT_PROJECTION] < diff_cornerMinSpacing
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                BOX_CORNER = FALSE
                NODAL = TRUE
            } TEMP = diffNet_corner_err1
            EXTERNAL via4  metal4  {
                SPACING <= 0
                CONVEX_TO_CONVEX < diff_cornerMinSpacing
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                BOX_CORNER = TRUE
                NODAL = TRUE
            } TEMP = diffNet_corner_err2
            BOOLEAN diffNet_corner_err1 OR diffNet_corner_err2 {
                COMMENT = "$layer_name Spacing   : corner to corner spacing = diff_cornerMinSpacing um "
            } (14 )
            EXTERNAL via4  metal4  {
                COMMENT = "$layer_name Spacing   : minimum spacing = diff_netMinSpacing um"
                SPACING < diff_netMinSpacing
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                NON_PARALLEL = TRUE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
                NODAL = TRUE
            } (14 )
        } else {
            EXTERNAL via4  metal4  {
                COMMENT = "$layer_name Spacing  : minimum spacing = diff_netMinSpacing um (corner to corner spacing = diff_cornerMinSpacing um)"
                SPACING < diff_netMinSpacing
                CONVEX_TO_CONVEX < diff_cornerMinSpacing
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                TOUCH = TRUE
                NODAL = TRUE
            } (14 )
        }
    } else {
        EXTERNAL via4  metal4  {
            COMMENT = "$layer_name Spacing  : minimum spacing = diff_netMinSpacing um"
            SPACING < diff_netMinSpacing
            NON_PARALLEL = TRUE
            POINT_TOUCH = TRUE
            TOUCH = TRUE
            NODAL = TRUE
        } (14 )
    }
    if (diff_cornerMinSpacing > 0) {
        if (cornerSpacingMode == 1) {
            /* Work around: CONVEX_TO_CONVEX [POINT_PROJECTION] has a bug */
            EXTERNAL via4  metal4  {
                SPACING <= 0
                CONVEX_TO_CONVEX [POINT_PROJECTION] < diff_cornerMinSpacing
                FLAG_DISCONNECTED = FALSE
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                BOX_CORNER = FALSE
            } TEMP = sameNet_corner_err1
            EXTERNAL via4  metal4  {
                SPACING <= 0
                CONVEX_TO_CONVEX < diff_cornerMinSpacing
                FLAG_DISCONNECTED = FALSE
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                BOX_CORNER = TRUE
            } TEMP = sameNet_corner_err2
            BOOLEAN sameNet_corner_err1 OR sameNet_corner_err2 {
                COMMENT = "$layer_name Spacing   : corner to corner spacing = diff_cornerMinSpacing um "
            } (14 )
            EXTERNAL via4  metal4  {
                COMMENT = "$layer_name Spacing   : minimum spacing = diff_minSpacing um"
                SPACING < diff_minSpacing
                FLAG_DISCONNECTED = FALSE
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                NON_PARALLEL = TRUE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
            } (14 )
        } else {
            EXTERNAL via4  metal4  {
                COMMENT = "$layer_name Spacing  : minimum spacing = diff_minSpacing um (corner to corner spacing = diff_cornerMinSpacing um)"
                SPACING < diff_minSpacing
                CONVEX_TO_CONVEX < diff_cornerMinSpacing
                FLAG_DISCONNECTED = FALSE
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                TOUCH = TRUE
            } (14 )
        }
    } else {
        EXTERNAL via4  metal4  {
            COMMENT = "$layer_name Spacing  : minimum spacing = diff_minSpacing um"
            SPACING < diff_minSpacing
            FLAG_DISCONNECTED = FALSE
            NON_PARALLEL = TRUE
            POINT_TOUCH = TRUE
            TOUCH = TRUE
        } (14 )
    }
} else {
    if (diff_netMinSpacing > 0) {
        if (diff_cornerMinSpacing > 0) {
            if (cornerSpacingMode == 1) {
                /* Work around: CONVEX_TO_CONVEX [POINT_PROJECTION] has a bug */
                EXTERNAL via4  metal4  {
                    SPACING <= 0
                    CONVEX_TO_CONVEX [POINT_PROJECTION] < diff_cornerMinSpacing
                    NON_PARALLEL = TRUE
                    POINT_TOUCH = TRUE
                    BOX_CORNER = FALSE
                    NODAL = TRUE
                } TEMP = corner_err1
                EXTERNAL via4  metal4  {
                    SPACING <= 0
                    CONVEX_TO_CONVEX < diff_cornerMinSpacing
                    NON_PARALLEL = TRUE
                    POINT_TOUCH = TRUE
                    BOX_CORNER = TRUE
                    NODAL = TRUE
                } TEMP = corner_err2
                BOOLEAN corner_err1 OR corner_err2 {
                    COMMENT = "$layer_name Spacing   : corner to corner spacing = diff_cornerMinSpacing um "
                } (14 )
                EXTERNAL via4  metal4  {
                    COMMENT = "$layer_name Spacing   : minimum spacing = diff_netMinSpacing um"
                    SPACING < diff_netMinSpacing
                    SET_CORNERS_TO_SPACING = FALSE
                    PARALLEL_POINT_PROJECTION = FALSE
                    NON_PARALLEL = TRUE
                    TOUCH = FALSE
                    POINT_TOUCH = FALSE
                    NODAL = TRUE
                } (14 )
            } else {
                EXTERNAL via4  metal4  {
                    COMMENT = "$layer_name Spacing  : minimum spacing = diff_netMinSpacing um (corner to corner spacing = diff_cornerMinSpacing um)"
                    SPACING < diff_netMinSpacing
                    CONVEX_TO_CONVEX < diff_cornerMinSpacing
                    NON_PARALLEL = TRUE
                    POINT_TOUCH = TRUE
                    TOUCH = TRUE
                    NODAL = TRUE
                } (14 )
            }
        } else {
            EXTERNAL via4  metal4  {
                COMMENT = "$layer_name Spacing  : minimum spacing = diff_netMinSpacing um"
                SPACING < diff_netMinSpacing
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                TOUCH = TRUE
                NODAL = TRUE
            } (14 )
        }
    } else if (diff_minSpacing > 0) {
        if (diff_cornerMinSpacing > 0) {
            if (cornerSpacingMode == 1) {
                /* Work around: CONVEX_TO_CONVEX [POINT_PROJECTION] has a bug */
                EXTERNAL via4  metal4  {
                    SPACING <= 0
                    CONVEX_TO_CONVEX [POINT_PROJECTION] < diff_cornerMinSpacing
                    NON_PARALLEL = TRUE
                    POINT_TOUCH = TRUE
                    BOX_CORNER = FALSE
                } TEMP = corner_err1
                EXTERNAL via4  metal4  {
                    SPACING <= 0
                    CONVEX_TO_CONVEX < diff_cornerMinSpacing
                    NON_PARALLEL = TRUE
                    POINT_TOUCH = TRUE
                    BOX_CORNER = TRUE
                } TEMP = corner_err2
                BOOLEAN corner_err1 OR corner_err2 {
                    COMMENT = "$layer_name Spacing   : corner to corner spacing = diff_cornerMinSpacing um "
                } (14 )
                EXTERNAL via4  metal4  {
                    COMMENT = "$layer_name Spacing   : minimum spacing = diff_minSpacing um"
                    SPACING < diff_minSpacing
                    SET_CORNERS_TO_SPACING = FALSE
                    PARALLEL_POINT_PROJECTION = FALSE
                    NON_PARALLEL = TRUE
                    TOUCH = FALSE
                    POINT_TOUCH = FALSE
                } (14 )
            } else {
                EXTERNAL via4  metal4  {
                    COMMENT = "$layer_name Spacing  : minimum spacing = diff_minSpacing um (corner to corner spacing = diff_cornerMinSpacing um)"
                    SPACING < diff_minSpacing
                    CONVEX_TO_CONVEX < diff_cornerMinSpacing
                    NON_PARALLEL = TRUE
                    POINT_TOUCH = TRUE
                    TOUCH = TRUE
                } (14 )
            }
        } else {
            EXTERNAL via4  metal4  {
                COMMENT = "$layer_name Spacing  : minimum spacing = diff_minSpacing um"
                SPACING < diff_minSpacing
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                TOUCH = TRUE
            } (14 )
        }
    }
}
 
/*check enclosure*/
if (diff_minEnclosure > 0) {
    ENCLOSE via4  BY metal4  {
        COMMENT = "$layer_name Enclosure: minimum enclosure ( diff_minEnclosure )"
        SPACING < diff_minEnclosure
	NON_PARALLEL = TRUE
	POINT_TOUCH = TRUE
	TOUCH = TRUE
    } (14 )
    BOOLEAN via4  NOT metal4  {
        COMMENT = "$layer_name Enclosure: minimum enclosure ( diff_minEnclosure )"
    } (14 )
}
 
/*check end_of_line enclosure*/
if (diff_endOfLineEnclosure > 0) {
    if (diff_minEnclosure  == 0) {
       BOOLEAN via4  NOT metal4  {
           COMMENT = "$layer_name EndOfLine: end-of-line minimum enclosure ( diff_endOfLineEnclosure )"
       } (14 )
    }
    if (diff_endOfLineMode == 0) {
        ENCLOSE via4  BY metal4  {
	    SPACING < diff_endOfLineEnclosure
	    SET_CORNERS_TO_SPACING = FALSE
	    PARALLEL_POINT_PROJECTION = FALSE
	    SHADOW_OTHER_LAYER = TRUE  
	    TOUCH = TRUE
	    POINT_TOUCH = FALSE
	    NON_PARALLEL = TRUE
            OUTPUT_EDGES = TRUE
        } TEMP = violation
 
        SELECT_EDGE via4  TOUCHING violation {  } TEMP = edges
        SELECT_VECTOR edges { ANGLE_RANGE = [0, 0] } TEMP = h_edges
        SELECT_VECTOR edges { ANGLE_RANGE = [90, 90] } TEMP = v_edges
        SELECT h_edges INTERACT v_edges { POINT_TOUCH = TRUE } TEMP = h_edges
 
        SELECT via4  ENCLOSING h_edges {
            COMMENT = "$layer_name EndOfLine: end-of-line minimum enclosure ( diff_endOfLineEnclosure )"
        } (14 )
    }
    else {
    }
}
 
/*check stackable*/
if (diff_not_stackable > 0) {
     BOOLEAN via4  AND metal4  {
        COMMENT = "$layer_name Stackable: not stackable"
    } (14 )
}
/*check fat metal via keep-out area*/
if (diff_fatTblViaKeepoutThreshold > 0 && diff_fatTblViaKeepoutMinSize > 0 && diff_fatTblViaKeepoutEnclosure > 0) {
    if (diff_fatTblViaKeepoutThreshold > 0) {
        if ((diff_fatTblViaKeepoutThreshold / 2.0) > 0.0005 ) {
           SIZE metal4  { UNDER_OVER = diff_fatTblViaKeepoutThreshold / 2.0 - 0.0005  } TEMP = fat_candidate
           if (diff_fatTblViaKeepoutNextThreshold > 0) {
              SIZE fat_candidate { UNDER_OVER = diff_fatTblViaKeepoutNextThreshold / 2.0 - 0.0005  } TEMP = fat_next
              BOOLEAN fat_candidate NOT fat_next { } TEMP = fat
              BOOLEAN fat AND metal4  { } TEMP = fat
              SET diff_fatTblViaKeepoutNextThreshold = 0;
           } else {
              BOOLEAN fat_candidate AND metal4  {  } TEMP = fat
           }
        } else {
           COPY metal4  { } TEMP = fat
           COPY metal4  { } TEMP = fat_candidate 
        }
    }
    VERTEX fat_candidate {
       CONVEX = TRUE
       SIZE = 0.001 
    } TEMP = fat_corners
    VERTEX fat {
       CONVEX = TRUE
       SIZE = 0.001 
    } TEMP = wire_corners
    SELECT wire_corners INTERACT fat_corners { } TEMP = wire_corners
    SELECT_EDGE fat INTERACT wire_corners { } TEMP = edge_corners
    SELECT_VECTOR edge_corners {
       LENGTH_RANGE = [0, diff_fatTblViaKeepoutMinSize- 0.0005 ]
    } TEMP = edge_tmp1
    BOOLEAN edge_corners NOT edge_tmp1 { } TEMP = edge_tmp2
    SELECT wire_corners OUTSIDE edge_tmp1 {  } TEMP = real_corners
    BOOLEAN edge_tmp2 AND real_corners { } TEMP = real_edge
    SIZE real_edge {
       VSIZE_HEAD = diff_fatTblViaKeepoutMinSize-2* 0.001 
       VSIZE_TAIL = diff_fatTblViaKeepoutMinSize-2* 0.001 
       VSIZE_INSIDE = diff_fatTblViaKeepoutEnclosure- 0.001 
    } TEMP = forb_corners
    SELECT via4  INSIDE fat { } TEMP = v_fat
    /* Work around: need an accurate via_cluster */
    SELECT via_cluster INSIDE fat { } TEMP = v_fat_cluster
    SELECT v_fat INTERACT forb_corners { } TEMP = bad_vias
    BOOLEAN v_fat NOT bad_vias { } TEMP = good_vias
    SELECT v_fat_cluster OUTSIDE good_vias { } TEMP = bad_v_fat_cluster
    SELECT v_fat INTERACT bad_v_fat_cluster {
       COMMENT = "$layer_name ViaKepOut: fat metal ( diff_fatTblViaKeepoutThreshold um) contact keep-out area ( diff_fatTblViaKeepoutMinSize um, diff_fatTblViaKeepoutEnclosure um) "
    } (14 )
}
 
/* reset variables */



 
SET diff_minSpacing = 0;
SET diff_netMinSpacing = 0;
SET diff_cornerMinSpacing = 0;
SET diff_minEnclosure = 0;
SET diff_endOfLineEnclosure = 0;
SET diff_not_stackable = 0;
SET diff_fatTblViaKeepoutThreshold = 0;
SET diff_fatTblViaKeepoutNextThreshold = 0;
SET diff_fatTblViaKeepoutMinSize = 0;
SET diff_fatTblViaKeepoutEnclosure = 0;
@ 708 "adrc/adrc.ev" 2

    }
}
DISCONNECT


/*via 5 / metal 5*/
SET layer_name = "V5/M5";





LOAD_CONNECT_DB all_layer

if (!layer_empty (via5 )) {
    if (!layer_empty (metal5 )) {
        
@ 1 "adrc/adrc_check_diff.ev" 1
/*check spacing*/
if (diff_minSpacing > 0 && diff_netMinSpacing > 0) {
    if (diff_cornerMinSpacing > 0) {
        if (cornerSpacingMode == 1) {
            /* Work around: CONVEX_TO_CONVEX [POINT_PROJECTION] has a bug */
            EXTERNAL via5  metal5  {
                SPACING <= 0
                CONVEX_TO_CONVEX [POINT_PROJECTION] < diff_cornerMinSpacing
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                BOX_CORNER = FALSE
                NODAL = TRUE
            } TEMP = diffNet_corner_err1
            EXTERNAL via5  metal5  {
                SPACING <= 0
                CONVEX_TO_CONVEX < diff_cornerMinSpacing
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                BOX_CORNER = TRUE
                NODAL = TRUE
            } TEMP = diffNet_corner_err2
            BOOLEAN diffNet_corner_err1 OR diffNet_corner_err2 {
                COMMENT = "$layer_name Spacing   : corner to corner spacing = diff_cornerMinSpacing um "
            } (15 )
            EXTERNAL via5  metal5  {
                COMMENT = "$layer_name Spacing   : minimum spacing = diff_netMinSpacing um"
                SPACING < diff_netMinSpacing
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                NON_PARALLEL = TRUE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
                NODAL = TRUE
            } (15 )
        } else {
            EXTERNAL via5  metal5  {
                COMMENT = "$layer_name Spacing  : minimum spacing = diff_netMinSpacing um (corner to corner spacing = diff_cornerMinSpacing um)"
                SPACING < diff_netMinSpacing
                CONVEX_TO_CONVEX < diff_cornerMinSpacing
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                TOUCH = TRUE
                NODAL = TRUE
            } (15 )
        }
    } else {
        EXTERNAL via5  metal5  {
            COMMENT = "$layer_name Spacing  : minimum spacing = diff_netMinSpacing um"
            SPACING < diff_netMinSpacing
            NON_PARALLEL = TRUE
            POINT_TOUCH = TRUE
            TOUCH = TRUE
            NODAL = TRUE
        } (15 )
    }
    if (diff_cornerMinSpacing > 0) {
        if (cornerSpacingMode == 1) {
            /* Work around: CONVEX_TO_CONVEX [POINT_PROJECTION] has a bug */
            EXTERNAL via5  metal5  {
                SPACING <= 0
                CONVEX_TO_CONVEX [POINT_PROJECTION] < diff_cornerMinSpacing
                FLAG_DISCONNECTED = FALSE
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                BOX_CORNER = FALSE
            } TEMP = sameNet_corner_err1
            EXTERNAL via5  metal5  {
                SPACING <= 0
                CONVEX_TO_CONVEX < diff_cornerMinSpacing
                FLAG_DISCONNECTED = FALSE
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                BOX_CORNER = TRUE
            } TEMP = sameNet_corner_err2
            BOOLEAN sameNet_corner_err1 OR sameNet_corner_err2 {
                COMMENT = "$layer_name Spacing   : corner to corner spacing = diff_cornerMinSpacing um "
            } (15 )
            EXTERNAL via5  metal5  {
                COMMENT = "$layer_name Spacing   : minimum spacing = diff_minSpacing um"
                SPACING < diff_minSpacing
                FLAG_DISCONNECTED = FALSE
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                NON_PARALLEL = TRUE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
            } (15 )
        } else {
            EXTERNAL via5  metal5  {
                COMMENT = "$layer_name Spacing  : minimum spacing = diff_minSpacing um (corner to corner spacing = diff_cornerMinSpacing um)"
                SPACING < diff_minSpacing
                CONVEX_TO_CONVEX < diff_cornerMinSpacing
                FLAG_DISCONNECTED = FALSE
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                TOUCH = TRUE
            } (15 )
        }
    } else {
        EXTERNAL via5  metal5  {
            COMMENT = "$layer_name Spacing  : minimum spacing = diff_minSpacing um"
            SPACING < diff_minSpacing
            FLAG_DISCONNECTED = FALSE
            NON_PARALLEL = TRUE
            POINT_TOUCH = TRUE
            TOUCH = TRUE
        } (15 )
    }
} else {
    if (diff_netMinSpacing > 0) {
        if (diff_cornerMinSpacing > 0) {
            if (cornerSpacingMode == 1) {
                /* Work around: CONVEX_TO_CONVEX [POINT_PROJECTION] has a bug */
                EXTERNAL via5  metal5  {
                    SPACING <= 0
                    CONVEX_TO_CONVEX [POINT_PROJECTION] < diff_cornerMinSpacing
                    NON_PARALLEL = TRUE
                    POINT_TOUCH = TRUE
                    BOX_CORNER = FALSE
                    NODAL = TRUE
                } TEMP = corner_err1
                EXTERNAL via5  metal5  {
                    SPACING <= 0
                    CONVEX_TO_CONVEX < diff_cornerMinSpacing
                    NON_PARALLEL = TRUE
                    POINT_TOUCH = TRUE
                    BOX_CORNER = TRUE
                    NODAL = TRUE
                } TEMP = corner_err2
                BOOLEAN corner_err1 OR corner_err2 {
                    COMMENT = "$layer_name Spacing   : corner to corner spacing = diff_cornerMinSpacing um "
                } (15 )
                EXTERNAL via5  metal5  {
                    COMMENT = "$layer_name Spacing   : minimum spacing = diff_netMinSpacing um"
                    SPACING < diff_netMinSpacing
                    SET_CORNERS_TO_SPACING = FALSE
                    PARALLEL_POINT_PROJECTION = FALSE
                    NON_PARALLEL = TRUE
                    TOUCH = FALSE
                    POINT_TOUCH = FALSE
                    NODAL = TRUE
                } (15 )
            } else {
                EXTERNAL via5  metal5  {
                    COMMENT = "$layer_name Spacing  : minimum spacing = diff_netMinSpacing um (corner to corner spacing = diff_cornerMinSpacing um)"
                    SPACING < diff_netMinSpacing
                    CONVEX_TO_CONVEX < diff_cornerMinSpacing
                    NON_PARALLEL = TRUE
                    POINT_TOUCH = TRUE
                    TOUCH = TRUE
                    NODAL = TRUE
                } (15 )
            }
        } else {
            EXTERNAL via5  metal5  {
                COMMENT = "$layer_name Spacing  : minimum spacing = diff_netMinSpacing um"
                SPACING < diff_netMinSpacing
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                TOUCH = TRUE
                NODAL = TRUE
            } (15 )
        }
    } else if (diff_minSpacing > 0) {
        if (diff_cornerMinSpacing > 0) {
            if (cornerSpacingMode == 1) {
                /* Work around: CONVEX_TO_CONVEX [POINT_PROJECTION] has a bug */
                EXTERNAL via5  metal5  {
                    SPACING <= 0
                    CONVEX_TO_CONVEX [POINT_PROJECTION] < diff_cornerMinSpacing
                    NON_PARALLEL = TRUE
                    POINT_TOUCH = TRUE
                    BOX_CORNER = FALSE
                } TEMP = corner_err1
                EXTERNAL via5  metal5  {
                    SPACING <= 0
                    CONVEX_TO_CONVEX < diff_cornerMinSpacing
                    NON_PARALLEL = TRUE
                    POINT_TOUCH = TRUE
                    BOX_CORNER = TRUE
                } TEMP = corner_err2
                BOOLEAN corner_err1 OR corner_err2 {
                    COMMENT = "$layer_name Spacing   : corner to corner spacing = diff_cornerMinSpacing um "
                } (15 )
                EXTERNAL via5  metal5  {
                    COMMENT = "$layer_name Spacing   : minimum spacing = diff_minSpacing um"
                    SPACING < diff_minSpacing
                    SET_CORNERS_TO_SPACING = FALSE
                    PARALLEL_POINT_PROJECTION = FALSE
                    NON_PARALLEL = TRUE
                    TOUCH = FALSE
                    POINT_TOUCH = FALSE
                } (15 )
            } else {
                EXTERNAL via5  metal5  {
                    COMMENT = "$layer_name Spacing  : minimum spacing = diff_minSpacing um (corner to corner spacing = diff_cornerMinSpacing um)"
                    SPACING < diff_minSpacing
                    CONVEX_TO_CONVEX < diff_cornerMinSpacing
                    NON_PARALLEL = TRUE
                    POINT_TOUCH = TRUE
                    TOUCH = TRUE
                } (15 )
            }
        } else {
            EXTERNAL via5  metal5  {
                COMMENT = "$layer_name Spacing  : minimum spacing = diff_minSpacing um"
                SPACING < diff_minSpacing
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                TOUCH = TRUE
            } (15 )
        }
    }
}
 
/*check enclosure*/
if (diff_minEnclosure > 0) {
    ENCLOSE via5  BY metal5  {
        COMMENT = "$layer_name Enclosure: minimum enclosure ( diff_minEnclosure )"
        SPACING < diff_minEnclosure
	NON_PARALLEL = TRUE
	POINT_TOUCH = TRUE
	TOUCH = TRUE
    } (15 )
    BOOLEAN via5  NOT metal5  {
        COMMENT = "$layer_name Enclosure: minimum enclosure ( diff_minEnclosure )"
    } (15 )
}
 
/*check end_of_line enclosure*/
if (diff_endOfLineEnclosure > 0) {
    if (diff_minEnclosure  == 0) {
       BOOLEAN via5  NOT metal5  {
           COMMENT = "$layer_name EndOfLine: end-of-line minimum enclosure ( diff_endOfLineEnclosure )"
       } (15 )
    }
    if (diff_endOfLineMode == 0) {
        ENCLOSE via5  BY metal5  {
	    SPACING < diff_endOfLineEnclosure
	    SET_CORNERS_TO_SPACING = FALSE
	    PARALLEL_POINT_PROJECTION = FALSE
	    SHADOW_OTHER_LAYER = TRUE  
	    TOUCH = TRUE
	    POINT_TOUCH = FALSE
	    NON_PARALLEL = TRUE
            OUTPUT_EDGES = TRUE
        } TEMP = violation
 
        SELECT_EDGE via5  TOUCHING violation {  } TEMP = edges
        SELECT_VECTOR edges { ANGLE_RANGE = [0, 0] } TEMP = h_edges
        SELECT_VECTOR edges { ANGLE_RANGE = [90, 90] } TEMP = v_edges
        SELECT h_edges INTERACT v_edges { POINT_TOUCH = TRUE } TEMP = h_edges
 
        SELECT via5  ENCLOSING h_edges {
            COMMENT = "$layer_name EndOfLine: end-of-line minimum enclosure ( diff_endOfLineEnclosure )"
        } (15 )
    }
    else {
    }
}
 
/*check stackable*/
if (diff_not_stackable > 0) {
     BOOLEAN via5  AND metal5  {
        COMMENT = "$layer_name Stackable: not stackable"
    } (15 )
}
/*check fat metal via keep-out area*/
if (diff_fatTblViaKeepoutThreshold > 0 && diff_fatTblViaKeepoutMinSize > 0 && diff_fatTblViaKeepoutEnclosure > 0) {
    if (diff_fatTblViaKeepoutThreshold > 0) {
        if ((diff_fatTblViaKeepoutThreshold / 2.0) > 0.0005 ) {
           SIZE metal5  { UNDER_OVER = diff_fatTblViaKeepoutThreshold / 2.0 - 0.0005  } TEMP = fat_candidate
           if (diff_fatTblViaKeepoutNextThreshold > 0) {
              SIZE fat_candidate { UNDER_OVER = diff_fatTblViaKeepoutNextThreshold / 2.0 - 0.0005  } TEMP = fat_next
              BOOLEAN fat_candidate NOT fat_next { } TEMP = fat
              BOOLEAN fat AND metal5  { } TEMP = fat
              SET diff_fatTblViaKeepoutNextThreshold = 0;
           } else {
              BOOLEAN fat_candidate AND metal5  {  } TEMP = fat
           }
        } else {
           COPY metal5  { } TEMP = fat
           COPY metal5  { } TEMP = fat_candidate 
        }
    }
    VERTEX fat_candidate {
       CONVEX = TRUE
       SIZE = 0.001 
    } TEMP = fat_corners
    VERTEX fat {
       CONVEX = TRUE
       SIZE = 0.001 
    } TEMP = wire_corners
    SELECT wire_corners INTERACT fat_corners { } TEMP = wire_corners
    SELECT_EDGE fat INTERACT wire_corners { } TEMP = edge_corners
    SELECT_VECTOR edge_corners {
       LENGTH_RANGE = [0, diff_fatTblViaKeepoutMinSize- 0.0005 ]
    } TEMP = edge_tmp1
    BOOLEAN edge_corners NOT edge_tmp1 { } TEMP = edge_tmp2
    SELECT wire_corners OUTSIDE edge_tmp1 {  } TEMP = real_corners
    BOOLEAN edge_tmp2 AND real_corners { } TEMP = real_edge
    SIZE real_edge {
       VSIZE_HEAD = diff_fatTblViaKeepoutMinSize-2* 0.001 
       VSIZE_TAIL = diff_fatTblViaKeepoutMinSize-2* 0.001 
       VSIZE_INSIDE = diff_fatTblViaKeepoutEnclosure- 0.001 
    } TEMP = forb_corners
    SELECT via5  INSIDE fat { } TEMP = v_fat
    /* Work around: need an accurate via_cluster */
    SELECT via_cluster INSIDE fat { } TEMP = v_fat_cluster
    SELECT v_fat INTERACT forb_corners { } TEMP = bad_vias
    BOOLEAN v_fat NOT bad_vias { } TEMP = good_vias
    SELECT v_fat_cluster OUTSIDE good_vias { } TEMP = bad_v_fat_cluster
    SELECT v_fat INTERACT bad_v_fat_cluster {
       COMMENT = "$layer_name ViaKepOut: fat metal ( diff_fatTblViaKeepoutThreshold um) contact keep-out area ( diff_fatTblViaKeepoutMinSize um, diff_fatTblViaKeepoutEnclosure um) "
    } (15 )
}
 
/* reset variables */



 
SET diff_minSpacing = 0;
SET diff_netMinSpacing = 0;
SET diff_cornerMinSpacing = 0;
SET diff_minEnclosure = 0;
SET diff_endOfLineEnclosure = 0;
SET diff_not_stackable = 0;
SET diff_fatTblViaKeepoutThreshold = 0;
SET diff_fatTblViaKeepoutNextThreshold = 0;
SET diff_fatTblViaKeepoutMinSize = 0;
SET diff_fatTblViaKeepoutEnclosure = 0;
@ 725 "adrc/adrc.ev" 2

    }
}
DISCONNECT


/*via 6 / metal 6*/
SET layer_name = "V6/M6";





LOAD_CONNECT_DB all_layer

if (!layer_empty (via6 )) {
    if (!layer_empty (metal6 )) {
        
@ 1 "adrc/adrc_check_diff.ev" 1
/*check spacing*/
if (diff_minSpacing > 0 && diff_netMinSpacing > 0) {
    if (diff_cornerMinSpacing > 0) {
        if (cornerSpacingMode == 1) {
            /* Work around: CONVEX_TO_CONVEX [POINT_PROJECTION] has a bug */
            EXTERNAL via6  metal6  {
                SPACING <= 0
                CONVEX_TO_CONVEX [POINT_PROJECTION] < diff_cornerMinSpacing
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                BOX_CORNER = FALSE
                NODAL = TRUE
            } TEMP = diffNet_corner_err1
            EXTERNAL via6  metal6  {
                SPACING <= 0
                CONVEX_TO_CONVEX < diff_cornerMinSpacing
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                BOX_CORNER = TRUE
                NODAL = TRUE
            } TEMP = diffNet_corner_err2
            BOOLEAN diffNet_corner_err1 OR diffNet_corner_err2 {
                COMMENT = "$layer_name Spacing   : corner to corner spacing = diff_cornerMinSpacing um "
            } (16 )
            EXTERNAL via6  metal6  {
                COMMENT = "$layer_name Spacing   : minimum spacing = diff_netMinSpacing um"
                SPACING < diff_netMinSpacing
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                NON_PARALLEL = TRUE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
                NODAL = TRUE
            } (16 )
        } else {
            EXTERNAL via6  metal6  {
                COMMENT = "$layer_name Spacing  : minimum spacing = diff_netMinSpacing um (corner to corner spacing = diff_cornerMinSpacing um)"
                SPACING < diff_netMinSpacing
                CONVEX_TO_CONVEX < diff_cornerMinSpacing
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                TOUCH = TRUE
                NODAL = TRUE
            } (16 )
        }
    } else {
        EXTERNAL via6  metal6  {
            COMMENT = "$layer_name Spacing  : minimum spacing = diff_netMinSpacing um"
            SPACING < diff_netMinSpacing
            NON_PARALLEL = TRUE
            POINT_TOUCH = TRUE
            TOUCH = TRUE
            NODAL = TRUE
        } (16 )
    }
    if (diff_cornerMinSpacing > 0) {
        if (cornerSpacingMode == 1) {
            /* Work around: CONVEX_TO_CONVEX [POINT_PROJECTION] has a bug */
            EXTERNAL via6  metal6  {
                SPACING <= 0
                CONVEX_TO_CONVEX [POINT_PROJECTION] < diff_cornerMinSpacing
                FLAG_DISCONNECTED = FALSE
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                BOX_CORNER = FALSE
            } TEMP = sameNet_corner_err1
            EXTERNAL via6  metal6  {
                SPACING <= 0
                CONVEX_TO_CONVEX < diff_cornerMinSpacing
                FLAG_DISCONNECTED = FALSE
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                BOX_CORNER = TRUE
            } TEMP = sameNet_corner_err2
            BOOLEAN sameNet_corner_err1 OR sameNet_corner_err2 {
                COMMENT = "$layer_name Spacing   : corner to corner spacing = diff_cornerMinSpacing um "
            } (16 )
            EXTERNAL via6  metal6  {
                COMMENT = "$layer_name Spacing   : minimum spacing = diff_minSpacing um"
                SPACING < diff_minSpacing
                FLAG_DISCONNECTED = FALSE
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                NON_PARALLEL = TRUE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
            } (16 )
        } else {
            EXTERNAL via6  metal6  {
                COMMENT = "$layer_name Spacing  : minimum spacing = diff_minSpacing um (corner to corner spacing = diff_cornerMinSpacing um)"
                SPACING < diff_minSpacing
                CONVEX_TO_CONVEX < diff_cornerMinSpacing
                FLAG_DISCONNECTED = FALSE
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                TOUCH = TRUE
            } (16 )
        }
    } else {
        EXTERNAL via6  metal6  {
            COMMENT = "$layer_name Spacing  : minimum spacing = diff_minSpacing um"
            SPACING < diff_minSpacing
            FLAG_DISCONNECTED = FALSE
            NON_PARALLEL = TRUE
            POINT_TOUCH = TRUE
            TOUCH = TRUE
        } (16 )
    }
} else {
    if (diff_netMinSpacing > 0) {
        if (diff_cornerMinSpacing > 0) {
            if (cornerSpacingMode == 1) {
                /* Work around: CONVEX_TO_CONVEX [POINT_PROJECTION] has a bug */
                EXTERNAL via6  metal6  {
                    SPACING <= 0
                    CONVEX_TO_CONVEX [POINT_PROJECTION] < diff_cornerMinSpacing
                    NON_PARALLEL = TRUE
                    POINT_TOUCH = TRUE
                    BOX_CORNER = FALSE
                    NODAL = TRUE
                } TEMP = corner_err1
                EXTERNAL via6  metal6  {
                    SPACING <= 0
                    CONVEX_TO_CONVEX < diff_cornerMinSpacing
                    NON_PARALLEL = TRUE
                    POINT_TOUCH = TRUE
                    BOX_CORNER = TRUE
                    NODAL = TRUE
                } TEMP = corner_err2
                BOOLEAN corner_err1 OR corner_err2 {
                    COMMENT = "$layer_name Spacing   : corner to corner spacing = diff_cornerMinSpacing um "
                } (16 )
                EXTERNAL via6  metal6  {
                    COMMENT = "$layer_name Spacing   : minimum spacing = diff_netMinSpacing um"
                    SPACING < diff_netMinSpacing
                    SET_CORNERS_TO_SPACING = FALSE
                    PARALLEL_POINT_PROJECTION = FALSE
                    NON_PARALLEL = TRUE
                    TOUCH = FALSE
                    POINT_TOUCH = FALSE
                    NODAL = TRUE
                } (16 )
            } else {
                EXTERNAL via6  metal6  {
                    COMMENT = "$layer_name Spacing  : minimum spacing = diff_netMinSpacing um (corner to corner spacing = diff_cornerMinSpacing um)"
                    SPACING < diff_netMinSpacing
                    CONVEX_TO_CONVEX < diff_cornerMinSpacing
                    NON_PARALLEL = TRUE
                    POINT_TOUCH = TRUE
                    TOUCH = TRUE
                    NODAL = TRUE
                } (16 )
            }
        } else {
            EXTERNAL via6  metal6  {
                COMMENT = "$layer_name Spacing  : minimum spacing = diff_netMinSpacing um"
                SPACING < diff_netMinSpacing
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                TOUCH = TRUE
                NODAL = TRUE
            } (16 )
        }
    } else if (diff_minSpacing > 0) {
        if (diff_cornerMinSpacing > 0) {
            if (cornerSpacingMode == 1) {
                /* Work around: CONVEX_TO_CONVEX [POINT_PROJECTION] has a bug */
                EXTERNAL via6  metal6  {
                    SPACING <= 0
                    CONVEX_TO_CONVEX [POINT_PROJECTION] < diff_cornerMinSpacing
                    NON_PARALLEL = TRUE
                    POINT_TOUCH = TRUE
                    BOX_CORNER = FALSE
                } TEMP = corner_err1
                EXTERNAL via6  metal6  {
                    SPACING <= 0
                    CONVEX_TO_CONVEX < diff_cornerMinSpacing
                    NON_PARALLEL = TRUE
                    POINT_TOUCH = TRUE
                    BOX_CORNER = TRUE
                } TEMP = corner_err2
                BOOLEAN corner_err1 OR corner_err2 {
                    COMMENT = "$layer_name Spacing   : corner to corner spacing = diff_cornerMinSpacing um "
                } (16 )
                EXTERNAL via6  metal6  {
                    COMMENT = "$layer_name Spacing   : minimum spacing = diff_minSpacing um"
                    SPACING < diff_minSpacing
                    SET_CORNERS_TO_SPACING = FALSE
                    PARALLEL_POINT_PROJECTION = FALSE
                    NON_PARALLEL = TRUE
                    TOUCH = FALSE
                    POINT_TOUCH = FALSE
                } (16 )
            } else {
                EXTERNAL via6  metal6  {
                    COMMENT = "$layer_name Spacing  : minimum spacing = diff_minSpacing um (corner to corner spacing = diff_cornerMinSpacing um)"
                    SPACING < diff_minSpacing
                    CONVEX_TO_CONVEX < diff_cornerMinSpacing
                    NON_PARALLEL = TRUE
                    POINT_TOUCH = TRUE
                    TOUCH = TRUE
                } (16 )
            }
        } else {
            EXTERNAL via6  metal6  {
                COMMENT = "$layer_name Spacing  : minimum spacing = diff_minSpacing um"
                SPACING < diff_minSpacing
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                TOUCH = TRUE
            } (16 )
        }
    }
}
 
/*check enclosure*/
if (diff_minEnclosure > 0) {
    ENCLOSE via6  BY metal6  {
        COMMENT = "$layer_name Enclosure: minimum enclosure ( diff_minEnclosure )"
        SPACING < diff_minEnclosure
	NON_PARALLEL = TRUE
	POINT_TOUCH = TRUE
	TOUCH = TRUE
    } (16 )
    BOOLEAN via6  NOT metal6  {
        COMMENT = "$layer_name Enclosure: minimum enclosure ( diff_minEnclosure )"
    } (16 )
}
 
/*check end_of_line enclosure*/
if (diff_endOfLineEnclosure > 0) {
    if (diff_minEnclosure  == 0) {
       BOOLEAN via6  NOT metal6  {
           COMMENT = "$layer_name EndOfLine: end-of-line minimum enclosure ( diff_endOfLineEnclosure )"
       } (16 )
    }
    if (diff_endOfLineMode == 0) {
        ENCLOSE via6  BY metal6  {
	    SPACING < diff_endOfLineEnclosure
	    SET_CORNERS_TO_SPACING = FALSE
	    PARALLEL_POINT_PROJECTION = FALSE
	    SHADOW_OTHER_LAYER = TRUE  
	    TOUCH = TRUE
	    POINT_TOUCH = FALSE
	    NON_PARALLEL = TRUE
            OUTPUT_EDGES = TRUE
        } TEMP = violation
 
        SELECT_EDGE via6  TOUCHING violation {  } TEMP = edges
        SELECT_VECTOR edges { ANGLE_RANGE = [0, 0] } TEMP = h_edges
        SELECT_VECTOR edges { ANGLE_RANGE = [90, 90] } TEMP = v_edges
        SELECT h_edges INTERACT v_edges { POINT_TOUCH = TRUE } TEMP = h_edges
 
        SELECT via6  ENCLOSING h_edges {
            COMMENT = "$layer_name EndOfLine: end-of-line minimum enclosure ( diff_endOfLineEnclosure )"
        } (16 )
    }
    else {
    }
}
 
/*check stackable*/
if (diff_not_stackable > 0) {
     BOOLEAN via6  AND metal6  {
        COMMENT = "$layer_name Stackable: not stackable"
    } (16 )
}
/*check fat metal via keep-out area*/
if (diff_fatTblViaKeepoutThreshold > 0 && diff_fatTblViaKeepoutMinSize > 0 && diff_fatTblViaKeepoutEnclosure > 0) {
    if (diff_fatTblViaKeepoutThreshold > 0) {
        if ((diff_fatTblViaKeepoutThreshold / 2.0) > 0.0005 ) {
           SIZE metal6  { UNDER_OVER = diff_fatTblViaKeepoutThreshold / 2.0 - 0.0005  } TEMP = fat_candidate
           if (diff_fatTblViaKeepoutNextThreshold > 0) {
              SIZE fat_candidate { UNDER_OVER = diff_fatTblViaKeepoutNextThreshold / 2.0 - 0.0005  } TEMP = fat_next
              BOOLEAN fat_candidate NOT fat_next { } TEMP = fat
              BOOLEAN fat AND metal6  { } TEMP = fat
              SET diff_fatTblViaKeepoutNextThreshold = 0;
           } else {
              BOOLEAN fat_candidate AND metal6  {  } TEMP = fat
           }
        } else {
           COPY metal6  { } TEMP = fat
           COPY metal6  { } TEMP = fat_candidate 
        }
    }
    VERTEX fat_candidate {
       CONVEX = TRUE
       SIZE = 0.001 
    } TEMP = fat_corners
    VERTEX fat {
       CONVEX = TRUE
       SIZE = 0.001 
    } TEMP = wire_corners
    SELECT wire_corners INTERACT fat_corners { } TEMP = wire_corners
    SELECT_EDGE fat INTERACT wire_corners { } TEMP = edge_corners
    SELECT_VECTOR edge_corners {
       LENGTH_RANGE = [0, diff_fatTblViaKeepoutMinSize- 0.0005 ]
    } TEMP = edge_tmp1
    BOOLEAN edge_corners NOT edge_tmp1 { } TEMP = edge_tmp2
    SELECT wire_corners OUTSIDE edge_tmp1 {  } TEMP = real_corners
    BOOLEAN edge_tmp2 AND real_corners { } TEMP = real_edge
    SIZE real_edge {
       VSIZE_HEAD = diff_fatTblViaKeepoutMinSize-2* 0.001 
       VSIZE_TAIL = diff_fatTblViaKeepoutMinSize-2* 0.001 
       VSIZE_INSIDE = diff_fatTblViaKeepoutEnclosure- 0.001 
    } TEMP = forb_corners
    SELECT via6  INSIDE fat { } TEMP = v_fat
    /* Work around: need an accurate via_cluster */
    SELECT via_cluster INSIDE fat { } TEMP = v_fat_cluster
    SELECT v_fat INTERACT forb_corners { } TEMP = bad_vias
    BOOLEAN v_fat NOT bad_vias { } TEMP = good_vias
    SELECT v_fat_cluster OUTSIDE good_vias { } TEMP = bad_v_fat_cluster
    SELECT v_fat INTERACT bad_v_fat_cluster {
       COMMENT = "$layer_name ViaKepOut: fat metal ( diff_fatTblViaKeepoutThreshold um) contact keep-out area ( diff_fatTblViaKeepoutMinSize um, diff_fatTblViaKeepoutEnclosure um) "
    } (16 )
}
 
/* reset variables */



 
SET diff_minSpacing = 0;
SET diff_netMinSpacing = 0;
SET diff_cornerMinSpacing = 0;
SET diff_minEnclosure = 0;
SET diff_endOfLineEnclosure = 0;
SET diff_not_stackable = 0;
SET diff_fatTblViaKeepoutThreshold = 0;
SET diff_fatTblViaKeepoutNextThreshold = 0;
SET diff_fatTblViaKeepoutMinSize = 0;
SET diff_fatTblViaKeepoutEnclosure = 0;
@ 742 "adrc/adrc.ev" 2

    }
}
DISCONNECT


/*via 7 / metal 7*/
SET layer_name = "V7/M7";





LOAD_CONNECT_DB all_layer

if (!layer_empty (via7 )) {
    if (!layer_empty (metal7 )) {
        
@ 1 "adrc/adrc_check_diff.ev" 1
/*check spacing*/
if (diff_minSpacing > 0 && diff_netMinSpacing > 0) {
    if (diff_cornerMinSpacing > 0) {
        if (cornerSpacingMode == 1) {
            /* Work around: CONVEX_TO_CONVEX [POINT_PROJECTION] has a bug */
            EXTERNAL via7  metal7  {
                SPACING <= 0
                CONVEX_TO_CONVEX [POINT_PROJECTION] < diff_cornerMinSpacing
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                BOX_CORNER = FALSE
                NODAL = TRUE
            } TEMP = diffNet_corner_err1
            EXTERNAL via7  metal7  {
                SPACING <= 0
                CONVEX_TO_CONVEX < diff_cornerMinSpacing
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                BOX_CORNER = TRUE
                NODAL = TRUE
            } TEMP = diffNet_corner_err2
            BOOLEAN diffNet_corner_err1 OR diffNet_corner_err2 {
                COMMENT = "$layer_name Spacing   : corner to corner spacing = diff_cornerMinSpacing um "
            } (17 )
            EXTERNAL via7  metal7  {
                COMMENT = "$layer_name Spacing   : minimum spacing = diff_netMinSpacing um"
                SPACING < diff_netMinSpacing
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                NON_PARALLEL = TRUE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
                NODAL = TRUE
            } (17 )
        } else {
            EXTERNAL via7  metal7  {
                COMMENT = "$layer_name Spacing  : minimum spacing = diff_netMinSpacing um (corner to corner spacing = diff_cornerMinSpacing um)"
                SPACING < diff_netMinSpacing
                CONVEX_TO_CONVEX < diff_cornerMinSpacing
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                TOUCH = TRUE
                NODAL = TRUE
            } (17 )
        }
    } else {
        EXTERNAL via7  metal7  {
            COMMENT = "$layer_name Spacing  : minimum spacing = diff_netMinSpacing um"
            SPACING < diff_netMinSpacing
            NON_PARALLEL = TRUE
            POINT_TOUCH = TRUE
            TOUCH = TRUE
            NODAL = TRUE
        } (17 )
    }
    if (diff_cornerMinSpacing > 0) {
        if (cornerSpacingMode == 1) {
            /* Work around: CONVEX_TO_CONVEX [POINT_PROJECTION] has a bug */
            EXTERNAL via7  metal7  {
                SPACING <= 0
                CONVEX_TO_CONVEX [POINT_PROJECTION] < diff_cornerMinSpacing
                FLAG_DISCONNECTED = FALSE
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                BOX_CORNER = FALSE
            } TEMP = sameNet_corner_err1
            EXTERNAL via7  metal7  {
                SPACING <= 0
                CONVEX_TO_CONVEX < diff_cornerMinSpacing
                FLAG_DISCONNECTED = FALSE
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                BOX_CORNER = TRUE
            } TEMP = sameNet_corner_err2
            BOOLEAN sameNet_corner_err1 OR sameNet_corner_err2 {
                COMMENT = "$layer_name Spacing   : corner to corner spacing = diff_cornerMinSpacing um "
            } (17 )
            EXTERNAL via7  metal7  {
                COMMENT = "$layer_name Spacing   : minimum spacing = diff_minSpacing um"
                SPACING < diff_minSpacing
                FLAG_DISCONNECTED = FALSE
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                NON_PARALLEL = TRUE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
            } (17 )
        } else {
            EXTERNAL via7  metal7  {
                COMMENT = "$layer_name Spacing  : minimum spacing = diff_minSpacing um (corner to corner spacing = diff_cornerMinSpacing um)"
                SPACING < diff_minSpacing
                CONVEX_TO_CONVEX < diff_cornerMinSpacing
                FLAG_DISCONNECTED = FALSE
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                TOUCH = TRUE
            } (17 )
        }
    } else {
        EXTERNAL via7  metal7  {
            COMMENT = "$layer_name Spacing  : minimum spacing = diff_minSpacing um"
            SPACING < diff_minSpacing
            FLAG_DISCONNECTED = FALSE
            NON_PARALLEL = TRUE
            POINT_TOUCH = TRUE
            TOUCH = TRUE
        } (17 )
    }
} else {
    if (diff_netMinSpacing > 0) {
        if (diff_cornerMinSpacing > 0) {
            if (cornerSpacingMode == 1) {
                /* Work around: CONVEX_TO_CONVEX [POINT_PROJECTION] has a bug */
                EXTERNAL via7  metal7  {
                    SPACING <= 0
                    CONVEX_TO_CONVEX [POINT_PROJECTION] < diff_cornerMinSpacing
                    NON_PARALLEL = TRUE
                    POINT_TOUCH = TRUE
                    BOX_CORNER = FALSE
                    NODAL = TRUE
                } TEMP = corner_err1
                EXTERNAL via7  metal7  {
                    SPACING <= 0
                    CONVEX_TO_CONVEX < diff_cornerMinSpacing
                    NON_PARALLEL = TRUE
                    POINT_TOUCH = TRUE
                    BOX_CORNER = TRUE
                    NODAL = TRUE
                } TEMP = corner_err2
                BOOLEAN corner_err1 OR corner_err2 {
                    COMMENT = "$layer_name Spacing   : corner to corner spacing = diff_cornerMinSpacing um "
                } (17 )
                EXTERNAL via7  metal7  {
                    COMMENT = "$layer_name Spacing   : minimum spacing = diff_netMinSpacing um"
                    SPACING < diff_netMinSpacing
                    SET_CORNERS_TO_SPACING = FALSE
                    PARALLEL_POINT_PROJECTION = FALSE
                    NON_PARALLEL = TRUE
                    TOUCH = FALSE
                    POINT_TOUCH = FALSE
                    NODAL = TRUE
                } (17 )
            } else {
                EXTERNAL via7  metal7  {
                    COMMENT = "$layer_name Spacing  : minimum spacing = diff_netMinSpacing um (corner to corner spacing = diff_cornerMinSpacing um)"
                    SPACING < diff_netMinSpacing
                    CONVEX_TO_CONVEX < diff_cornerMinSpacing
                    NON_PARALLEL = TRUE
                    POINT_TOUCH = TRUE
                    TOUCH = TRUE
                    NODAL = TRUE
                } (17 )
            }
        } else {
            EXTERNAL via7  metal7  {
                COMMENT = "$layer_name Spacing  : minimum spacing = diff_netMinSpacing um"
                SPACING < diff_netMinSpacing
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                TOUCH = TRUE
                NODAL = TRUE
            } (17 )
        }
    } else if (diff_minSpacing > 0) {
        if (diff_cornerMinSpacing > 0) {
            if (cornerSpacingMode == 1) {
                /* Work around: CONVEX_TO_CONVEX [POINT_PROJECTION] has a bug */
                EXTERNAL via7  metal7  {
                    SPACING <= 0
                    CONVEX_TO_CONVEX [POINT_PROJECTION] < diff_cornerMinSpacing
                    NON_PARALLEL = TRUE
                    POINT_TOUCH = TRUE
                    BOX_CORNER = FALSE
                } TEMP = corner_err1
                EXTERNAL via7  metal7  {
                    SPACING <= 0
                    CONVEX_TO_CONVEX < diff_cornerMinSpacing
                    NON_PARALLEL = TRUE
                    POINT_TOUCH = TRUE
                    BOX_CORNER = TRUE
                } TEMP = corner_err2
                BOOLEAN corner_err1 OR corner_err2 {
                    COMMENT = "$layer_name Spacing   : corner to corner spacing = diff_cornerMinSpacing um "
                } (17 )
                EXTERNAL via7  metal7  {
                    COMMENT = "$layer_name Spacing   : minimum spacing = diff_minSpacing um"
                    SPACING < diff_minSpacing
                    SET_CORNERS_TO_SPACING = FALSE
                    PARALLEL_POINT_PROJECTION = FALSE
                    NON_PARALLEL = TRUE
                    TOUCH = FALSE
                    POINT_TOUCH = FALSE
                } (17 )
            } else {
                EXTERNAL via7  metal7  {
                    COMMENT = "$layer_name Spacing  : minimum spacing = diff_minSpacing um (corner to corner spacing = diff_cornerMinSpacing um)"
                    SPACING < diff_minSpacing
                    CONVEX_TO_CONVEX < diff_cornerMinSpacing
                    NON_PARALLEL = TRUE
                    POINT_TOUCH = TRUE
                    TOUCH = TRUE
                } (17 )
            }
        } else {
            EXTERNAL via7  metal7  {
                COMMENT = "$layer_name Spacing  : minimum spacing = diff_minSpacing um"
                SPACING < diff_minSpacing
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                TOUCH = TRUE
            } (17 )
        }
    }
}
 
/*check enclosure*/
if (diff_minEnclosure > 0) {
    ENCLOSE via7  BY metal7  {
        COMMENT = "$layer_name Enclosure: minimum enclosure ( diff_minEnclosure )"
        SPACING < diff_minEnclosure
	NON_PARALLEL = TRUE
	POINT_TOUCH = TRUE
	TOUCH = TRUE
    } (17 )
    BOOLEAN via7  NOT metal7  {
        COMMENT = "$layer_name Enclosure: minimum enclosure ( diff_minEnclosure )"
    } (17 )
}
 
/*check end_of_line enclosure*/
if (diff_endOfLineEnclosure > 0) {
    if (diff_minEnclosure  == 0) {
       BOOLEAN via7  NOT metal7  {
           COMMENT = "$layer_name EndOfLine: end-of-line minimum enclosure ( diff_endOfLineEnclosure )"
       } (17 )
    }
    if (diff_endOfLineMode == 0) {
        ENCLOSE via7  BY metal7  {
	    SPACING < diff_endOfLineEnclosure
	    SET_CORNERS_TO_SPACING = FALSE
	    PARALLEL_POINT_PROJECTION = FALSE
	    SHADOW_OTHER_LAYER = TRUE  
	    TOUCH = TRUE
	    POINT_TOUCH = FALSE
	    NON_PARALLEL = TRUE
            OUTPUT_EDGES = TRUE
        } TEMP = violation
 
        SELECT_EDGE via7  TOUCHING violation {  } TEMP = edges
        SELECT_VECTOR edges { ANGLE_RANGE = [0, 0] } TEMP = h_edges
        SELECT_VECTOR edges { ANGLE_RANGE = [90, 90] } TEMP = v_edges
        SELECT h_edges INTERACT v_edges { POINT_TOUCH = TRUE } TEMP = h_edges
 
        SELECT via7  ENCLOSING h_edges {
            COMMENT = "$layer_name EndOfLine: end-of-line minimum enclosure ( diff_endOfLineEnclosure )"
        } (17 )
    }
    else {
    }
}
 
/*check stackable*/
if (diff_not_stackable > 0) {
     BOOLEAN via7  AND metal7  {
        COMMENT = "$layer_name Stackable: not stackable"
    } (17 )
}
/*check fat metal via keep-out area*/
if (diff_fatTblViaKeepoutThreshold > 0 && diff_fatTblViaKeepoutMinSize > 0 && diff_fatTblViaKeepoutEnclosure > 0) {
    if (diff_fatTblViaKeepoutThreshold > 0) {
        if ((diff_fatTblViaKeepoutThreshold / 2.0) > 0.0005 ) {
           SIZE metal7  { UNDER_OVER = diff_fatTblViaKeepoutThreshold / 2.0 - 0.0005  } TEMP = fat_candidate
           if (diff_fatTblViaKeepoutNextThreshold > 0) {
              SIZE fat_candidate { UNDER_OVER = diff_fatTblViaKeepoutNextThreshold / 2.0 - 0.0005  } TEMP = fat_next
              BOOLEAN fat_candidate NOT fat_next { } TEMP = fat
              BOOLEAN fat AND metal7  { } TEMP = fat
              SET diff_fatTblViaKeepoutNextThreshold = 0;
           } else {
              BOOLEAN fat_candidate AND metal7  {  } TEMP = fat
           }
        } else {
           COPY metal7  { } TEMP = fat
           COPY metal7  { } TEMP = fat_candidate 
        }
    }
    VERTEX fat_candidate {
       CONVEX = TRUE
       SIZE = 0.001 
    } TEMP = fat_corners
    VERTEX fat {
       CONVEX = TRUE
       SIZE = 0.001 
    } TEMP = wire_corners
    SELECT wire_corners INTERACT fat_corners { } TEMP = wire_corners
    SELECT_EDGE fat INTERACT wire_corners { } TEMP = edge_corners
    SELECT_VECTOR edge_corners {
       LENGTH_RANGE = [0, diff_fatTblViaKeepoutMinSize- 0.0005 ]
    } TEMP = edge_tmp1
    BOOLEAN edge_corners NOT edge_tmp1 { } TEMP = edge_tmp2
    SELECT wire_corners OUTSIDE edge_tmp1 {  } TEMP = real_corners
    BOOLEAN edge_tmp2 AND real_corners { } TEMP = real_edge
    SIZE real_edge {
       VSIZE_HEAD = diff_fatTblViaKeepoutMinSize-2* 0.001 
       VSIZE_TAIL = diff_fatTblViaKeepoutMinSize-2* 0.001 
       VSIZE_INSIDE = diff_fatTblViaKeepoutEnclosure- 0.001 
    } TEMP = forb_corners
    SELECT via7  INSIDE fat { } TEMP = v_fat
    /* Work around: need an accurate via_cluster */
    SELECT via_cluster INSIDE fat { } TEMP = v_fat_cluster
    SELECT v_fat INTERACT forb_corners { } TEMP = bad_vias
    BOOLEAN v_fat NOT bad_vias { } TEMP = good_vias
    SELECT v_fat_cluster OUTSIDE good_vias { } TEMP = bad_v_fat_cluster
    SELECT v_fat INTERACT bad_v_fat_cluster {
       COMMENT = "$layer_name ViaKepOut: fat metal ( diff_fatTblViaKeepoutThreshold um) contact keep-out area ( diff_fatTblViaKeepoutMinSize um, diff_fatTblViaKeepoutEnclosure um) "
    } (17 )
}
 
/* reset variables */



 
SET diff_minSpacing = 0;
SET diff_netMinSpacing = 0;
SET diff_cornerMinSpacing = 0;
SET diff_minEnclosure = 0;
SET diff_endOfLineEnclosure = 0;
SET diff_not_stackable = 0;
SET diff_fatTblViaKeepoutThreshold = 0;
SET diff_fatTblViaKeepoutNextThreshold = 0;
SET diff_fatTblViaKeepoutMinSize = 0;
SET diff_fatTblViaKeepoutEnclosure = 0;
@ 759 "adrc/adrc.ev" 2

    }
}
DISCONNECT


/*via 8 / metal 8*/
SET layer_name = "V8/M8";





LOAD_CONNECT_DB all_layer

if (!layer_empty (via8 )) {
    if (!layer_empty (metal8 )) {
        
@ 1 "adrc/adrc_check_diff.ev" 1
/*check spacing*/
if (diff_minSpacing > 0 && diff_netMinSpacing > 0) {
    if (diff_cornerMinSpacing > 0) {
        if (cornerSpacingMode == 1) {
            /* Work around: CONVEX_TO_CONVEX [POINT_PROJECTION] has a bug */
            EXTERNAL via8  metal8  {
                SPACING <= 0
                CONVEX_TO_CONVEX [POINT_PROJECTION] < diff_cornerMinSpacing
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                BOX_CORNER = FALSE
                NODAL = TRUE
            } TEMP = diffNet_corner_err1
            EXTERNAL via8  metal8  {
                SPACING <= 0
                CONVEX_TO_CONVEX < diff_cornerMinSpacing
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                BOX_CORNER = TRUE
                NODAL = TRUE
            } TEMP = diffNet_corner_err2
            BOOLEAN diffNet_corner_err1 OR diffNet_corner_err2 {
                COMMENT = "$layer_name Spacing   : corner to corner spacing = diff_cornerMinSpacing um "
            } (18 )
            EXTERNAL via8  metal8  {
                COMMENT = "$layer_name Spacing   : minimum spacing = diff_netMinSpacing um"
                SPACING < diff_netMinSpacing
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                NON_PARALLEL = TRUE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
                NODAL = TRUE
            } (18 )
        } else {
            EXTERNAL via8  metal8  {
                COMMENT = "$layer_name Spacing  : minimum spacing = diff_netMinSpacing um (corner to corner spacing = diff_cornerMinSpacing um)"
                SPACING < diff_netMinSpacing
                CONVEX_TO_CONVEX < diff_cornerMinSpacing
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                TOUCH = TRUE
                NODAL = TRUE
            } (18 )
        }
    } else {
        EXTERNAL via8  metal8  {
            COMMENT = "$layer_name Spacing  : minimum spacing = diff_netMinSpacing um"
            SPACING < diff_netMinSpacing
            NON_PARALLEL = TRUE
            POINT_TOUCH = TRUE
            TOUCH = TRUE
            NODAL = TRUE
        } (18 )
    }
    if (diff_cornerMinSpacing > 0) {
        if (cornerSpacingMode == 1) {
            /* Work around: CONVEX_TO_CONVEX [POINT_PROJECTION] has a bug */
            EXTERNAL via8  metal8  {
                SPACING <= 0
                CONVEX_TO_CONVEX [POINT_PROJECTION] < diff_cornerMinSpacing
                FLAG_DISCONNECTED = FALSE
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                BOX_CORNER = FALSE
            } TEMP = sameNet_corner_err1
            EXTERNAL via8  metal8  {
                SPACING <= 0
                CONVEX_TO_CONVEX < diff_cornerMinSpacing
                FLAG_DISCONNECTED = FALSE
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                BOX_CORNER = TRUE
            } TEMP = sameNet_corner_err2
            BOOLEAN sameNet_corner_err1 OR sameNet_corner_err2 {
                COMMENT = "$layer_name Spacing   : corner to corner spacing = diff_cornerMinSpacing um "
            } (18 )
            EXTERNAL via8  metal8  {
                COMMENT = "$layer_name Spacing   : minimum spacing = diff_minSpacing um"
                SPACING < diff_minSpacing
                FLAG_DISCONNECTED = FALSE
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                NON_PARALLEL = TRUE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
            } (18 )
        } else {
            EXTERNAL via8  metal8  {
                COMMENT = "$layer_name Spacing  : minimum spacing = diff_minSpacing um (corner to corner spacing = diff_cornerMinSpacing um)"
                SPACING < diff_minSpacing
                CONVEX_TO_CONVEX < diff_cornerMinSpacing
                FLAG_DISCONNECTED = FALSE
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                TOUCH = TRUE
            } (18 )
        }
    } else {
        EXTERNAL via8  metal8  {
            COMMENT = "$layer_name Spacing  : minimum spacing = diff_minSpacing um"
            SPACING < diff_minSpacing
            FLAG_DISCONNECTED = FALSE
            NON_PARALLEL = TRUE
            POINT_TOUCH = TRUE
            TOUCH = TRUE
        } (18 )
    }
} else {
    if (diff_netMinSpacing > 0) {
        if (diff_cornerMinSpacing > 0) {
            if (cornerSpacingMode == 1) {
                /* Work around: CONVEX_TO_CONVEX [POINT_PROJECTION] has a bug */
                EXTERNAL via8  metal8  {
                    SPACING <= 0
                    CONVEX_TO_CONVEX [POINT_PROJECTION] < diff_cornerMinSpacing
                    NON_PARALLEL = TRUE
                    POINT_TOUCH = TRUE
                    BOX_CORNER = FALSE
                    NODAL = TRUE
                } TEMP = corner_err1
                EXTERNAL via8  metal8  {
                    SPACING <= 0
                    CONVEX_TO_CONVEX < diff_cornerMinSpacing
                    NON_PARALLEL = TRUE
                    POINT_TOUCH = TRUE
                    BOX_CORNER = TRUE
                    NODAL = TRUE
                } TEMP = corner_err2
                BOOLEAN corner_err1 OR corner_err2 {
                    COMMENT = "$layer_name Spacing   : corner to corner spacing = diff_cornerMinSpacing um "
                } (18 )
                EXTERNAL via8  metal8  {
                    COMMENT = "$layer_name Spacing   : minimum spacing = diff_netMinSpacing um"
                    SPACING < diff_netMinSpacing
                    SET_CORNERS_TO_SPACING = FALSE
                    PARALLEL_POINT_PROJECTION = FALSE
                    NON_PARALLEL = TRUE
                    TOUCH = FALSE
                    POINT_TOUCH = FALSE
                    NODAL = TRUE
                } (18 )
            } else {
                EXTERNAL via8  metal8  {
                    COMMENT = "$layer_name Spacing  : minimum spacing = diff_netMinSpacing um (corner to corner spacing = diff_cornerMinSpacing um)"
                    SPACING < diff_netMinSpacing
                    CONVEX_TO_CONVEX < diff_cornerMinSpacing
                    NON_PARALLEL = TRUE
                    POINT_TOUCH = TRUE
                    TOUCH = TRUE
                    NODAL = TRUE
                } (18 )
            }
        } else {
            EXTERNAL via8  metal8  {
                COMMENT = "$layer_name Spacing  : minimum spacing = diff_netMinSpacing um"
                SPACING < diff_netMinSpacing
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                TOUCH = TRUE
                NODAL = TRUE
            } (18 )
        }
    } else if (diff_minSpacing > 0) {
        if (diff_cornerMinSpacing > 0) {
            if (cornerSpacingMode == 1) {
                /* Work around: CONVEX_TO_CONVEX [POINT_PROJECTION] has a bug */
                EXTERNAL via8  metal8  {
                    SPACING <= 0
                    CONVEX_TO_CONVEX [POINT_PROJECTION] < diff_cornerMinSpacing
                    NON_PARALLEL = TRUE
                    POINT_TOUCH = TRUE
                    BOX_CORNER = FALSE
                } TEMP = corner_err1
                EXTERNAL via8  metal8  {
                    SPACING <= 0
                    CONVEX_TO_CONVEX < diff_cornerMinSpacing
                    NON_PARALLEL = TRUE
                    POINT_TOUCH = TRUE
                    BOX_CORNER = TRUE
                } TEMP = corner_err2
                BOOLEAN corner_err1 OR corner_err2 {
                    COMMENT = "$layer_name Spacing   : corner to corner spacing = diff_cornerMinSpacing um "
                } (18 )
                EXTERNAL via8  metal8  {
                    COMMENT = "$layer_name Spacing   : minimum spacing = diff_minSpacing um"
                    SPACING < diff_minSpacing
                    SET_CORNERS_TO_SPACING = FALSE
                    PARALLEL_POINT_PROJECTION = FALSE
                    NON_PARALLEL = TRUE
                    TOUCH = FALSE
                    POINT_TOUCH = FALSE
                } (18 )
            } else {
                EXTERNAL via8  metal8  {
                    COMMENT = "$layer_name Spacing  : minimum spacing = diff_minSpacing um (corner to corner spacing = diff_cornerMinSpacing um)"
                    SPACING < diff_minSpacing
                    CONVEX_TO_CONVEX < diff_cornerMinSpacing
                    NON_PARALLEL = TRUE
                    POINT_TOUCH = TRUE
                    TOUCH = TRUE
                } (18 )
            }
        } else {
            EXTERNAL via8  metal8  {
                COMMENT = "$layer_name Spacing  : minimum spacing = diff_minSpacing um"
                SPACING < diff_minSpacing
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                TOUCH = TRUE
            } (18 )
        }
    }
}
 
/*check enclosure*/
if (diff_minEnclosure > 0) {
    ENCLOSE via8  BY metal8  {
        COMMENT = "$layer_name Enclosure: minimum enclosure ( diff_minEnclosure )"
        SPACING < diff_minEnclosure
	NON_PARALLEL = TRUE
	POINT_TOUCH = TRUE
	TOUCH = TRUE
    } (18 )
    BOOLEAN via8  NOT metal8  {
        COMMENT = "$layer_name Enclosure: minimum enclosure ( diff_minEnclosure )"
    } (18 )
}
 
/*check end_of_line enclosure*/
if (diff_endOfLineEnclosure > 0) {
    if (diff_minEnclosure  == 0) {
       BOOLEAN via8  NOT metal8  {
           COMMENT = "$layer_name EndOfLine: end-of-line minimum enclosure ( diff_endOfLineEnclosure )"
       } (18 )
    }
    if (diff_endOfLineMode == 0) {
        ENCLOSE via8  BY metal8  {
	    SPACING < diff_endOfLineEnclosure
	    SET_CORNERS_TO_SPACING = FALSE
	    PARALLEL_POINT_PROJECTION = FALSE
	    SHADOW_OTHER_LAYER = TRUE  
	    TOUCH = TRUE
	    POINT_TOUCH = FALSE
	    NON_PARALLEL = TRUE
            OUTPUT_EDGES = TRUE
        } TEMP = violation
 
        SELECT_EDGE via8  TOUCHING violation {  } TEMP = edges
        SELECT_VECTOR edges { ANGLE_RANGE = [0, 0] } TEMP = h_edges
        SELECT_VECTOR edges { ANGLE_RANGE = [90, 90] } TEMP = v_edges
        SELECT h_edges INTERACT v_edges { POINT_TOUCH = TRUE } TEMP = h_edges
 
        SELECT via8  ENCLOSING h_edges {
            COMMENT = "$layer_name EndOfLine: end-of-line minimum enclosure ( diff_endOfLineEnclosure )"
        } (18 )
    }
    else {
    }
}
 
/*check stackable*/
if (diff_not_stackable > 0) {
     BOOLEAN via8  AND metal8  {
        COMMENT = "$layer_name Stackable: not stackable"
    } (18 )
}
/*check fat metal via keep-out area*/
if (diff_fatTblViaKeepoutThreshold > 0 && diff_fatTblViaKeepoutMinSize > 0 && diff_fatTblViaKeepoutEnclosure > 0) {
    if (diff_fatTblViaKeepoutThreshold > 0) {
        if ((diff_fatTblViaKeepoutThreshold / 2.0) > 0.0005 ) {
           SIZE metal8  { UNDER_OVER = diff_fatTblViaKeepoutThreshold / 2.0 - 0.0005  } TEMP = fat_candidate
           if (diff_fatTblViaKeepoutNextThreshold > 0) {
              SIZE fat_candidate { UNDER_OVER = diff_fatTblViaKeepoutNextThreshold / 2.0 - 0.0005  } TEMP = fat_next
              BOOLEAN fat_candidate NOT fat_next { } TEMP = fat
              BOOLEAN fat AND metal8  { } TEMP = fat
              SET diff_fatTblViaKeepoutNextThreshold = 0;
           } else {
              BOOLEAN fat_candidate AND metal8  {  } TEMP = fat
           }
        } else {
           COPY metal8  { } TEMP = fat
           COPY metal8  { } TEMP = fat_candidate 
        }
    }
    VERTEX fat_candidate {
       CONVEX = TRUE
       SIZE = 0.001 
    } TEMP = fat_corners
    VERTEX fat {
       CONVEX = TRUE
       SIZE = 0.001 
    } TEMP = wire_corners
    SELECT wire_corners INTERACT fat_corners { } TEMP = wire_corners
    SELECT_EDGE fat INTERACT wire_corners { } TEMP = edge_corners
    SELECT_VECTOR edge_corners {
       LENGTH_RANGE = [0, diff_fatTblViaKeepoutMinSize- 0.0005 ]
    } TEMP = edge_tmp1
    BOOLEAN edge_corners NOT edge_tmp1 { } TEMP = edge_tmp2
    SELECT wire_corners OUTSIDE edge_tmp1 {  } TEMP = real_corners
    BOOLEAN edge_tmp2 AND real_corners { } TEMP = real_edge
    SIZE real_edge {
       VSIZE_HEAD = diff_fatTblViaKeepoutMinSize-2* 0.001 
       VSIZE_TAIL = diff_fatTblViaKeepoutMinSize-2* 0.001 
       VSIZE_INSIDE = diff_fatTblViaKeepoutEnclosure- 0.001 
    } TEMP = forb_corners
    SELECT via8  INSIDE fat { } TEMP = v_fat
    /* Work around: need an accurate via_cluster */
    SELECT via_cluster INSIDE fat { } TEMP = v_fat_cluster
    SELECT v_fat INTERACT forb_corners { } TEMP = bad_vias
    BOOLEAN v_fat NOT bad_vias { } TEMP = good_vias
    SELECT v_fat_cluster OUTSIDE good_vias { } TEMP = bad_v_fat_cluster
    SELECT v_fat INTERACT bad_v_fat_cluster {
       COMMENT = "$layer_name ViaKepOut: fat metal ( diff_fatTblViaKeepoutThreshold um) contact keep-out area ( diff_fatTblViaKeepoutMinSize um, diff_fatTblViaKeepoutEnclosure um) "
    } (18 )
}
 
/* reset variables */



 
SET diff_minSpacing = 0;
SET diff_netMinSpacing = 0;
SET diff_cornerMinSpacing = 0;
SET diff_minEnclosure = 0;
SET diff_endOfLineEnclosure = 0;
SET diff_not_stackable = 0;
SET diff_fatTblViaKeepoutThreshold = 0;
SET diff_fatTblViaKeepoutNextThreshold = 0;
SET diff_fatTblViaKeepoutMinSize = 0;
SET diff_fatTblViaKeepoutEnclosure = 0;
@ 776 "adrc/adrc.ev" 2

    }
}
DISCONNECT


/*via 1 / metal 2*/
SET layer_name = "V1/M2";





LOAD_CONNECT_DB all_layer

if (!layer_empty (via1 )) {
    if (!layer_empty (metal2 )) {
        
@ 1 "adrc/adrc_check_diff.ev" 1
/*check spacing*/
if (diff_minSpacing > 0 && diff_netMinSpacing > 0) {
    if (diff_cornerMinSpacing > 0) {
        if (cornerSpacingMode == 1) {
            /* Work around: CONVEX_TO_CONVEX [POINT_PROJECTION] has a bug */
            EXTERNAL via1  metal2  {
                SPACING <= 0
                CONVEX_TO_CONVEX [POINT_PROJECTION] < diff_cornerMinSpacing
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                BOX_CORNER = FALSE
                NODAL = TRUE
            } TEMP = diffNet_corner_err1
            EXTERNAL via1  metal2  {
                SPACING <= 0
                CONVEX_TO_CONVEX < diff_cornerMinSpacing
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                BOX_CORNER = TRUE
                NODAL = TRUE
            } TEMP = diffNet_corner_err2
            BOOLEAN diffNet_corner_err1 OR diffNet_corner_err2 {
                COMMENT = "$layer_name Spacing   : corner to corner spacing = diff_cornerMinSpacing um "
            } (12 )
            EXTERNAL via1  metal2  {
                COMMENT = "$layer_name Spacing   : minimum spacing = diff_netMinSpacing um"
                SPACING < diff_netMinSpacing
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                NON_PARALLEL = TRUE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
                NODAL = TRUE
            } (12 )
        } else {
            EXTERNAL via1  metal2  {
                COMMENT = "$layer_name Spacing  : minimum spacing = diff_netMinSpacing um (corner to corner spacing = diff_cornerMinSpacing um)"
                SPACING < diff_netMinSpacing
                CONVEX_TO_CONVEX < diff_cornerMinSpacing
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                TOUCH = TRUE
                NODAL = TRUE
            } (12 )
        }
    } else {
        EXTERNAL via1  metal2  {
            COMMENT = "$layer_name Spacing  : minimum spacing = diff_netMinSpacing um"
            SPACING < diff_netMinSpacing
            NON_PARALLEL = TRUE
            POINT_TOUCH = TRUE
            TOUCH = TRUE
            NODAL = TRUE
        } (12 )
    }
    if (diff_cornerMinSpacing > 0) {
        if (cornerSpacingMode == 1) {
            /* Work around: CONVEX_TO_CONVEX [POINT_PROJECTION] has a bug */
            EXTERNAL via1  metal2  {
                SPACING <= 0
                CONVEX_TO_CONVEX [POINT_PROJECTION] < diff_cornerMinSpacing
                FLAG_DISCONNECTED = FALSE
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                BOX_CORNER = FALSE
            } TEMP = sameNet_corner_err1
            EXTERNAL via1  metal2  {
                SPACING <= 0
                CONVEX_TO_CONVEX < diff_cornerMinSpacing
                FLAG_DISCONNECTED = FALSE
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                BOX_CORNER = TRUE
            } TEMP = sameNet_corner_err2
            BOOLEAN sameNet_corner_err1 OR sameNet_corner_err2 {
                COMMENT = "$layer_name Spacing   : corner to corner spacing = diff_cornerMinSpacing um "
            } (12 )
            EXTERNAL via1  metal2  {
                COMMENT = "$layer_name Spacing   : minimum spacing = diff_minSpacing um"
                SPACING < diff_minSpacing
                FLAG_DISCONNECTED = FALSE
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                NON_PARALLEL = TRUE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
            } (12 )
        } else {
            EXTERNAL via1  metal2  {
                COMMENT = "$layer_name Spacing  : minimum spacing = diff_minSpacing um (corner to corner spacing = diff_cornerMinSpacing um)"
                SPACING < diff_minSpacing
                CONVEX_TO_CONVEX < diff_cornerMinSpacing
                FLAG_DISCONNECTED = FALSE
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                TOUCH = TRUE
            } (12 )
        }
    } else {
        EXTERNAL via1  metal2  {
            COMMENT = "$layer_name Spacing  : minimum spacing = diff_minSpacing um"
            SPACING < diff_minSpacing
            FLAG_DISCONNECTED = FALSE
            NON_PARALLEL = TRUE
            POINT_TOUCH = TRUE
            TOUCH = TRUE
        } (12 )
    }
} else {
    if (diff_netMinSpacing > 0) {
        if (diff_cornerMinSpacing > 0) {
            if (cornerSpacingMode == 1) {
                /* Work around: CONVEX_TO_CONVEX [POINT_PROJECTION] has a bug */
                EXTERNAL via1  metal2  {
                    SPACING <= 0
                    CONVEX_TO_CONVEX [POINT_PROJECTION] < diff_cornerMinSpacing
                    NON_PARALLEL = TRUE
                    POINT_TOUCH = TRUE
                    BOX_CORNER = FALSE
                    NODAL = TRUE
                } TEMP = corner_err1
                EXTERNAL via1  metal2  {
                    SPACING <= 0
                    CONVEX_TO_CONVEX < diff_cornerMinSpacing
                    NON_PARALLEL = TRUE
                    POINT_TOUCH = TRUE
                    BOX_CORNER = TRUE
                    NODAL = TRUE
                } TEMP = corner_err2
                BOOLEAN corner_err1 OR corner_err2 {
                    COMMENT = "$layer_name Spacing   : corner to corner spacing = diff_cornerMinSpacing um "
                } (12 )
                EXTERNAL via1  metal2  {
                    COMMENT = "$layer_name Spacing   : minimum spacing = diff_netMinSpacing um"
                    SPACING < diff_netMinSpacing
                    SET_CORNERS_TO_SPACING = FALSE
                    PARALLEL_POINT_PROJECTION = FALSE
                    NON_PARALLEL = TRUE
                    TOUCH = FALSE
                    POINT_TOUCH = FALSE
                    NODAL = TRUE
                } (12 )
            } else {
                EXTERNAL via1  metal2  {
                    COMMENT = "$layer_name Spacing  : minimum spacing = diff_netMinSpacing um (corner to corner spacing = diff_cornerMinSpacing um)"
                    SPACING < diff_netMinSpacing
                    CONVEX_TO_CONVEX < diff_cornerMinSpacing
                    NON_PARALLEL = TRUE
                    POINT_TOUCH = TRUE
                    TOUCH = TRUE
                    NODAL = TRUE
                } (12 )
            }
        } else {
            EXTERNAL via1  metal2  {
                COMMENT = "$layer_name Spacing  : minimum spacing = diff_netMinSpacing um"
                SPACING < diff_netMinSpacing
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                TOUCH = TRUE
                NODAL = TRUE
            } (12 )
        }
    } else if (diff_minSpacing > 0) {
        if (diff_cornerMinSpacing > 0) {
            if (cornerSpacingMode == 1) {
                /* Work around: CONVEX_TO_CONVEX [POINT_PROJECTION] has a bug */
                EXTERNAL via1  metal2  {
                    SPACING <= 0
                    CONVEX_TO_CONVEX [POINT_PROJECTION] < diff_cornerMinSpacing
                    NON_PARALLEL = TRUE
                    POINT_TOUCH = TRUE
                    BOX_CORNER = FALSE
                } TEMP = corner_err1
                EXTERNAL via1  metal2  {
                    SPACING <= 0
                    CONVEX_TO_CONVEX < diff_cornerMinSpacing
                    NON_PARALLEL = TRUE
                    POINT_TOUCH = TRUE
                    BOX_CORNER = TRUE
                } TEMP = corner_err2
                BOOLEAN corner_err1 OR corner_err2 {
                    COMMENT = "$layer_name Spacing   : corner to corner spacing = diff_cornerMinSpacing um "
                } (12 )
                EXTERNAL via1  metal2  {
                    COMMENT = "$layer_name Spacing   : minimum spacing = diff_minSpacing um"
                    SPACING < diff_minSpacing
                    SET_CORNERS_TO_SPACING = FALSE
                    PARALLEL_POINT_PROJECTION = FALSE
                    NON_PARALLEL = TRUE
                    TOUCH = FALSE
                    POINT_TOUCH = FALSE
                } (12 )
            } else {
                EXTERNAL via1  metal2  {
                    COMMENT = "$layer_name Spacing  : minimum spacing = diff_minSpacing um (corner to corner spacing = diff_cornerMinSpacing um)"
                    SPACING < diff_minSpacing
                    CONVEX_TO_CONVEX < diff_cornerMinSpacing
                    NON_PARALLEL = TRUE
                    POINT_TOUCH = TRUE
                    TOUCH = TRUE
                } (12 )
            }
        } else {
            EXTERNAL via1  metal2  {
                COMMENT = "$layer_name Spacing  : minimum spacing = diff_minSpacing um"
                SPACING < diff_minSpacing
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                TOUCH = TRUE
            } (12 )
        }
    }
}
 
/*check enclosure*/
if (diff_minEnclosure > 0) {
    ENCLOSE via1  BY metal2  {
        COMMENT = "$layer_name Enclosure: minimum enclosure ( diff_minEnclosure )"
        SPACING < diff_minEnclosure
	NON_PARALLEL = TRUE
	POINT_TOUCH = TRUE
	TOUCH = TRUE
    } (12 )
    BOOLEAN via1  NOT metal2  {
        COMMENT = "$layer_name Enclosure: minimum enclosure ( diff_minEnclosure )"
    } (12 )
}
 
/*check end_of_line enclosure*/
if (diff_endOfLineEnclosure > 0) {
    if (diff_minEnclosure  == 0) {
       BOOLEAN via1  NOT metal2  {
           COMMENT = "$layer_name EndOfLine: end-of-line minimum enclosure ( diff_endOfLineEnclosure )"
       } (12 )
    }
    if (diff_endOfLineMode == 0) {
        ENCLOSE via1  BY metal2  {
	    SPACING < diff_endOfLineEnclosure
	    SET_CORNERS_TO_SPACING = FALSE
	    PARALLEL_POINT_PROJECTION = FALSE
	    SHADOW_OTHER_LAYER = TRUE  
	    TOUCH = TRUE
	    POINT_TOUCH = FALSE
	    NON_PARALLEL = TRUE
            OUTPUT_EDGES = TRUE
        } TEMP = violation
 
        SELECT_EDGE via1  TOUCHING violation {  } TEMP = edges
        SELECT_VECTOR edges { ANGLE_RANGE = [0, 0] } TEMP = h_edges
        SELECT_VECTOR edges { ANGLE_RANGE = [90, 90] } TEMP = v_edges
        SELECT h_edges INTERACT v_edges { POINT_TOUCH = TRUE } TEMP = h_edges
 
        SELECT via1  ENCLOSING h_edges {
            COMMENT = "$layer_name EndOfLine: end-of-line minimum enclosure ( diff_endOfLineEnclosure )"
        } (12 )
    }
    else {
    }
}
 
/*check stackable*/
if (diff_not_stackable > 0) {
     BOOLEAN via1  AND metal2  {
        COMMENT = "$layer_name Stackable: not stackable"
    } (12 )
}
/*check fat metal via keep-out area*/
if (diff_fatTblViaKeepoutThreshold > 0 && diff_fatTblViaKeepoutMinSize > 0 && diff_fatTblViaKeepoutEnclosure > 0) {
    if (diff_fatTblViaKeepoutThreshold > 0) {
        if ((diff_fatTblViaKeepoutThreshold / 2.0) > 0.0005 ) {
           SIZE metal2  { UNDER_OVER = diff_fatTblViaKeepoutThreshold / 2.0 - 0.0005  } TEMP = fat_candidate
           if (diff_fatTblViaKeepoutNextThreshold > 0) {
              SIZE fat_candidate { UNDER_OVER = diff_fatTblViaKeepoutNextThreshold / 2.0 - 0.0005  } TEMP = fat_next
              BOOLEAN fat_candidate NOT fat_next { } TEMP = fat
              BOOLEAN fat AND metal2  { } TEMP = fat
              SET diff_fatTblViaKeepoutNextThreshold = 0;
           } else {
              BOOLEAN fat_candidate AND metal2  {  } TEMP = fat
           }
        } else {
           COPY metal2  { } TEMP = fat
           COPY metal2  { } TEMP = fat_candidate 
        }
    }
    VERTEX fat_candidate {
       CONVEX = TRUE
       SIZE = 0.001 
    } TEMP = fat_corners
    VERTEX fat {
       CONVEX = TRUE
       SIZE = 0.001 
    } TEMP = wire_corners
    SELECT wire_corners INTERACT fat_corners { } TEMP = wire_corners
    SELECT_EDGE fat INTERACT wire_corners { } TEMP = edge_corners
    SELECT_VECTOR edge_corners {
       LENGTH_RANGE = [0, diff_fatTblViaKeepoutMinSize- 0.0005 ]
    } TEMP = edge_tmp1
    BOOLEAN edge_corners NOT edge_tmp1 { } TEMP = edge_tmp2
    SELECT wire_corners OUTSIDE edge_tmp1 {  } TEMP = real_corners
    BOOLEAN edge_tmp2 AND real_corners { } TEMP = real_edge
    SIZE real_edge {
       VSIZE_HEAD = diff_fatTblViaKeepoutMinSize-2* 0.001 
       VSIZE_TAIL = diff_fatTblViaKeepoutMinSize-2* 0.001 
       VSIZE_INSIDE = diff_fatTblViaKeepoutEnclosure- 0.001 
    } TEMP = forb_corners
    SELECT via1  INSIDE fat { } TEMP = v_fat
    /* Work around: need an accurate via_cluster */
    SELECT via_cluster INSIDE fat { } TEMP = v_fat_cluster
    SELECT v_fat INTERACT forb_corners { } TEMP = bad_vias
    BOOLEAN v_fat NOT bad_vias { } TEMP = good_vias
    SELECT v_fat_cluster OUTSIDE good_vias { } TEMP = bad_v_fat_cluster
    SELECT v_fat INTERACT bad_v_fat_cluster {
       COMMENT = "$layer_name ViaKepOut: fat metal ( diff_fatTblViaKeepoutThreshold um) contact keep-out area ( diff_fatTblViaKeepoutMinSize um, diff_fatTblViaKeepoutEnclosure um) "
    } (12 )
}
 
/* reset variables */



 
SET diff_minSpacing = 0;
SET diff_netMinSpacing = 0;
SET diff_cornerMinSpacing = 0;
SET diff_minEnclosure = 0;
SET diff_endOfLineEnclosure = 0;
SET diff_not_stackable = 0;
SET diff_fatTblViaKeepoutThreshold = 0;
SET diff_fatTblViaKeepoutNextThreshold = 0;
SET diff_fatTblViaKeepoutMinSize = 0;
SET diff_fatTblViaKeepoutEnclosure = 0;
@ 793 "adrc/adrc.ev" 2

    }
}
DISCONNECT


/*via 2 / metal 3*/
SET layer_name = "V2/M3";





LOAD_CONNECT_DB all_layer

if (!layer_empty (via2 )) {
    if (!layer_empty (metal3 )) {
        
@ 1 "adrc/adrc_check_diff.ev" 1
/*check spacing*/
if (diff_minSpacing > 0 && diff_netMinSpacing > 0) {
    if (diff_cornerMinSpacing > 0) {
        if (cornerSpacingMode == 1) {
            /* Work around: CONVEX_TO_CONVEX [POINT_PROJECTION] has a bug */
            EXTERNAL via2  metal3  {
                SPACING <= 0
                CONVEX_TO_CONVEX [POINT_PROJECTION] < diff_cornerMinSpacing
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                BOX_CORNER = FALSE
                NODAL = TRUE
            } TEMP = diffNet_corner_err1
            EXTERNAL via2  metal3  {
                SPACING <= 0
                CONVEX_TO_CONVEX < diff_cornerMinSpacing
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                BOX_CORNER = TRUE
                NODAL = TRUE
            } TEMP = diffNet_corner_err2
            BOOLEAN diffNet_corner_err1 OR diffNet_corner_err2 {
                COMMENT = "$layer_name Spacing   : corner to corner spacing = diff_cornerMinSpacing um "
            } (13 )
            EXTERNAL via2  metal3  {
                COMMENT = "$layer_name Spacing   : minimum spacing = diff_netMinSpacing um"
                SPACING < diff_netMinSpacing
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                NON_PARALLEL = TRUE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
                NODAL = TRUE
            } (13 )
        } else {
            EXTERNAL via2  metal3  {
                COMMENT = "$layer_name Spacing  : minimum spacing = diff_netMinSpacing um (corner to corner spacing = diff_cornerMinSpacing um)"
                SPACING < diff_netMinSpacing
                CONVEX_TO_CONVEX < diff_cornerMinSpacing
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                TOUCH = TRUE
                NODAL = TRUE
            } (13 )
        }
    } else {
        EXTERNAL via2  metal3  {
            COMMENT = "$layer_name Spacing  : minimum spacing = diff_netMinSpacing um"
            SPACING < diff_netMinSpacing
            NON_PARALLEL = TRUE
            POINT_TOUCH = TRUE
            TOUCH = TRUE
            NODAL = TRUE
        } (13 )
    }
    if (diff_cornerMinSpacing > 0) {
        if (cornerSpacingMode == 1) {
            /* Work around: CONVEX_TO_CONVEX [POINT_PROJECTION] has a bug */
            EXTERNAL via2  metal3  {
                SPACING <= 0
                CONVEX_TO_CONVEX [POINT_PROJECTION] < diff_cornerMinSpacing
                FLAG_DISCONNECTED = FALSE
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                BOX_CORNER = FALSE
            } TEMP = sameNet_corner_err1
            EXTERNAL via2  metal3  {
                SPACING <= 0
                CONVEX_TO_CONVEX < diff_cornerMinSpacing
                FLAG_DISCONNECTED = FALSE
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                BOX_CORNER = TRUE
            } TEMP = sameNet_corner_err2
            BOOLEAN sameNet_corner_err1 OR sameNet_corner_err2 {
                COMMENT = "$layer_name Spacing   : corner to corner spacing = diff_cornerMinSpacing um "
            } (13 )
            EXTERNAL via2  metal3  {
                COMMENT = "$layer_name Spacing   : minimum spacing = diff_minSpacing um"
                SPACING < diff_minSpacing
                FLAG_DISCONNECTED = FALSE
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                NON_PARALLEL = TRUE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
            } (13 )
        } else {
            EXTERNAL via2  metal3  {
                COMMENT = "$layer_name Spacing  : minimum spacing = diff_minSpacing um (corner to corner spacing = diff_cornerMinSpacing um)"
                SPACING < diff_minSpacing
                CONVEX_TO_CONVEX < diff_cornerMinSpacing
                FLAG_DISCONNECTED = FALSE
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                TOUCH = TRUE
            } (13 )
        }
    } else {
        EXTERNAL via2  metal3  {
            COMMENT = "$layer_name Spacing  : minimum spacing = diff_minSpacing um"
            SPACING < diff_minSpacing
            FLAG_DISCONNECTED = FALSE
            NON_PARALLEL = TRUE
            POINT_TOUCH = TRUE
            TOUCH = TRUE
        } (13 )
    }
} else {
    if (diff_netMinSpacing > 0) {
        if (diff_cornerMinSpacing > 0) {
            if (cornerSpacingMode == 1) {
                /* Work around: CONVEX_TO_CONVEX [POINT_PROJECTION] has a bug */
                EXTERNAL via2  metal3  {
                    SPACING <= 0
                    CONVEX_TO_CONVEX [POINT_PROJECTION] < diff_cornerMinSpacing
                    NON_PARALLEL = TRUE
                    POINT_TOUCH = TRUE
                    BOX_CORNER = FALSE
                    NODAL = TRUE
                } TEMP = corner_err1
                EXTERNAL via2  metal3  {
                    SPACING <= 0
                    CONVEX_TO_CONVEX < diff_cornerMinSpacing
                    NON_PARALLEL = TRUE
                    POINT_TOUCH = TRUE
                    BOX_CORNER = TRUE
                    NODAL = TRUE
                } TEMP = corner_err2
                BOOLEAN corner_err1 OR corner_err2 {
                    COMMENT = "$layer_name Spacing   : corner to corner spacing = diff_cornerMinSpacing um "
                } (13 )
                EXTERNAL via2  metal3  {
                    COMMENT = "$layer_name Spacing   : minimum spacing = diff_netMinSpacing um"
                    SPACING < diff_netMinSpacing
                    SET_CORNERS_TO_SPACING = FALSE
                    PARALLEL_POINT_PROJECTION = FALSE
                    NON_PARALLEL = TRUE
                    TOUCH = FALSE
                    POINT_TOUCH = FALSE
                    NODAL = TRUE
                } (13 )
            } else {
                EXTERNAL via2  metal3  {
                    COMMENT = "$layer_name Spacing  : minimum spacing = diff_netMinSpacing um (corner to corner spacing = diff_cornerMinSpacing um)"
                    SPACING < diff_netMinSpacing
                    CONVEX_TO_CONVEX < diff_cornerMinSpacing
                    NON_PARALLEL = TRUE
                    POINT_TOUCH = TRUE
                    TOUCH = TRUE
                    NODAL = TRUE
                } (13 )
            }
        } else {
            EXTERNAL via2  metal3  {
                COMMENT = "$layer_name Spacing  : minimum spacing = diff_netMinSpacing um"
                SPACING < diff_netMinSpacing
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                TOUCH = TRUE
                NODAL = TRUE
            } (13 )
        }
    } else if (diff_minSpacing > 0) {
        if (diff_cornerMinSpacing > 0) {
            if (cornerSpacingMode == 1) {
                /* Work around: CONVEX_TO_CONVEX [POINT_PROJECTION] has a bug */
                EXTERNAL via2  metal3  {
                    SPACING <= 0
                    CONVEX_TO_CONVEX [POINT_PROJECTION] < diff_cornerMinSpacing
                    NON_PARALLEL = TRUE
                    POINT_TOUCH = TRUE
                    BOX_CORNER = FALSE
                } TEMP = corner_err1
                EXTERNAL via2  metal3  {
                    SPACING <= 0
                    CONVEX_TO_CONVEX < diff_cornerMinSpacing
                    NON_PARALLEL = TRUE
                    POINT_TOUCH = TRUE
                    BOX_CORNER = TRUE
                } TEMP = corner_err2
                BOOLEAN corner_err1 OR corner_err2 {
                    COMMENT = "$layer_name Spacing   : corner to corner spacing = diff_cornerMinSpacing um "
                } (13 )
                EXTERNAL via2  metal3  {
                    COMMENT = "$layer_name Spacing   : minimum spacing = diff_minSpacing um"
                    SPACING < diff_minSpacing
                    SET_CORNERS_TO_SPACING = FALSE
                    PARALLEL_POINT_PROJECTION = FALSE
                    NON_PARALLEL = TRUE
                    TOUCH = FALSE
                    POINT_TOUCH = FALSE
                } (13 )
            } else {
                EXTERNAL via2  metal3  {
                    COMMENT = "$layer_name Spacing  : minimum spacing = diff_minSpacing um (corner to corner spacing = diff_cornerMinSpacing um)"
                    SPACING < diff_minSpacing
                    CONVEX_TO_CONVEX < diff_cornerMinSpacing
                    NON_PARALLEL = TRUE
                    POINT_TOUCH = TRUE
                    TOUCH = TRUE
                } (13 )
            }
        } else {
            EXTERNAL via2  metal3  {
                COMMENT = "$layer_name Spacing  : minimum spacing = diff_minSpacing um"
                SPACING < diff_minSpacing
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                TOUCH = TRUE
            } (13 )
        }
    }
}
 
/*check enclosure*/
if (diff_minEnclosure > 0) {
    ENCLOSE via2  BY metal3  {
        COMMENT = "$layer_name Enclosure: minimum enclosure ( diff_minEnclosure )"
        SPACING < diff_minEnclosure
	NON_PARALLEL = TRUE
	POINT_TOUCH = TRUE
	TOUCH = TRUE
    } (13 )
    BOOLEAN via2  NOT metal3  {
        COMMENT = "$layer_name Enclosure: minimum enclosure ( diff_minEnclosure )"
    } (13 )
}
 
/*check end_of_line enclosure*/
if (diff_endOfLineEnclosure > 0) {
    if (diff_minEnclosure  == 0) {
       BOOLEAN via2  NOT metal3  {
           COMMENT = "$layer_name EndOfLine: end-of-line minimum enclosure ( diff_endOfLineEnclosure )"
       } (13 )
    }
    if (diff_endOfLineMode == 0) {
        ENCLOSE via2  BY metal3  {
	    SPACING < diff_endOfLineEnclosure
	    SET_CORNERS_TO_SPACING = FALSE
	    PARALLEL_POINT_PROJECTION = FALSE
	    SHADOW_OTHER_LAYER = TRUE  
	    TOUCH = TRUE
	    POINT_TOUCH = FALSE
	    NON_PARALLEL = TRUE
            OUTPUT_EDGES = TRUE
        } TEMP = violation
 
        SELECT_EDGE via2  TOUCHING violation {  } TEMP = edges
        SELECT_VECTOR edges { ANGLE_RANGE = [0, 0] } TEMP = h_edges
        SELECT_VECTOR edges { ANGLE_RANGE = [90, 90] } TEMP = v_edges
        SELECT h_edges INTERACT v_edges { POINT_TOUCH = TRUE } TEMP = h_edges
 
        SELECT via2  ENCLOSING h_edges {
            COMMENT = "$layer_name EndOfLine: end-of-line minimum enclosure ( diff_endOfLineEnclosure )"
        } (13 )
    }
    else {
    }
}
 
/*check stackable*/
if (diff_not_stackable > 0) {
     BOOLEAN via2  AND metal3  {
        COMMENT = "$layer_name Stackable: not stackable"
    } (13 )
}
/*check fat metal via keep-out area*/
if (diff_fatTblViaKeepoutThreshold > 0 && diff_fatTblViaKeepoutMinSize > 0 && diff_fatTblViaKeepoutEnclosure > 0) {
    if (diff_fatTblViaKeepoutThreshold > 0) {
        if ((diff_fatTblViaKeepoutThreshold / 2.0) > 0.0005 ) {
           SIZE metal3  { UNDER_OVER = diff_fatTblViaKeepoutThreshold / 2.0 - 0.0005  } TEMP = fat_candidate
           if (diff_fatTblViaKeepoutNextThreshold > 0) {
              SIZE fat_candidate { UNDER_OVER = diff_fatTblViaKeepoutNextThreshold / 2.0 - 0.0005  } TEMP = fat_next
              BOOLEAN fat_candidate NOT fat_next { } TEMP = fat
              BOOLEAN fat AND metal3  { } TEMP = fat
              SET diff_fatTblViaKeepoutNextThreshold = 0;
           } else {
              BOOLEAN fat_candidate AND metal3  {  } TEMP = fat
           }
        } else {
           COPY metal3  { } TEMP = fat
           COPY metal3  { } TEMP = fat_candidate 
        }
    }
    VERTEX fat_candidate {
       CONVEX = TRUE
       SIZE = 0.001 
    } TEMP = fat_corners
    VERTEX fat {
       CONVEX = TRUE
       SIZE = 0.001 
    } TEMP = wire_corners
    SELECT wire_corners INTERACT fat_corners { } TEMP = wire_corners
    SELECT_EDGE fat INTERACT wire_corners { } TEMP = edge_corners
    SELECT_VECTOR edge_corners {
       LENGTH_RANGE = [0, diff_fatTblViaKeepoutMinSize- 0.0005 ]
    } TEMP = edge_tmp1
    BOOLEAN edge_corners NOT edge_tmp1 { } TEMP = edge_tmp2
    SELECT wire_corners OUTSIDE edge_tmp1 {  } TEMP = real_corners
    BOOLEAN edge_tmp2 AND real_corners { } TEMP = real_edge
    SIZE real_edge {
       VSIZE_HEAD = diff_fatTblViaKeepoutMinSize-2* 0.001 
       VSIZE_TAIL = diff_fatTblViaKeepoutMinSize-2* 0.001 
       VSIZE_INSIDE = diff_fatTblViaKeepoutEnclosure- 0.001 
    } TEMP = forb_corners
    SELECT via2  INSIDE fat { } TEMP = v_fat
    /* Work around: need an accurate via_cluster */
    SELECT via_cluster INSIDE fat { } TEMP = v_fat_cluster
    SELECT v_fat INTERACT forb_corners { } TEMP = bad_vias
    BOOLEAN v_fat NOT bad_vias { } TEMP = good_vias
    SELECT v_fat_cluster OUTSIDE good_vias { } TEMP = bad_v_fat_cluster
    SELECT v_fat INTERACT bad_v_fat_cluster {
       COMMENT = "$layer_name ViaKepOut: fat metal ( diff_fatTblViaKeepoutThreshold um) contact keep-out area ( diff_fatTblViaKeepoutMinSize um, diff_fatTblViaKeepoutEnclosure um) "
    } (13 )
}
 
/* reset variables */



 
SET diff_minSpacing = 0;
SET diff_netMinSpacing = 0;
SET diff_cornerMinSpacing = 0;
SET diff_minEnclosure = 0;
SET diff_endOfLineEnclosure = 0;
SET diff_not_stackable = 0;
SET diff_fatTblViaKeepoutThreshold = 0;
SET diff_fatTblViaKeepoutNextThreshold = 0;
SET diff_fatTblViaKeepoutMinSize = 0;
SET diff_fatTblViaKeepoutEnclosure = 0;
@ 810 "adrc/adrc.ev" 2

    }
}
DISCONNECT


/*via 3 / metal 4*/
SET layer_name = "V3/M4";





LOAD_CONNECT_DB all_layer

if (!layer_empty (via3 )) {
    if (!layer_empty (metal4 )) {
        
@ 1 "adrc/adrc_check_diff.ev" 1
/*check spacing*/
if (diff_minSpacing > 0 && diff_netMinSpacing > 0) {
    if (diff_cornerMinSpacing > 0) {
        if (cornerSpacingMode == 1) {
            /* Work around: CONVEX_TO_CONVEX [POINT_PROJECTION] has a bug */
            EXTERNAL via3  metal4  {
                SPACING <= 0
                CONVEX_TO_CONVEX [POINT_PROJECTION] < diff_cornerMinSpacing
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                BOX_CORNER = FALSE
                NODAL = TRUE
            } TEMP = diffNet_corner_err1
            EXTERNAL via3  metal4  {
                SPACING <= 0
                CONVEX_TO_CONVEX < diff_cornerMinSpacing
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                BOX_CORNER = TRUE
                NODAL = TRUE
            } TEMP = diffNet_corner_err2
            BOOLEAN diffNet_corner_err1 OR diffNet_corner_err2 {
                COMMENT = "$layer_name Spacing   : corner to corner spacing = diff_cornerMinSpacing um "
            } (14 )
            EXTERNAL via3  metal4  {
                COMMENT = "$layer_name Spacing   : minimum spacing = diff_netMinSpacing um"
                SPACING < diff_netMinSpacing
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                NON_PARALLEL = TRUE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
                NODAL = TRUE
            } (14 )
        } else {
            EXTERNAL via3  metal4  {
                COMMENT = "$layer_name Spacing  : minimum spacing = diff_netMinSpacing um (corner to corner spacing = diff_cornerMinSpacing um)"
                SPACING < diff_netMinSpacing
                CONVEX_TO_CONVEX < diff_cornerMinSpacing
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                TOUCH = TRUE
                NODAL = TRUE
            } (14 )
        }
    } else {
        EXTERNAL via3  metal4  {
            COMMENT = "$layer_name Spacing  : minimum spacing = diff_netMinSpacing um"
            SPACING < diff_netMinSpacing
            NON_PARALLEL = TRUE
            POINT_TOUCH = TRUE
            TOUCH = TRUE
            NODAL = TRUE
        } (14 )
    }
    if (diff_cornerMinSpacing > 0) {
        if (cornerSpacingMode == 1) {
            /* Work around: CONVEX_TO_CONVEX [POINT_PROJECTION] has a bug */
            EXTERNAL via3  metal4  {
                SPACING <= 0
                CONVEX_TO_CONVEX [POINT_PROJECTION] < diff_cornerMinSpacing
                FLAG_DISCONNECTED = FALSE
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                BOX_CORNER = FALSE
            } TEMP = sameNet_corner_err1
            EXTERNAL via3  metal4  {
                SPACING <= 0
                CONVEX_TO_CONVEX < diff_cornerMinSpacing
                FLAG_DISCONNECTED = FALSE
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                BOX_CORNER = TRUE
            } TEMP = sameNet_corner_err2
            BOOLEAN sameNet_corner_err1 OR sameNet_corner_err2 {
                COMMENT = "$layer_name Spacing   : corner to corner spacing = diff_cornerMinSpacing um "
            } (14 )
            EXTERNAL via3  metal4  {
                COMMENT = "$layer_name Spacing   : minimum spacing = diff_minSpacing um"
                SPACING < diff_minSpacing
                FLAG_DISCONNECTED = FALSE
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                NON_PARALLEL = TRUE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
            } (14 )
        } else {
            EXTERNAL via3  metal4  {
                COMMENT = "$layer_name Spacing  : minimum spacing = diff_minSpacing um (corner to corner spacing = diff_cornerMinSpacing um)"
                SPACING < diff_minSpacing
                CONVEX_TO_CONVEX < diff_cornerMinSpacing
                FLAG_DISCONNECTED = FALSE
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                TOUCH = TRUE
            } (14 )
        }
    } else {
        EXTERNAL via3  metal4  {
            COMMENT = "$layer_name Spacing  : minimum spacing = diff_minSpacing um"
            SPACING < diff_minSpacing
            FLAG_DISCONNECTED = FALSE
            NON_PARALLEL = TRUE
            POINT_TOUCH = TRUE
            TOUCH = TRUE
        } (14 )
    }
} else {
    if (diff_netMinSpacing > 0) {
        if (diff_cornerMinSpacing > 0) {
            if (cornerSpacingMode == 1) {
                /* Work around: CONVEX_TO_CONVEX [POINT_PROJECTION] has a bug */
                EXTERNAL via3  metal4  {
                    SPACING <= 0
                    CONVEX_TO_CONVEX [POINT_PROJECTION] < diff_cornerMinSpacing
                    NON_PARALLEL = TRUE
                    POINT_TOUCH = TRUE
                    BOX_CORNER = FALSE
                    NODAL = TRUE
                } TEMP = corner_err1
                EXTERNAL via3  metal4  {
                    SPACING <= 0
                    CONVEX_TO_CONVEX < diff_cornerMinSpacing
                    NON_PARALLEL = TRUE
                    POINT_TOUCH = TRUE
                    BOX_CORNER = TRUE
                    NODAL = TRUE
                } TEMP = corner_err2
                BOOLEAN corner_err1 OR corner_err2 {
                    COMMENT = "$layer_name Spacing   : corner to corner spacing = diff_cornerMinSpacing um "
                } (14 )
                EXTERNAL via3  metal4  {
                    COMMENT = "$layer_name Spacing   : minimum spacing = diff_netMinSpacing um"
                    SPACING < diff_netMinSpacing
                    SET_CORNERS_TO_SPACING = FALSE
                    PARALLEL_POINT_PROJECTION = FALSE
                    NON_PARALLEL = TRUE
                    TOUCH = FALSE
                    POINT_TOUCH = FALSE
                    NODAL = TRUE
                } (14 )
            } else {
                EXTERNAL via3  metal4  {
                    COMMENT = "$layer_name Spacing  : minimum spacing = diff_netMinSpacing um (corner to corner spacing = diff_cornerMinSpacing um)"
                    SPACING < diff_netMinSpacing
                    CONVEX_TO_CONVEX < diff_cornerMinSpacing
                    NON_PARALLEL = TRUE
                    POINT_TOUCH = TRUE
                    TOUCH = TRUE
                    NODAL = TRUE
                } (14 )
            }
        } else {
            EXTERNAL via3  metal4  {
                COMMENT = "$layer_name Spacing  : minimum spacing = diff_netMinSpacing um"
                SPACING < diff_netMinSpacing
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                TOUCH = TRUE
                NODAL = TRUE
            } (14 )
        }
    } else if (diff_minSpacing > 0) {
        if (diff_cornerMinSpacing > 0) {
            if (cornerSpacingMode == 1) {
                /* Work around: CONVEX_TO_CONVEX [POINT_PROJECTION] has a bug */
                EXTERNAL via3  metal4  {
                    SPACING <= 0
                    CONVEX_TO_CONVEX [POINT_PROJECTION] < diff_cornerMinSpacing
                    NON_PARALLEL = TRUE
                    POINT_TOUCH = TRUE
                    BOX_CORNER = FALSE
                } TEMP = corner_err1
                EXTERNAL via3  metal4  {
                    SPACING <= 0
                    CONVEX_TO_CONVEX < diff_cornerMinSpacing
                    NON_PARALLEL = TRUE
                    POINT_TOUCH = TRUE
                    BOX_CORNER = TRUE
                } TEMP = corner_err2
                BOOLEAN corner_err1 OR corner_err2 {
                    COMMENT = "$layer_name Spacing   : corner to corner spacing = diff_cornerMinSpacing um "
                } (14 )
                EXTERNAL via3  metal4  {
                    COMMENT = "$layer_name Spacing   : minimum spacing = diff_minSpacing um"
                    SPACING < diff_minSpacing
                    SET_CORNERS_TO_SPACING = FALSE
                    PARALLEL_POINT_PROJECTION = FALSE
                    NON_PARALLEL = TRUE
                    TOUCH = FALSE
                    POINT_TOUCH = FALSE
                } (14 )
            } else {
                EXTERNAL via3  metal4  {
                    COMMENT = "$layer_name Spacing  : minimum spacing = diff_minSpacing um (corner to corner spacing = diff_cornerMinSpacing um)"
                    SPACING < diff_minSpacing
                    CONVEX_TO_CONVEX < diff_cornerMinSpacing
                    NON_PARALLEL = TRUE
                    POINT_TOUCH = TRUE
                    TOUCH = TRUE
                } (14 )
            }
        } else {
            EXTERNAL via3  metal4  {
                COMMENT = "$layer_name Spacing  : minimum spacing = diff_minSpacing um"
                SPACING < diff_minSpacing
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                TOUCH = TRUE
            } (14 )
        }
    }
}
 
/*check enclosure*/
if (diff_minEnclosure > 0) {
    ENCLOSE via3  BY metal4  {
        COMMENT = "$layer_name Enclosure: minimum enclosure ( diff_minEnclosure )"
        SPACING < diff_minEnclosure
	NON_PARALLEL = TRUE
	POINT_TOUCH = TRUE
	TOUCH = TRUE
    } (14 )
    BOOLEAN via3  NOT metal4  {
        COMMENT = "$layer_name Enclosure: minimum enclosure ( diff_minEnclosure )"
    } (14 )
}
 
/*check end_of_line enclosure*/
if (diff_endOfLineEnclosure > 0) {
    if (diff_minEnclosure  == 0) {
       BOOLEAN via3  NOT metal4  {
           COMMENT = "$layer_name EndOfLine: end-of-line minimum enclosure ( diff_endOfLineEnclosure )"
       } (14 )
    }
    if (diff_endOfLineMode == 0) {
        ENCLOSE via3  BY metal4  {
	    SPACING < diff_endOfLineEnclosure
	    SET_CORNERS_TO_SPACING = FALSE
	    PARALLEL_POINT_PROJECTION = FALSE
	    SHADOW_OTHER_LAYER = TRUE  
	    TOUCH = TRUE
	    POINT_TOUCH = FALSE
	    NON_PARALLEL = TRUE
            OUTPUT_EDGES = TRUE
        } TEMP = violation
 
        SELECT_EDGE via3  TOUCHING violation {  } TEMP = edges
        SELECT_VECTOR edges { ANGLE_RANGE = [0, 0] } TEMP = h_edges
        SELECT_VECTOR edges { ANGLE_RANGE = [90, 90] } TEMP = v_edges
        SELECT h_edges INTERACT v_edges { POINT_TOUCH = TRUE } TEMP = h_edges
 
        SELECT via3  ENCLOSING h_edges {
            COMMENT = "$layer_name EndOfLine: end-of-line minimum enclosure ( diff_endOfLineEnclosure )"
        } (14 )
    }
    else {
    }
}
 
/*check stackable*/
if (diff_not_stackable > 0) {
     BOOLEAN via3  AND metal4  {
        COMMENT = "$layer_name Stackable: not stackable"
    } (14 )
}
/*check fat metal via keep-out area*/
if (diff_fatTblViaKeepoutThreshold > 0 && diff_fatTblViaKeepoutMinSize > 0 && diff_fatTblViaKeepoutEnclosure > 0) {
    if (diff_fatTblViaKeepoutThreshold > 0) {
        if ((diff_fatTblViaKeepoutThreshold / 2.0) > 0.0005 ) {
           SIZE metal4  { UNDER_OVER = diff_fatTblViaKeepoutThreshold / 2.0 - 0.0005  } TEMP = fat_candidate
           if (diff_fatTblViaKeepoutNextThreshold > 0) {
              SIZE fat_candidate { UNDER_OVER = diff_fatTblViaKeepoutNextThreshold / 2.0 - 0.0005  } TEMP = fat_next
              BOOLEAN fat_candidate NOT fat_next { } TEMP = fat
              BOOLEAN fat AND metal4  { } TEMP = fat
              SET diff_fatTblViaKeepoutNextThreshold = 0;
           } else {
              BOOLEAN fat_candidate AND metal4  {  } TEMP = fat
           }
        } else {
           COPY metal4  { } TEMP = fat
           COPY metal4  { } TEMP = fat_candidate 
        }
    }
    VERTEX fat_candidate {
       CONVEX = TRUE
       SIZE = 0.001 
    } TEMP = fat_corners
    VERTEX fat {
       CONVEX = TRUE
       SIZE = 0.001 
    } TEMP = wire_corners
    SELECT wire_corners INTERACT fat_corners { } TEMP = wire_corners
    SELECT_EDGE fat INTERACT wire_corners { } TEMP = edge_corners
    SELECT_VECTOR edge_corners {
       LENGTH_RANGE = [0, diff_fatTblViaKeepoutMinSize- 0.0005 ]
    } TEMP = edge_tmp1
    BOOLEAN edge_corners NOT edge_tmp1 { } TEMP = edge_tmp2
    SELECT wire_corners OUTSIDE edge_tmp1 {  } TEMP = real_corners
    BOOLEAN edge_tmp2 AND real_corners { } TEMP = real_edge
    SIZE real_edge {
       VSIZE_HEAD = diff_fatTblViaKeepoutMinSize-2* 0.001 
       VSIZE_TAIL = diff_fatTblViaKeepoutMinSize-2* 0.001 
       VSIZE_INSIDE = diff_fatTblViaKeepoutEnclosure- 0.001 
    } TEMP = forb_corners
    SELECT via3  INSIDE fat { } TEMP = v_fat
    /* Work around: need an accurate via_cluster */
    SELECT via_cluster INSIDE fat { } TEMP = v_fat_cluster
    SELECT v_fat INTERACT forb_corners { } TEMP = bad_vias
    BOOLEAN v_fat NOT bad_vias { } TEMP = good_vias
    SELECT v_fat_cluster OUTSIDE good_vias { } TEMP = bad_v_fat_cluster
    SELECT v_fat INTERACT bad_v_fat_cluster {
       COMMENT = "$layer_name ViaKepOut: fat metal ( diff_fatTblViaKeepoutThreshold um) contact keep-out area ( diff_fatTblViaKeepoutMinSize um, diff_fatTblViaKeepoutEnclosure um) "
    } (14 )
}
 
/* reset variables */



 
SET diff_minSpacing = 0;
SET diff_netMinSpacing = 0;
SET diff_cornerMinSpacing = 0;
SET diff_minEnclosure = 0;
SET diff_endOfLineEnclosure = 0;
SET diff_not_stackable = 0;
SET diff_fatTblViaKeepoutThreshold = 0;
SET diff_fatTblViaKeepoutNextThreshold = 0;
SET diff_fatTblViaKeepoutMinSize = 0;
SET diff_fatTblViaKeepoutEnclosure = 0;
@ 827 "adrc/adrc.ev" 2

    }
}
DISCONNECT


/*via 4 / metal 5*/
SET layer_name = "V4/M5";





LOAD_CONNECT_DB all_layer

if (!layer_empty (via4 )) {
    if (!layer_empty (metal5 )) {
        
@ 1 "adrc/adrc_check_diff.ev" 1
/*check spacing*/
if (diff_minSpacing > 0 && diff_netMinSpacing > 0) {
    if (diff_cornerMinSpacing > 0) {
        if (cornerSpacingMode == 1) {
            /* Work around: CONVEX_TO_CONVEX [POINT_PROJECTION] has a bug */
            EXTERNAL via4  metal5  {
                SPACING <= 0
                CONVEX_TO_CONVEX [POINT_PROJECTION] < diff_cornerMinSpacing
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                BOX_CORNER = FALSE
                NODAL = TRUE
            } TEMP = diffNet_corner_err1
            EXTERNAL via4  metal5  {
                SPACING <= 0
                CONVEX_TO_CONVEX < diff_cornerMinSpacing
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                BOX_CORNER = TRUE
                NODAL = TRUE
            } TEMP = diffNet_corner_err2
            BOOLEAN diffNet_corner_err1 OR diffNet_corner_err2 {
                COMMENT = "$layer_name Spacing   : corner to corner spacing = diff_cornerMinSpacing um "
            } (15 )
            EXTERNAL via4  metal5  {
                COMMENT = "$layer_name Spacing   : minimum spacing = diff_netMinSpacing um"
                SPACING < diff_netMinSpacing
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                NON_PARALLEL = TRUE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
                NODAL = TRUE
            } (15 )
        } else {
            EXTERNAL via4  metal5  {
                COMMENT = "$layer_name Spacing  : minimum spacing = diff_netMinSpacing um (corner to corner spacing = diff_cornerMinSpacing um)"
                SPACING < diff_netMinSpacing
                CONVEX_TO_CONVEX < diff_cornerMinSpacing
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                TOUCH = TRUE
                NODAL = TRUE
            } (15 )
        }
    } else {
        EXTERNAL via4  metal5  {
            COMMENT = "$layer_name Spacing  : minimum spacing = diff_netMinSpacing um"
            SPACING < diff_netMinSpacing
            NON_PARALLEL = TRUE
            POINT_TOUCH = TRUE
            TOUCH = TRUE
            NODAL = TRUE
        } (15 )
    }
    if (diff_cornerMinSpacing > 0) {
        if (cornerSpacingMode == 1) {
            /* Work around: CONVEX_TO_CONVEX [POINT_PROJECTION] has a bug */
            EXTERNAL via4  metal5  {
                SPACING <= 0
                CONVEX_TO_CONVEX [POINT_PROJECTION] < diff_cornerMinSpacing
                FLAG_DISCONNECTED = FALSE
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                BOX_CORNER = FALSE
            } TEMP = sameNet_corner_err1
            EXTERNAL via4  metal5  {
                SPACING <= 0
                CONVEX_TO_CONVEX < diff_cornerMinSpacing
                FLAG_DISCONNECTED = FALSE
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                BOX_CORNER = TRUE
            } TEMP = sameNet_corner_err2
            BOOLEAN sameNet_corner_err1 OR sameNet_corner_err2 {
                COMMENT = "$layer_name Spacing   : corner to corner spacing = diff_cornerMinSpacing um "
            } (15 )
            EXTERNAL via4  metal5  {
                COMMENT = "$layer_name Spacing   : minimum spacing = diff_minSpacing um"
                SPACING < diff_minSpacing
                FLAG_DISCONNECTED = FALSE
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                NON_PARALLEL = TRUE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
            } (15 )
        } else {
            EXTERNAL via4  metal5  {
                COMMENT = "$layer_name Spacing  : minimum spacing = diff_minSpacing um (corner to corner spacing = diff_cornerMinSpacing um)"
                SPACING < diff_minSpacing
                CONVEX_TO_CONVEX < diff_cornerMinSpacing
                FLAG_DISCONNECTED = FALSE
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                TOUCH = TRUE
            } (15 )
        }
    } else {
        EXTERNAL via4  metal5  {
            COMMENT = "$layer_name Spacing  : minimum spacing = diff_minSpacing um"
            SPACING < diff_minSpacing
            FLAG_DISCONNECTED = FALSE
            NON_PARALLEL = TRUE
            POINT_TOUCH = TRUE
            TOUCH = TRUE
        } (15 )
    }
} else {
    if (diff_netMinSpacing > 0) {
        if (diff_cornerMinSpacing > 0) {
            if (cornerSpacingMode == 1) {
                /* Work around: CONVEX_TO_CONVEX [POINT_PROJECTION] has a bug */
                EXTERNAL via4  metal5  {
                    SPACING <= 0
                    CONVEX_TO_CONVEX [POINT_PROJECTION] < diff_cornerMinSpacing
                    NON_PARALLEL = TRUE
                    POINT_TOUCH = TRUE
                    BOX_CORNER = FALSE
                    NODAL = TRUE
                } TEMP = corner_err1
                EXTERNAL via4  metal5  {
                    SPACING <= 0
                    CONVEX_TO_CONVEX < diff_cornerMinSpacing
                    NON_PARALLEL = TRUE
                    POINT_TOUCH = TRUE
                    BOX_CORNER = TRUE
                    NODAL = TRUE
                } TEMP = corner_err2
                BOOLEAN corner_err1 OR corner_err2 {
                    COMMENT = "$layer_name Spacing   : corner to corner spacing = diff_cornerMinSpacing um "
                } (15 )
                EXTERNAL via4  metal5  {
                    COMMENT = "$layer_name Spacing   : minimum spacing = diff_netMinSpacing um"
                    SPACING < diff_netMinSpacing
                    SET_CORNERS_TO_SPACING = FALSE
                    PARALLEL_POINT_PROJECTION = FALSE
                    NON_PARALLEL = TRUE
                    TOUCH = FALSE
                    POINT_TOUCH = FALSE
                    NODAL = TRUE
                } (15 )
            } else {
                EXTERNAL via4  metal5  {
                    COMMENT = "$layer_name Spacing  : minimum spacing = diff_netMinSpacing um (corner to corner spacing = diff_cornerMinSpacing um)"
                    SPACING < diff_netMinSpacing
                    CONVEX_TO_CONVEX < diff_cornerMinSpacing
                    NON_PARALLEL = TRUE
                    POINT_TOUCH = TRUE
                    TOUCH = TRUE
                    NODAL = TRUE
                } (15 )
            }
        } else {
            EXTERNAL via4  metal5  {
                COMMENT = "$layer_name Spacing  : minimum spacing = diff_netMinSpacing um"
                SPACING < diff_netMinSpacing
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                TOUCH = TRUE
                NODAL = TRUE
            } (15 )
        }
    } else if (diff_minSpacing > 0) {
        if (diff_cornerMinSpacing > 0) {
            if (cornerSpacingMode == 1) {
                /* Work around: CONVEX_TO_CONVEX [POINT_PROJECTION] has a bug */
                EXTERNAL via4  metal5  {
                    SPACING <= 0
                    CONVEX_TO_CONVEX [POINT_PROJECTION] < diff_cornerMinSpacing
                    NON_PARALLEL = TRUE
                    POINT_TOUCH = TRUE
                    BOX_CORNER = FALSE
                } TEMP = corner_err1
                EXTERNAL via4  metal5  {
                    SPACING <= 0
                    CONVEX_TO_CONVEX < diff_cornerMinSpacing
                    NON_PARALLEL = TRUE
                    POINT_TOUCH = TRUE
                    BOX_CORNER = TRUE
                } TEMP = corner_err2
                BOOLEAN corner_err1 OR corner_err2 {
                    COMMENT = "$layer_name Spacing   : corner to corner spacing = diff_cornerMinSpacing um "
                } (15 )
                EXTERNAL via4  metal5  {
                    COMMENT = "$layer_name Spacing   : minimum spacing = diff_minSpacing um"
                    SPACING < diff_minSpacing
                    SET_CORNERS_TO_SPACING = FALSE
                    PARALLEL_POINT_PROJECTION = FALSE
                    NON_PARALLEL = TRUE
                    TOUCH = FALSE
                    POINT_TOUCH = FALSE
                } (15 )
            } else {
                EXTERNAL via4  metal5  {
                    COMMENT = "$layer_name Spacing  : minimum spacing = diff_minSpacing um (corner to corner spacing = diff_cornerMinSpacing um)"
                    SPACING < diff_minSpacing
                    CONVEX_TO_CONVEX < diff_cornerMinSpacing
                    NON_PARALLEL = TRUE
                    POINT_TOUCH = TRUE
                    TOUCH = TRUE
                } (15 )
            }
        } else {
            EXTERNAL via4  metal5  {
                COMMENT = "$layer_name Spacing  : minimum spacing = diff_minSpacing um"
                SPACING < diff_minSpacing
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                TOUCH = TRUE
            } (15 )
        }
    }
}
 
/*check enclosure*/
if (diff_minEnclosure > 0) {
    ENCLOSE via4  BY metal5  {
        COMMENT = "$layer_name Enclosure: minimum enclosure ( diff_minEnclosure )"
        SPACING < diff_minEnclosure
	NON_PARALLEL = TRUE
	POINT_TOUCH = TRUE
	TOUCH = TRUE
    } (15 )
    BOOLEAN via4  NOT metal5  {
        COMMENT = "$layer_name Enclosure: minimum enclosure ( diff_minEnclosure )"
    } (15 )
}
 
/*check end_of_line enclosure*/
if (diff_endOfLineEnclosure > 0) {
    if (diff_minEnclosure  == 0) {
       BOOLEAN via4  NOT metal5  {
           COMMENT = "$layer_name EndOfLine: end-of-line minimum enclosure ( diff_endOfLineEnclosure )"
       } (15 )
    }
    if (diff_endOfLineMode == 0) {
        ENCLOSE via4  BY metal5  {
	    SPACING < diff_endOfLineEnclosure
	    SET_CORNERS_TO_SPACING = FALSE
	    PARALLEL_POINT_PROJECTION = FALSE
	    SHADOW_OTHER_LAYER = TRUE  
	    TOUCH = TRUE
	    POINT_TOUCH = FALSE
	    NON_PARALLEL = TRUE
            OUTPUT_EDGES = TRUE
        } TEMP = violation
 
        SELECT_EDGE via4  TOUCHING violation {  } TEMP = edges
        SELECT_VECTOR edges { ANGLE_RANGE = [0, 0] } TEMP = h_edges
        SELECT_VECTOR edges { ANGLE_RANGE = [90, 90] } TEMP = v_edges
        SELECT h_edges INTERACT v_edges { POINT_TOUCH = TRUE } TEMP = h_edges
 
        SELECT via4  ENCLOSING h_edges {
            COMMENT = "$layer_name EndOfLine: end-of-line minimum enclosure ( diff_endOfLineEnclosure )"
        } (15 )
    }
    else {
    }
}
 
/*check stackable*/
if (diff_not_stackable > 0) {
     BOOLEAN via4  AND metal5  {
        COMMENT = "$layer_name Stackable: not stackable"
    } (15 )
}
/*check fat metal via keep-out area*/
if (diff_fatTblViaKeepoutThreshold > 0 && diff_fatTblViaKeepoutMinSize > 0 && diff_fatTblViaKeepoutEnclosure > 0) {
    if (diff_fatTblViaKeepoutThreshold > 0) {
        if ((diff_fatTblViaKeepoutThreshold / 2.0) > 0.0005 ) {
           SIZE metal5  { UNDER_OVER = diff_fatTblViaKeepoutThreshold / 2.0 - 0.0005  } TEMP = fat_candidate
           if (diff_fatTblViaKeepoutNextThreshold > 0) {
              SIZE fat_candidate { UNDER_OVER = diff_fatTblViaKeepoutNextThreshold / 2.0 - 0.0005  } TEMP = fat_next
              BOOLEAN fat_candidate NOT fat_next { } TEMP = fat
              BOOLEAN fat AND metal5  { } TEMP = fat
              SET diff_fatTblViaKeepoutNextThreshold = 0;
           } else {
              BOOLEAN fat_candidate AND metal5  {  } TEMP = fat
           }
        } else {
           COPY metal5  { } TEMP = fat
           COPY metal5  { } TEMP = fat_candidate 
        }
    }
    VERTEX fat_candidate {
       CONVEX = TRUE
       SIZE = 0.001 
    } TEMP = fat_corners
    VERTEX fat {
       CONVEX = TRUE
       SIZE = 0.001 
    } TEMP = wire_corners
    SELECT wire_corners INTERACT fat_corners { } TEMP = wire_corners
    SELECT_EDGE fat INTERACT wire_corners { } TEMP = edge_corners
    SELECT_VECTOR edge_corners {
       LENGTH_RANGE = [0, diff_fatTblViaKeepoutMinSize- 0.0005 ]
    } TEMP = edge_tmp1
    BOOLEAN edge_corners NOT edge_tmp1 { } TEMP = edge_tmp2
    SELECT wire_corners OUTSIDE edge_tmp1 {  } TEMP = real_corners
    BOOLEAN edge_tmp2 AND real_corners { } TEMP = real_edge
    SIZE real_edge {
       VSIZE_HEAD = diff_fatTblViaKeepoutMinSize-2* 0.001 
       VSIZE_TAIL = diff_fatTblViaKeepoutMinSize-2* 0.001 
       VSIZE_INSIDE = diff_fatTblViaKeepoutEnclosure- 0.001 
    } TEMP = forb_corners
    SELECT via4  INSIDE fat { } TEMP = v_fat
    /* Work around: need an accurate via_cluster */
    SELECT via_cluster INSIDE fat { } TEMP = v_fat_cluster
    SELECT v_fat INTERACT forb_corners { } TEMP = bad_vias
    BOOLEAN v_fat NOT bad_vias { } TEMP = good_vias
    SELECT v_fat_cluster OUTSIDE good_vias { } TEMP = bad_v_fat_cluster
    SELECT v_fat INTERACT bad_v_fat_cluster {
       COMMENT = "$layer_name ViaKepOut: fat metal ( diff_fatTblViaKeepoutThreshold um) contact keep-out area ( diff_fatTblViaKeepoutMinSize um, diff_fatTblViaKeepoutEnclosure um) "
    } (15 )
}
 
/* reset variables */



 
SET diff_minSpacing = 0;
SET diff_netMinSpacing = 0;
SET diff_cornerMinSpacing = 0;
SET diff_minEnclosure = 0;
SET diff_endOfLineEnclosure = 0;
SET diff_not_stackable = 0;
SET diff_fatTblViaKeepoutThreshold = 0;
SET diff_fatTblViaKeepoutNextThreshold = 0;
SET diff_fatTblViaKeepoutMinSize = 0;
SET diff_fatTblViaKeepoutEnclosure = 0;
@ 844 "adrc/adrc.ev" 2

    }
}
DISCONNECT


/*via 5 / metal 6*/
SET layer_name = "V5/M6";





LOAD_CONNECT_DB all_layer

if (!layer_empty (via5 )) {
    if (!layer_empty (metal6 )) {
        
@ 1 "adrc/adrc_check_diff.ev" 1
/*check spacing*/
if (diff_minSpacing > 0 && diff_netMinSpacing > 0) {
    if (diff_cornerMinSpacing > 0) {
        if (cornerSpacingMode == 1) {
            /* Work around: CONVEX_TO_CONVEX [POINT_PROJECTION] has a bug */
            EXTERNAL via5  metal6  {
                SPACING <= 0
                CONVEX_TO_CONVEX [POINT_PROJECTION] < diff_cornerMinSpacing
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                BOX_CORNER = FALSE
                NODAL = TRUE
            } TEMP = diffNet_corner_err1
            EXTERNAL via5  metal6  {
                SPACING <= 0
                CONVEX_TO_CONVEX < diff_cornerMinSpacing
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                BOX_CORNER = TRUE
                NODAL = TRUE
            } TEMP = diffNet_corner_err2
            BOOLEAN diffNet_corner_err1 OR diffNet_corner_err2 {
                COMMENT = "$layer_name Spacing   : corner to corner spacing = diff_cornerMinSpacing um "
            } (16 )
            EXTERNAL via5  metal6  {
                COMMENT = "$layer_name Spacing   : minimum spacing = diff_netMinSpacing um"
                SPACING < diff_netMinSpacing
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                NON_PARALLEL = TRUE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
                NODAL = TRUE
            } (16 )
        } else {
            EXTERNAL via5  metal6  {
                COMMENT = "$layer_name Spacing  : minimum spacing = diff_netMinSpacing um (corner to corner spacing = diff_cornerMinSpacing um)"
                SPACING < diff_netMinSpacing
                CONVEX_TO_CONVEX < diff_cornerMinSpacing
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                TOUCH = TRUE
                NODAL = TRUE
            } (16 )
        }
    } else {
        EXTERNAL via5  metal6  {
            COMMENT = "$layer_name Spacing  : minimum spacing = diff_netMinSpacing um"
            SPACING < diff_netMinSpacing
            NON_PARALLEL = TRUE
            POINT_TOUCH = TRUE
            TOUCH = TRUE
            NODAL = TRUE
        } (16 )
    }
    if (diff_cornerMinSpacing > 0) {
        if (cornerSpacingMode == 1) {
            /* Work around: CONVEX_TO_CONVEX [POINT_PROJECTION] has a bug */
            EXTERNAL via5  metal6  {
                SPACING <= 0
                CONVEX_TO_CONVEX [POINT_PROJECTION] < diff_cornerMinSpacing
                FLAG_DISCONNECTED = FALSE
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                BOX_CORNER = FALSE
            } TEMP = sameNet_corner_err1
            EXTERNAL via5  metal6  {
                SPACING <= 0
                CONVEX_TO_CONVEX < diff_cornerMinSpacing
                FLAG_DISCONNECTED = FALSE
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                BOX_CORNER = TRUE
            } TEMP = sameNet_corner_err2
            BOOLEAN sameNet_corner_err1 OR sameNet_corner_err2 {
                COMMENT = "$layer_name Spacing   : corner to corner spacing = diff_cornerMinSpacing um "
            } (16 )
            EXTERNAL via5  metal6  {
                COMMENT = "$layer_name Spacing   : minimum spacing = diff_minSpacing um"
                SPACING < diff_minSpacing
                FLAG_DISCONNECTED = FALSE
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                NON_PARALLEL = TRUE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
            } (16 )
        } else {
            EXTERNAL via5  metal6  {
                COMMENT = "$layer_name Spacing  : minimum spacing = diff_minSpacing um (corner to corner spacing = diff_cornerMinSpacing um)"
                SPACING < diff_minSpacing
                CONVEX_TO_CONVEX < diff_cornerMinSpacing
                FLAG_DISCONNECTED = FALSE
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                TOUCH = TRUE
            } (16 )
        }
    } else {
        EXTERNAL via5  metal6  {
            COMMENT = "$layer_name Spacing  : minimum spacing = diff_minSpacing um"
            SPACING < diff_minSpacing
            FLAG_DISCONNECTED = FALSE
            NON_PARALLEL = TRUE
            POINT_TOUCH = TRUE
            TOUCH = TRUE
        } (16 )
    }
} else {
    if (diff_netMinSpacing > 0) {
        if (diff_cornerMinSpacing > 0) {
            if (cornerSpacingMode == 1) {
                /* Work around: CONVEX_TO_CONVEX [POINT_PROJECTION] has a bug */
                EXTERNAL via5  metal6  {
                    SPACING <= 0
                    CONVEX_TO_CONVEX [POINT_PROJECTION] < diff_cornerMinSpacing
                    NON_PARALLEL = TRUE
                    POINT_TOUCH = TRUE
                    BOX_CORNER = FALSE
                    NODAL = TRUE
                } TEMP = corner_err1
                EXTERNAL via5  metal6  {
                    SPACING <= 0
                    CONVEX_TO_CONVEX < diff_cornerMinSpacing
                    NON_PARALLEL = TRUE
                    POINT_TOUCH = TRUE
                    BOX_CORNER = TRUE
                    NODAL = TRUE
                } TEMP = corner_err2
                BOOLEAN corner_err1 OR corner_err2 {
                    COMMENT = "$layer_name Spacing   : corner to corner spacing = diff_cornerMinSpacing um "
                } (16 )
                EXTERNAL via5  metal6  {
                    COMMENT = "$layer_name Spacing   : minimum spacing = diff_netMinSpacing um"
                    SPACING < diff_netMinSpacing
                    SET_CORNERS_TO_SPACING = FALSE
                    PARALLEL_POINT_PROJECTION = FALSE
                    NON_PARALLEL = TRUE
                    TOUCH = FALSE
                    POINT_TOUCH = FALSE
                    NODAL = TRUE
                } (16 )
            } else {
                EXTERNAL via5  metal6  {
                    COMMENT = "$layer_name Spacing  : minimum spacing = diff_netMinSpacing um (corner to corner spacing = diff_cornerMinSpacing um)"
                    SPACING < diff_netMinSpacing
                    CONVEX_TO_CONVEX < diff_cornerMinSpacing
                    NON_PARALLEL = TRUE
                    POINT_TOUCH = TRUE
                    TOUCH = TRUE
                    NODAL = TRUE
                } (16 )
            }
        } else {
            EXTERNAL via5  metal6  {
                COMMENT = "$layer_name Spacing  : minimum spacing = diff_netMinSpacing um"
                SPACING < diff_netMinSpacing
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                TOUCH = TRUE
                NODAL = TRUE
            } (16 )
        }
    } else if (diff_minSpacing > 0) {
        if (diff_cornerMinSpacing > 0) {
            if (cornerSpacingMode == 1) {
                /* Work around: CONVEX_TO_CONVEX [POINT_PROJECTION] has a bug */
                EXTERNAL via5  metal6  {
                    SPACING <= 0
                    CONVEX_TO_CONVEX [POINT_PROJECTION] < diff_cornerMinSpacing
                    NON_PARALLEL = TRUE
                    POINT_TOUCH = TRUE
                    BOX_CORNER = FALSE
                } TEMP = corner_err1
                EXTERNAL via5  metal6  {
                    SPACING <= 0
                    CONVEX_TO_CONVEX < diff_cornerMinSpacing
                    NON_PARALLEL = TRUE
                    POINT_TOUCH = TRUE
                    BOX_CORNER = TRUE
                } TEMP = corner_err2
                BOOLEAN corner_err1 OR corner_err2 {
                    COMMENT = "$layer_name Spacing   : corner to corner spacing = diff_cornerMinSpacing um "
                } (16 )
                EXTERNAL via5  metal6  {
                    COMMENT = "$layer_name Spacing   : minimum spacing = diff_minSpacing um"
                    SPACING < diff_minSpacing
                    SET_CORNERS_TO_SPACING = FALSE
                    PARALLEL_POINT_PROJECTION = FALSE
                    NON_PARALLEL = TRUE
                    TOUCH = FALSE
                    POINT_TOUCH = FALSE
                } (16 )
            } else {
                EXTERNAL via5  metal6  {
                    COMMENT = "$layer_name Spacing  : minimum spacing = diff_minSpacing um (corner to corner spacing = diff_cornerMinSpacing um)"
                    SPACING < diff_minSpacing
                    CONVEX_TO_CONVEX < diff_cornerMinSpacing
                    NON_PARALLEL = TRUE
                    POINT_TOUCH = TRUE
                    TOUCH = TRUE
                } (16 )
            }
        } else {
            EXTERNAL via5  metal6  {
                COMMENT = "$layer_name Spacing  : minimum spacing = diff_minSpacing um"
                SPACING < diff_minSpacing
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                TOUCH = TRUE
            } (16 )
        }
    }
}
 
/*check enclosure*/
if (diff_minEnclosure > 0) {
    ENCLOSE via5  BY metal6  {
        COMMENT = "$layer_name Enclosure: minimum enclosure ( diff_minEnclosure )"
        SPACING < diff_minEnclosure
	NON_PARALLEL = TRUE
	POINT_TOUCH = TRUE
	TOUCH = TRUE
    } (16 )
    BOOLEAN via5  NOT metal6  {
        COMMENT = "$layer_name Enclosure: minimum enclosure ( diff_minEnclosure )"
    } (16 )
}
 
/*check end_of_line enclosure*/
if (diff_endOfLineEnclosure > 0) {
    if (diff_minEnclosure  == 0) {
       BOOLEAN via5  NOT metal6  {
           COMMENT = "$layer_name EndOfLine: end-of-line minimum enclosure ( diff_endOfLineEnclosure )"
       } (16 )
    }
    if (diff_endOfLineMode == 0) {
        ENCLOSE via5  BY metal6  {
	    SPACING < diff_endOfLineEnclosure
	    SET_CORNERS_TO_SPACING = FALSE
	    PARALLEL_POINT_PROJECTION = FALSE
	    SHADOW_OTHER_LAYER = TRUE  
	    TOUCH = TRUE
	    POINT_TOUCH = FALSE
	    NON_PARALLEL = TRUE
            OUTPUT_EDGES = TRUE
        } TEMP = violation
 
        SELECT_EDGE via5  TOUCHING violation {  } TEMP = edges
        SELECT_VECTOR edges { ANGLE_RANGE = [0, 0] } TEMP = h_edges
        SELECT_VECTOR edges { ANGLE_RANGE = [90, 90] } TEMP = v_edges
        SELECT h_edges INTERACT v_edges { POINT_TOUCH = TRUE } TEMP = h_edges
 
        SELECT via5  ENCLOSING h_edges {
            COMMENT = "$layer_name EndOfLine: end-of-line minimum enclosure ( diff_endOfLineEnclosure )"
        } (16 )
    }
    else {
    }
}
 
/*check stackable*/
if (diff_not_stackable > 0) {
     BOOLEAN via5  AND metal6  {
        COMMENT = "$layer_name Stackable: not stackable"
    } (16 )
}
/*check fat metal via keep-out area*/
if (diff_fatTblViaKeepoutThreshold > 0 && diff_fatTblViaKeepoutMinSize > 0 && diff_fatTblViaKeepoutEnclosure > 0) {
    if (diff_fatTblViaKeepoutThreshold > 0) {
        if ((diff_fatTblViaKeepoutThreshold / 2.0) > 0.0005 ) {
           SIZE metal6  { UNDER_OVER = diff_fatTblViaKeepoutThreshold / 2.0 - 0.0005  } TEMP = fat_candidate
           if (diff_fatTblViaKeepoutNextThreshold > 0) {
              SIZE fat_candidate { UNDER_OVER = diff_fatTblViaKeepoutNextThreshold / 2.0 - 0.0005  } TEMP = fat_next
              BOOLEAN fat_candidate NOT fat_next { } TEMP = fat
              BOOLEAN fat AND metal6  { } TEMP = fat
              SET diff_fatTblViaKeepoutNextThreshold = 0;
           } else {
              BOOLEAN fat_candidate AND metal6  {  } TEMP = fat
           }
        } else {
           COPY metal6  { } TEMP = fat
           COPY metal6  { } TEMP = fat_candidate 
        }
    }
    VERTEX fat_candidate {
       CONVEX = TRUE
       SIZE = 0.001 
    } TEMP = fat_corners
    VERTEX fat {
       CONVEX = TRUE
       SIZE = 0.001 
    } TEMP = wire_corners
    SELECT wire_corners INTERACT fat_corners { } TEMP = wire_corners
    SELECT_EDGE fat INTERACT wire_corners { } TEMP = edge_corners
    SELECT_VECTOR edge_corners {
       LENGTH_RANGE = [0, diff_fatTblViaKeepoutMinSize- 0.0005 ]
    } TEMP = edge_tmp1
    BOOLEAN edge_corners NOT edge_tmp1 { } TEMP = edge_tmp2
    SELECT wire_corners OUTSIDE edge_tmp1 {  } TEMP = real_corners
    BOOLEAN edge_tmp2 AND real_corners { } TEMP = real_edge
    SIZE real_edge {
       VSIZE_HEAD = diff_fatTblViaKeepoutMinSize-2* 0.001 
       VSIZE_TAIL = diff_fatTblViaKeepoutMinSize-2* 0.001 
       VSIZE_INSIDE = diff_fatTblViaKeepoutEnclosure- 0.001 
    } TEMP = forb_corners
    SELECT via5  INSIDE fat { } TEMP = v_fat
    /* Work around: need an accurate via_cluster */
    SELECT via_cluster INSIDE fat { } TEMP = v_fat_cluster
    SELECT v_fat INTERACT forb_corners { } TEMP = bad_vias
    BOOLEAN v_fat NOT bad_vias { } TEMP = good_vias
    SELECT v_fat_cluster OUTSIDE good_vias { } TEMP = bad_v_fat_cluster
    SELECT v_fat INTERACT bad_v_fat_cluster {
       COMMENT = "$layer_name ViaKepOut: fat metal ( diff_fatTblViaKeepoutThreshold um) contact keep-out area ( diff_fatTblViaKeepoutMinSize um, diff_fatTblViaKeepoutEnclosure um) "
    } (16 )
}
 
/* reset variables */



 
SET diff_minSpacing = 0;
SET diff_netMinSpacing = 0;
SET diff_cornerMinSpacing = 0;
SET diff_minEnclosure = 0;
SET diff_endOfLineEnclosure = 0;
SET diff_not_stackable = 0;
SET diff_fatTblViaKeepoutThreshold = 0;
SET diff_fatTblViaKeepoutNextThreshold = 0;
SET diff_fatTblViaKeepoutMinSize = 0;
SET diff_fatTblViaKeepoutEnclosure = 0;
@ 861 "adrc/adrc.ev" 2

    }
}
DISCONNECT


/*via 6 / metal 7*/
SET layer_name = "V6/M7";





LOAD_CONNECT_DB all_layer

if (!layer_empty (via6 )) {
    if (!layer_empty (metal7 )) {
        
@ 1 "adrc/adrc_check_diff.ev" 1
/*check spacing*/
if (diff_minSpacing > 0 && diff_netMinSpacing > 0) {
    if (diff_cornerMinSpacing > 0) {
        if (cornerSpacingMode == 1) {
            /* Work around: CONVEX_TO_CONVEX [POINT_PROJECTION] has a bug */
            EXTERNAL via6  metal7  {
                SPACING <= 0
                CONVEX_TO_CONVEX [POINT_PROJECTION] < diff_cornerMinSpacing
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                BOX_CORNER = FALSE
                NODAL = TRUE
            } TEMP = diffNet_corner_err1
            EXTERNAL via6  metal7  {
                SPACING <= 0
                CONVEX_TO_CONVEX < diff_cornerMinSpacing
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                BOX_CORNER = TRUE
                NODAL = TRUE
            } TEMP = diffNet_corner_err2
            BOOLEAN diffNet_corner_err1 OR diffNet_corner_err2 {
                COMMENT = "$layer_name Spacing   : corner to corner spacing = diff_cornerMinSpacing um "
            } (17 )
            EXTERNAL via6  metal7  {
                COMMENT = "$layer_name Spacing   : minimum spacing = diff_netMinSpacing um"
                SPACING < diff_netMinSpacing
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                NON_PARALLEL = TRUE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
                NODAL = TRUE
            } (17 )
        } else {
            EXTERNAL via6  metal7  {
                COMMENT = "$layer_name Spacing  : minimum spacing = diff_netMinSpacing um (corner to corner spacing = diff_cornerMinSpacing um)"
                SPACING < diff_netMinSpacing
                CONVEX_TO_CONVEX < diff_cornerMinSpacing
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                TOUCH = TRUE
                NODAL = TRUE
            } (17 )
        }
    } else {
        EXTERNAL via6  metal7  {
            COMMENT = "$layer_name Spacing  : minimum spacing = diff_netMinSpacing um"
            SPACING < diff_netMinSpacing
            NON_PARALLEL = TRUE
            POINT_TOUCH = TRUE
            TOUCH = TRUE
            NODAL = TRUE
        } (17 )
    }
    if (diff_cornerMinSpacing > 0) {
        if (cornerSpacingMode == 1) {
            /* Work around: CONVEX_TO_CONVEX [POINT_PROJECTION] has a bug */
            EXTERNAL via6  metal7  {
                SPACING <= 0
                CONVEX_TO_CONVEX [POINT_PROJECTION] < diff_cornerMinSpacing
                FLAG_DISCONNECTED = FALSE
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                BOX_CORNER = FALSE
            } TEMP = sameNet_corner_err1
            EXTERNAL via6  metal7  {
                SPACING <= 0
                CONVEX_TO_CONVEX < diff_cornerMinSpacing
                FLAG_DISCONNECTED = FALSE
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                BOX_CORNER = TRUE
            } TEMP = sameNet_corner_err2
            BOOLEAN sameNet_corner_err1 OR sameNet_corner_err2 {
                COMMENT = "$layer_name Spacing   : corner to corner spacing = diff_cornerMinSpacing um "
            } (17 )
            EXTERNAL via6  metal7  {
                COMMENT = "$layer_name Spacing   : minimum spacing = diff_minSpacing um"
                SPACING < diff_minSpacing
                FLAG_DISCONNECTED = FALSE
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                NON_PARALLEL = TRUE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
            } (17 )
        } else {
            EXTERNAL via6  metal7  {
                COMMENT = "$layer_name Spacing  : minimum spacing = diff_minSpacing um (corner to corner spacing = diff_cornerMinSpacing um)"
                SPACING < diff_minSpacing
                CONVEX_TO_CONVEX < diff_cornerMinSpacing
                FLAG_DISCONNECTED = FALSE
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                TOUCH = TRUE
            } (17 )
        }
    } else {
        EXTERNAL via6  metal7  {
            COMMENT = "$layer_name Spacing  : minimum spacing = diff_minSpacing um"
            SPACING < diff_minSpacing
            FLAG_DISCONNECTED = FALSE
            NON_PARALLEL = TRUE
            POINT_TOUCH = TRUE
            TOUCH = TRUE
        } (17 )
    }
} else {
    if (diff_netMinSpacing > 0) {
        if (diff_cornerMinSpacing > 0) {
            if (cornerSpacingMode == 1) {
                /* Work around: CONVEX_TO_CONVEX [POINT_PROJECTION] has a bug */
                EXTERNAL via6  metal7  {
                    SPACING <= 0
                    CONVEX_TO_CONVEX [POINT_PROJECTION] < diff_cornerMinSpacing
                    NON_PARALLEL = TRUE
                    POINT_TOUCH = TRUE
                    BOX_CORNER = FALSE
                    NODAL = TRUE
                } TEMP = corner_err1
                EXTERNAL via6  metal7  {
                    SPACING <= 0
                    CONVEX_TO_CONVEX < diff_cornerMinSpacing
                    NON_PARALLEL = TRUE
                    POINT_TOUCH = TRUE
                    BOX_CORNER = TRUE
                    NODAL = TRUE
                } TEMP = corner_err2
                BOOLEAN corner_err1 OR corner_err2 {
                    COMMENT = "$layer_name Spacing   : corner to corner spacing = diff_cornerMinSpacing um "
                } (17 )
                EXTERNAL via6  metal7  {
                    COMMENT = "$layer_name Spacing   : minimum spacing = diff_netMinSpacing um"
                    SPACING < diff_netMinSpacing
                    SET_CORNERS_TO_SPACING = FALSE
                    PARALLEL_POINT_PROJECTION = FALSE
                    NON_PARALLEL = TRUE
                    TOUCH = FALSE
                    POINT_TOUCH = FALSE
                    NODAL = TRUE
                } (17 )
            } else {
                EXTERNAL via6  metal7  {
                    COMMENT = "$layer_name Spacing  : minimum spacing = diff_netMinSpacing um (corner to corner spacing = diff_cornerMinSpacing um)"
                    SPACING < diff_netMinSpacing
                    CONVEX_TO_CONVEX < diff_cornerMinSpacing
                    NON_PARALLEL = TRUE
                    POINT_TOUCH = TRUE
                    TOUCH = TRUE
                    NODAL = TRUE
                } (17 )
            }
        } else {
            EXTERNAL via6  metal7  {
                COMMENT = "$layer_name Spacing  : minimum spacing = diff_netMinSpacing um"
                SPACING < diff_netMinSpacing
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                TOUCH = TRUE
                NODAL = TRUE
            } (17 )
        }
    } else if (diff_minSpacing > 0) {
        if (diff_cornerMinSpacing > 0) {
            if (cornerSpacingMode == 1) {
                /* Work around: CONVEX_TO_CONVEX [POINT_PROJECTION] has a bug */
                EXTERNAL via6  metal7  {
                    SPACING <= 0
                    CONVEX_TO_CONVEX [POINT_PROJECTION] < diff_cornerMinSpacing
                    NON_PARALLEL = TRUE
                    POINT_TOUCH = TRUE
                    BOX_CORNER = FALSE
                } TEMP = corner_err1
                EXTERNAL via6  metal7  {
                    SPACING <= 0
                    CONVEX_TO_CONVEX < diff_cornerMinSpacing
                    NON_PARALLEL = TRUE
                    POINT_TOUCH = TRUE
                    BOX_CORNER = TRUE
                } TEMP = corner_err2
                BOOLEAN corner_err1 OR corner_err2 {
                    COMMENT = "$layer_name Spacing   : corner to corner spacing = diff_cornerMinSpacing um "
                } (17 )
                EXTERNAL via6  metal7  {
                    COMMENT = "$layer_name Spacing   : minimum spacing = diff_minSpacing um"
                    SPACING < diff_minSpacing
                    SET_CORNERS_TO_SPACING = FALSE
                    PARALLEL_POINT_PROJECTION = FALSE
                    NON_PARALLEL = TRUE
                    TOUCH = FALSE
                    POINT_TOUCH = FALSE
                } (17 )
            } else {
                EXTERNAL via6  metal7  {
                    COMMENT = "$layer_name Spacing  : minimum spacing = diff_minSpacing um (corner to corner spacing = diff_cornerMinSpacing um)"
                    SPACING < diff_minSpacing
                    CONVEX_TO_CONVEX < diff_cornerMinSpacing
                    NON_PARALLEL = TRUE
                    POINT_TOUCH = TRUE
                    TOUCH = TRUE
                } (17 )
            }
        } else {
            EXTERNAL via6  metal7  {
                COMMENT = "$layer_name Spacing  : minimum spacing = diff_minSpacing um"
                SPACING < diff_minSpacing
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                TOUCH = TRUE
            } (17 )
        }
    }
}
 
/*check enclosure*/
if (diff_minEnclosure > 0) {
    ENCLOSE via6  BY metal7  {
        COMMENT = "$layer_name Enclosure: minimum enclosure ( diff_minEnclosure )"
        SPACING < diff_minEnclosure
	NON_PARALLEL = TRUE
	POINT_TOUCH = TRUE
	TOUCH = TRUE
    } (17 )
    BOOLEAN via6  NOT metal7  {
        COMMENT = "$layer_name Enclosure: minimum enclosure ( diff_minEnclosure )"
    } (17 )
}
 
/*check end_of_line enclosure*/
if (diff_endOfLineEnclosure > 0) {
    if (diff_minEnclosure  == 0) {
       BOOLEAN via6  NOT metal7  {
           COMMENT = "$layer_name EndOfLine: end-of-line minimum enclosure ( diff_endOfLineEnclosure )"
       } (17 )
    }
    if (diff_endOfLineMode == 0) {
        ENCLOSE via6  BY metal7  {
	    SPACING < diff_endOfLineEnclosure
	    SET_CORNERS_TO_SPACING = FALSE
	    PARALLEL_POINT_PROJECTION = FALSE
	    SHADOW_OTHER_LAYER = TRUE  
	    TOUCH = TRUE
	    POINT_TOUCH = FALSE
	    NON_PARALLEL = TRUE
            OUTPUT_EDGES = TRUE
        } TEMP = violation
 
        SELECT_EDGE via6  TOUCHING violation {  } TEMP = edges
        SELECT_VECTOR edges { ANGLE_RANGE = [0, 0] } TEMP = h_edges
        SELECT_VECTOR edges { ANGLE_RANGE = [90, 90] } TEMP = v_edges
        SELECT h_edges INTERACT v_edges { POINT_TOUCH = TRUE } TEMP = h_edges
 
        SELECT via6  ENCLOSING h_edges {
            COMMENT = "$layer_name EndOfLine: end-of-line minimum enclosure ( diff_endOfLineEnclosure )"
        } (17 )
    }
    else {
    }
}
 
/*check stackable*/
if (diff_not_stackable > 0) {
     BOOLEAN via6  AND metal7  {
        COMMENT = "$layer_name Stackable: not stackable"
    } (17 )
}
/*check fat metal via keep-out area*/
if (diff_fatTblViaKeepoutThreshold > 0 && diff_fatTblViaKeepoutMinSize > 0 && diff_fatTblViaKeepoutEnclosure > 0) {
    if (diff_fatTblViaKeepoutThreshold > 0) {
        if ((diff_fatTblViaKeepoutThreshold / 2.0) > 0.0005 ) {
           SIZE metal7  { UNDER_OVER = diff_fatTblViaKeepoutThreshold / 2.0 - 0.0005  } TEMP = fat_candidate
           if (diff_fatTblViaKeepoutNextThreshold > 0) {
              SIZE fat_candidate { UNDER_OVER = diff_fatTblViaKeepoutNextThreshold / 2.0 - 0.0005  } TEMP = fat_next
              BOOLEAN fat_candidate NOT fat_next { } TEMP = fat
              BOOLEAN fat AND metal7  { } TEMP = fat
              SET diff_fatTblViaKeepoutNextThreshold = 0;
           } else {
              BOOLEAN fat_candidate AND metal7  {  } TEMP = fat
           }
        } else {
           COPY metal7  { } TEMP = fat
           COPY metal7  { } TEMP = fat_candidate 
        }
    }
    VERTEX fat_candidate {
       CONVEX = TRUE
       SIZE = 0.001 
    } TEMP = fat_corners
    VERTEX fat {
       CONVEX = TRUE
       SIZE = 0.001 
    } TEMP = wire_corners
    SELECT wire_corners INTERACT fat_corners { } TEMP = wire_corners
    SELECT_EDGE fat INTERACT wire_corners { } TEMP = edge_corners
    SELECT_VECTOR edge_corners {
       LENGTH_RANGE = [0, diff_fatTblViaKeepoutMinSize- 0.0005 ]
    } TEMP = edge_tmp1
    BOOLEAN edge_corners NOT edge_tmp1 { } TEMP = edge_tmp2
    SELECT wire_corners OUTSIDE edge_tmp1 {  } TEMP = real_corners
    BOOLEAN edge_tmp2 AND real_corners { } TEMP = real_edge
    SIZE real_edge {
       VSIZE_HEAD = diff_fatTblViaKeepoutMinSize-2* 0.001 
       VSIZE_TAIL = diff_fatTblViaKeepoutMinSize-2* 0.001 
       VSIZE_INSIDE = diff_fatTblViaKeepoutEnclosure- 0.001 
    } TEMP = forb_corners
    SELECT via6  INSIDE fat { } TEMP = v_fat
    /* Work around: need an accurate via_cluster */
    SELECT via_cluster INSIDE fat { } TEMP = v_fat_cluster
    SELECT v_fat INTERACT forb_corners { } TEMP = bad_vias
    BOOLEAN v_fat NOT bad_vias { } TEMP = good_vias
    SELECT v_fat_cluster OUTSIDE good_vias { } TEMP = bad_v_fat_cluster
    SELECT v_fat INTERACT bad_v_fat_cluster {
       COMMENT = "$layer_name ViaKepOut: fat metal ( diff_fatTblViaKeepoutThreshold um) contact keep-out area ( diff_fatTblViaKeepoutMinSize um, diff_fatTblViaKeepoutEnclosure um) "
    } (17 )
}
 
/* reset variables */



 
SET diff_minSpacing = 0;
SET diff_netMinSpacing = 0;
SET diff_cornerMinSpacing = 0;
SET diff_minEnclosure = 0;
SET diff_endOfLineEnclosure = 0;
SET diff_not_stackable = 0;
SET diff_fatTblViaKeepoutThreshold = 0;
SET diff_fatTblViaKeepoutNextThreshold = 0;
SET diff_fatTblViaKeepoutMinSize = 0;
SET diff_fatTblViaKeepoutEnclosure = 0;
@ 878 "adrc/adrc.ev" 2

    }
}
DISCONNECT


/*via 7 / metal 8*/
SET layer_name = "V7/M8";





LOAD_CONNECT_DB all_layer

if (!layer_empty (via7 )) {
    if (!layer_empty (metal8 )) {
        
@ 1 "adrc/adrc_check_diff.ev" 1
/*check spacing*/
if (diff_minSpacing > 0 && diff_netMinSpacing > 0) {
    if (diff_cornerMinSpacing > 0) {
        if (cornerSpacingMode == 1) {
            /* Work around: CONVEX_TO_CONVEX [POINT_PROJECTION] has a bug */
            EXTERNAL via7  metal8  {
                SPACING <= 0
                CONVEX_TO_CONVEX [POINT_PROJECTION] < diff_cornerMinSpacing
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                BOX_CORNER = FALSE
                NODAL = TRUE
            } TEMP = diffNet_corner_err1
            EXTERNAL via7  metal8  {
                SPACING <= 0
                CONVEX_TO_CONVEX < diff_cornerMinSpacing
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                BOX_CORNER = TRUE
                NODAL = TRUE
            } TEMP = diffNet_corner_err2
            BOOLEAN diffNet_corner_err1 OR diffNet_corner_err2 {
                COMMENT = "$layer_name Spacing   : corner to corner spacing = diff_cornerMinSpacing um "
            } (18 )
            EXTERNAL via7  metal8  {
                COMMENT = "$layer_name Spacing   : minimum spacing = diff_netMinSpacing um"
                SPACING < diff_netMinSpacing
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                NON_PARALLEL = TRUE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
                NODAL = TRUE
            } (18 )
        } else {
            EXTERNAL via7  metal8  {
                COMMENT = "$layer_name Spacing  : minimum spacing = diff_netMinSpacing um (corner to corner spacing = diff_cornerMinSpacing um)"
                SPACING < diff_netMinSpacing
                CONVEX_TO_CONVEX < diff_cornerMinSpacing
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                TOUCH = TRUE
                NODAL = TRUE
            } (18 )
        }
    } else {
        EXTERNAL via7  metal8  {
            COMMENT = "$layer_name Spacing  : minimum spacing = diff_netMinSpacing um"
            SPACING < diff_netMinSpacing
            NON_PARALLEL = TRUE
            POINT_TOUCH = TRUE
            TOUCH = TRUE
            NODAL = TRUE
        } (18 )
    }
    if (diff_cornerMinSpacing > 0) {
        if (cornerSpacingMode == 1) {
            /* Work around: CONVEX_TO_CONVEX [POINT_PROJECTION] has a bug */
            EXTERNAL via7  metal8  {
                SPACING <= 0
                CONVEX_TO_CONVEX [POINT_PROJECTION] < diff_cornerMinSpacing
                FLAG_DISCONNECTED = FALSE
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                BOX_CORNER = FALSE
            } TEMP = sameNet_corner_err1
            EXTERNAL via7  metal8  {
                SPACING <= 0
                CONVEX_TO_CONVEX < diff_cornerMinSpacing
                FLAG_DISCONNECTED = FALSE
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                BOX_CORNER = TRUE
            } TEMP = sameNet_corner_err2
            BOOLEAN sameNet_corner_err1 OR sameNet_corner_err2 {
                COMMENT = "$layer_name Spacing   : corner to corner spacing = diff_cornerMinSpacing um "
            } (18 )
            EXTERNAL via7  metal8  {
                COMMENT = "$layer_name Spacing   : minimum spacing = diff_minSpacing um"
                SPACING < diff_minSpacing
                FLAG_DISCONNECTED = FALSE
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                NON_PARALLEL = TRUE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
            } (18 )
        } else {
            EXTERNAL via7  metal8  {
                COMMENT = "$layer_name Spacing  : minimum spacing = diff_minSpacing um (corner to corner spacing = diff_cornerMinSpacing um)"
                SPACING < diff_minSpacing
                CONVEX_TO_CONVEX < diff_cornerMinSpacing
                FLAG_DISCONNECTED = FALSE
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                TOUCH = TRUE
            } (18 )
        }
    } else {
        EXTERNAL via7  metal8  {
            COMMENT = "$layer_name Spacing  : minimum spacing = diff_minSpacing um"
            SPACING < diff_minSpacing
            FLAG_DISCONNECTED = FALSE
            NON_PARALLEL = TRUE
            POINT_TOUCH = TRUE
            TOUCH = TRUE
        } (18 )
    }
} else {
    if (diff_netMinSpacing > 0) {
        if (diff_cornerMinSpacing > 0) {
            if (cornerSpacingMode == 1) {
                /* Work around: CONVEX_TO_CONVEX [POINT_PROJECTION] has a bug */
                EXTERNAL via7  metal8  {
                    SPACING <= 0
                    CONVEX_TO_CONVEX [POINT_PROJECTION] < diff_cornerMinSpacing
                    NON_PARALLEL = TRUE
                    POINT_TOUCH = TRUE
                    BOX_CORNER = FALSE
                    NODAL = TRUE
                } TEMP = corner_err1
                EXTERNAL via7  metal8  {
                    SPACING <= 0
                    CONVEX_TO_CONVEX < diff_cornerMinSpacing
                    NON_PARALLEL = TRUE
                    POINT_TOUCH = TRUE
                    BOX_CORNER = TRUE
                    NODAL = TRUE
                } TEMP = corner_err2
                BOOLEAN corner_err1 OR corner_err2 {
                    COMMENT = "$layer_name Spacing   : corner to corner spacing = diff_cornerMinSpacing um "
                } (18 )
                EXTERNAL via7  metal8  {
                    COMMENT = "$layer_name Spacing   : minimum spacing = diff_netMinSpacing um"
                    SPACING < diff_netMinSpacing
                    SET_CORNERS_TO_SPACING = FALSE
                    PARALLEL_POINT_PROJECTION = FALSE
                    NON_PARALLEL = TRUE
                    TOUCH = FALSE
                    POINT_TOUCH = FALSE
                    NODAL = TRUE
                } (18 )
            } else {
                EXTERNAL via7  metal8  {
                    COMMENT = "$layer_name Spacing  : minimum spacing = diff_netMinSpacing um (corner to corner spacing = diff_cornerMinSpacing um)"
                    SPACING < diff_netMinSpacing
                    CONVEX_TO_CONVEX < diff_cornerMinSpacing
                    NON_PARALLEL = TRUE
                    POINT_TOUCH = TRUE
                    TOUCH = TRUE
                    NODAL = TRUE
                } (18 )
            }
        } else {
            EXTERNAL via7  metal8  {
                COMMENT = "$layer_name Spacing  : minimum spacing = diff_netMinSpacing um"
                SPACING < diff_netMinSpacing
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                TOUCH = TRUE
                NODAL = TRUE
            } (18 )
        }
    } else if (diff_minSpacing > 0) {
        if (diff_cornerMinSpacing > 0) {
            if (cornerSpacingMode == 1) {
                /* Work around: CONVEX_TO_CONVEX [POINT_PROJECTION] has a bug */
                EXTERNAL via7  metal8  {
                    SPACING <= 0
                    CONVEX_TO_CONVEX [POINT_PROJECTION] < diff_cornerMinSpacing
                    NON_PARALLEL = TRUE
                    POINT_TOUCH = TRUE
                    BOX_CORNER = FALSE
                } TEMP = corner_err1
                EXTERNAL via7  metal8  {
                    SPACING <= 0
                    CONVEX_TO_CONVEX < diff_cornerMinSpacing
                    NON_PARALLEL = TRUE
                    POINT_TOUCH = TRUE
                    BOX_CORNER = TRUE
                } TEMP = corner_err2
                BOOLEAN corner_err1 OR corner_err2 {
                    COMMENT = "$layer_name Spacing   : corner to corner spacing = diff_cornerMinSpacing um "
                } (18 )
                EXTERNAL via7  metal8  {
                    COMMENT = "$layer_name Spacing   : minimum spacing = diff_minSpacing um"
                    SPACING < diff_minSpacing
                    SET_CORNERS_TO_SPACING = FALSE
                    PARALLEL_POINT_PROJECTION = FALSE
                    NON_PARALLEL = TRUE
                    TOUCH = FALSE
                    POINT_TOUCH = FALSE
                } (18 )
            } else {
                EXTERNAL via7  metal8  {
                    COMMENT = "$layer_name Spacing  : minimum spacing = diff_minSpacing um (corner to corner spacing = diff_cornerMinSpacing um)"
                    SPACING < diff_minSpacing
                    CONVEX_TO_CONVEX < diff_cornerMinSpacing
                    NON_PARALLEL = TRUE
                    POINT_TOUCH = TRUE
                    TOUCH = TRUE
                } (18 )
            }
        } else {
            EXTERNAL via7  metal8  {
                COMMENT = "$layer_name Spacing  : minimum spacing = diff_minSpacing um"
                SPACING < diff_minSpacing
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                TOUCH = TRUE
            } (18 )
        }
    }
}
 
/*check enclosure*/
if (diff_minEnclosure > 0) {
    ENCLOSE via7  BY metal8  {
        COMMENT = "$layer_name Enclosure: minimum enclosure ( diff_minEnclosure )"
        SPACING < diff_minEnclosure
	NON_PARALLEL = TRUE
	POINT_TOUCH = TRUE
	TOUCH = TRUE
    } (18 )
    BOOLEAN via7  NOT metal8  {
        COMMENT = "$layer_name Enclosure: minimum enclosure ( diff_minEnclosure )"
    } (18 )
}
 
/*check end_of_line enclosure*/
if (diff_endOfLineEnclosure > 0) {
    if (diff_minEnclosure  == 0) {
       BOOLEAN via7  NOT metal8  {
           COMMENT = "$layer_name EndOfLine: end-of-line minimum enclosure ( diff_endOfLineEnclosure )"
       } (18 )
    }
    if (diff_endOfLineMode == 0) {
        ENCLOSE via7  BY metal8  {
	    SPACING < diff_endOfLineEnclosure
	    SET_CORNERS_TO_SPACING = FALSE
	    PARALLEL_POINT_PROJECTION = FALSE
	    SHADOW_OTHER_LAYER = TRUE  
	    TOUCH = TRUE
	    POINT_TOUCH = FALSE
	    NON_PARALLEL = TRUE
            OUTPUT_EDGES = TRUE
        } TEMP = violation
 
        SELECT_EDGE via7  TOUCHING violation {  } TEMP = edges
        SELECT_VECTOR edges { ANGLE_RANGE = [0, 0] } TEMP = h_edges
        SELECT_VECTOR edges { ANGLE_RANGE = [90, 90] } TEMP = v_edges
        SELECT h_edges INTERACT v_edges { POINT_TOUCH = TRUE } TEMP = h_edges
 
        SELECT via7  ENCLOSING h_edges {
            COMMENT = "$layer_name EndOfLine: end-of-line minimum enclosure ( diff_endOfLineEnclosure )"
        } (18 )
    }
    else {
    }
}
 
/*check stackable*/
if (diff_not_stackable > 0) {
     BOOLEAN via7  AND metal8  {
        COMMENT = "$layer_name Stackable: not stackable"
    } (18 )
}
/*check fat metal via keep-out area*/
if (diff_fatTblViaKeepoutThreshold > 0 && diff_fatTblViaKeepoutMinSize > 0 && diff_fatTblViaKeepoutEnclosure > 0) {
    if (diff_fatTblViaKeepoutThreshold > 0) {
        if ((diff_fatTblViaKeepoutThreshold / 2.0) > 0.0005 ) {
           SIZE metal8  { UNDER_OVER = diff_fatTblViaKeepoutThreshold / 2.0 - 0.0005  } TEMP = fat_candidate
           if (diff_fatTblViaKeepoutNextThreshold > 0) {
              SIZE fat_candidate { UNDER_OVER = diff_fatTblViaKeepoutNextThreshold / 2.0 - 0.0005  } TEMP = fat_next
              BOOLEAN fat_candidate NOT fat_next { } TEMP = fat
              BOOLEAN fat AND metal8  { } TEMP = fat
              SET diff_fatTblViaKeepoutNextThreshold = 0;
           } else {
              BOOLEAN fat_candidate AND metal8  {  } TEMP = fat
           }
        } else {
           COPY metal8  { } TEMP = fat
           COPY metal8  { } TEMP = fat_candidate 
        }
    }
    VERTEX fat_candidate {
       CONVEX = TRUE
       SIZE = 0.001 
    } TEMP = fat_corners
    VERTEX fat {
       CONVEX = TRUE
       SIZE = 0.001 
    } TEMP = wire_corners
    SELECT wire_corners INTERACT fat_corners { } TEMP = wire_corners
    SELECT_EDGE fat INTERACT wire_corners { } TEMP = edge_corners
    SELECT_VECTOR edge_corners {
       LENGTH_RANGE = [0, diff_fatTblViaKeepoutMinSize- 0.0005 ]
    } TEMP = edge_tmp1
    BOOLEAN edge_corners NOT edge_tmp1 { } TEMP = edge_tmp2
    SELECT wire_corners OUTSIDE edge_tmp1 {  } TEMP = real_corners
    BOOLEAN edge_tmp2 AND real_corners { } TEMP = real_edge
    SIZE real_edge {
       VSIZE_HEAD = diff_fatTblViaKeepoutMinSize-2* 0.001 
       VSIZE_TAIL = diff_fatTblViaKeepoutMinSize-2* 0.001 
       VSIZE_INSIDE = diff_fatTblViaKeepoutEnclosure- 0.001 
    } TEMP = forb_corners
    SELECT via7  INSIDE fat { } TEMP = v_fat
    /* Work around: need an accurate via_cluster */
    SELECT via_cluster INSIDE fat { } TEMP = v_fat_cluster
    SELECT v_fat INTERACT forb_corners { } TEMP = bad_vias
    BOOLEAN v_fat NOT bad_vias { } TEMP = good_vias
    SELECT v_fat_cluster OUTSIDE good_vias { } TEMP = bad_v_fat_cluster
    SELECT v_fat INTERACT bad_v_fat_cluster {
       COMMENT = "$layer_name ViaKepOut: fat metal ( diff_fatTblViaKeepoutThreshold um) contact keep-out area ( diff_fatTblViaKeepoutMinSize um, diff_fatTblViaKeepoutEnclosure um) "
    } (18 )
}
 
/* reset variables */



 
SET diff_minSpacing = 0;
SET diff_netMinSpacing = 0;
SET diff_cornerMinSpacing = 0;
SET diff_minEnclosure = 0;
SET diff_endOfLineEnclosure = 0;
SET diff_not_stackable = 0;
SET diff_fatTblViaKeepoutThreshold = 0;
SET diff_fatTblViaKeepoutNextThreshold = 0;
SET diff_fatTblViaKeepoutMinSize = 0;
SET diff_fatTblViaKeepoutEnclosure = 0;
@ 895 "adrc/adrc.ev" 2

    }
}
DISCONNECT


/*via 8 / metal 9*/
SET layer_name = "V8/M9";





LOAD_CONNECT_DB all_layer

if (!layer_empty (via8 )) {
    if (!layer_empty (metal9 )) {
        
@ 1 "adrc/adrc_check_diff.ev" 1
/*check spacing*/
if (diff_minSpacing > 0 && diff_netMinSpacing > 0) {
    if (diff_cornerMinSpacing > 0) {
        if (cornerSpacingMode == 1) {
            /* Work around: CONVEX_TO_CONVEX [POINT_PROJECTION] has a bug */
            EXTERNAL via8  metal9  {
                SPACING <= 0
                CONVEX_TO_CONVEX [POINT_PROJECTION] < diff_cornerMinSpacing
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                BOX_CORNER = FALSE
                NODAL = TRUE
            } TEMP = diffNet_corner_err1
            EXTERNAL via8  metal9  {
                SPACING <= 0
                CONVEX_TO_CONVEX < diff_cornerMinSpacing
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                BOX_CORNER = TRUE
                NODAL = TRUE
            } TEMP = diffNet_corner_err2
            BOOLEAN diffNet_corner_err1 OR diffNet_corner_err2 {
                COMMENT = "$layer_name Spacing   : corner to corner spacing = diff_cornerMinSpacing um "
            } (19 )
            EXTERNAL via8  metal9  {
                COMMENT = "$layer_name Spacing   : minimum spacing = diff_netMinSpacing um"
                SPACING < diff_netMinSpacing
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                NON_PARALLEL = TRUE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
                NODAL = TRUE
            } (19 )
        } else {
            EXTERNAL via8  metal9  {
                COMMENT = "$layer_name Spacing  : minimum spacing = diff_netMinSpacing um (corner to corner spacing = diff_cornerMinSpacing um)"
                SPACING < diff_netMinSpacing
                CONVEX_TO_CONVEX < diff_cornerMinSpacing
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                TOUCH = TRUE
                NODAL = TRUE
            } (19 )
        }
    } else {
        EXTERNAL via8  metal9  {
            COMMENT = "$layer_name Spacing  : minimum spacing = diff_netMinSpacing um"
            SPACING < diff_netMinSpacing
            NON_PARALLEL = TRUE
            POINT_TOUCH = TRUE
            TOUCH = TRUE
            NODAL = TRUE
        } (19 )
    }
    if (diff_cornerMinSpacing > 0) {
        if (cornerSpacingMode == 1) {
            /* Work around: CONVEX_TO_CONVEX [POINT_PROJECTION] has a bug */
            EXTERNAL via8  metal9  {
                SPACING <= 0
                CONVEX_TO_CONVEX [POINT_PROJECTION] < diff_cornerMinSpacing
                FLAG_DISCONNECTED = FALSE
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                BOX_CORNER = FALSE
            } TEMP = sameNet_corner_err1
            EXTERNAL via8  metal9  {
                SPACING <= 0
                CONVEX_TO_CONVEX < diff_cornerMinSpacing
                FLAG_DISCONNECTED = FALSE
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                BOX_CORNER = TRUE
            } TEMP = sameNet_corner_err2
            BOOLEAN sameNet_corner_err1 OR sameNet_corner_err2 {
                COMMENT = "$layer_name Spacing   : corner to corner spacing = diff_cornerMinSpacing um "
            } (19 )
            EXTERNAL via8  metal9  {
                COMMENT = "$layer_name Spacing   : minimum spacing = diff_minSpacing um"
                SPACING < diff_minSpacing
                FLAG_DISCONNECTED = FALSE
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                NON_PARALLEL = TRUE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
            } (19 )
        } else {
            EXTERNAL via8  metal9  {
                COMMENT = "$layer_name Spacing  : minimum spacing = diff_minSpacing um (corner to corner spacing = diff_cornerMinSpacing um)"
                SPACING < diff_minSpacing
                CONVEX_TO_CONVEX < diff_cornerMinSpacing
                FLAG_DISCONNECTED = FALSE
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                TOUCH = TRUE
            } (19 )
        }
    } else {
        EXTERNAL via8  metal9  {
            COMMENT = "$layer_name Spacing  : minimum spacing = diff_minSpacing um"
            SPACING < diff_minSpacing
            FLAG_DISCONNECTED = FALSE
            NON_PARALLEL = TRUE
            POINT_TOUCH = TRUE
            TOUCH = TRUE
        } (19 )
    }
} else {
    if (diff_netMinSpacing > 0) {
        if (diff_cornerMinSpacing > 0) {
            if (cornerSpacingMode == 1) {
                /* Work around: CONVEX_TO_CONVEX [POINT_PROJECTION] has a bug */
                EXTERNAL via8  metal9  {
                    SPACING <= 0
                    CONVEX_TO_CONVEX [POINT_PROJECTION] < diff_cornerMinSpacing
                    NON_PARALLEL = TRUE
                    POINT_TOUCH = TRUE
                    BOX_CORNER = FALSE
                    NODAL = TRUE
                } TEMP = corner_err1
                EXTERNAL via8  metal9  {
                    SPACING <= 0
                    CONVEX_TO_CONVEX < diff_cornerMinSpacing
                    NON_PARALLEL = TRUE
                    POINT_TOUCH = TRUE
                    BOX_CORNER = TRUE
                    NODAL = TRUE
                } TEMP = corner_err2
                BOOLEAN corner_err1 OR corner_err2 {
                    COMMENT = "$layer_name Spacing   : corner to corner spacing = diff_cornerMinSpacing um "
                } (19 )
                EXTERNAL via8  metal9  {
                    COMMENT = "$layer_name Spacing   : minimum spacing = diff_netMinSpacing um"
                    SPACING < diff_netMinSpacing
                    SET_CORNERS_TO_SPACING = FALSE
                    PARALLEL_POINT_PROJECTION = FALSE
                    NON_PARALLEL = TRUE
                    TOUCH = FALSE
                    POINT_TOUCH = FALSE
                    NODAL = TRUE
                } (19 )
            } else {
                EXTERNAL via8  metal9  {
                    COMMENT = "$layer_name Spacing  : minimum spacing = diff_netMinSpacing um (corner to corner spacing = diff_cornerMinSpacing um)"
                    SPACING < diff_netMinSpacing
                    CONVEX_TO_CONVEX < diff_cornerMinSpacing
                    NON_PARALLEL = TRUE
                    POINT_TOUCH = TRUE
                    TOUCH = TRUE
                    NODAL = TRUE
                } (19 )
            }
        } else {
            EXTERNAL via8  metal9  {
                COMMENT = "$layer_name Spacing  : minimum spacing = diff_netMinSpacing um"
                SPACING < diff_netMinSpacing
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                TOUCH = TRUE
                NODAL = TRUE
            } (19 )
        }
    } else if (diff_minSpacing > 0) {
        if (diff_cornerMinSpacing > 0) {
            if (cornerSpacingMode == 1) {
                /* Work around: CONVEX_TO_CONVEX [POINT_PROJECTION] has a bug */
                EXTERNAL via8  metal9  {
                    SPACING <= 0
                    CONVEX_TO_CONVEX [POINT_PROJECTION] < diff_cornerMinSpacing
                    NON_PARALLEL = TRUE
                    POINT_TOUCH = TRUE
                    BOX_CORNER = FALSE
                } TEMP = corner_err1
                EXTERNAL via8  metal9  {
                    SPACING <= 0
                    CONVEX_TO_CONVEX < diff_cornerMinSpacing
                    NON_PARALLEL = TRUE
                    POINT_TOUCH = TRUE
                    BOX_CORNER = TRUE
                } TEMP = corner_err2
                BOOLEAN corner_err1 OR corner_err2 {
                    COMMENT = "$layer_name Spacing   : corner to corner spacing = diff_cornerMinSpacing um "
                } (19 )
                EXTERNAL via8  metal9  {
                    COMMENT = "$layer_name Spacing   : minimum spacing = diff_minSpacing um"
                    SPACING < diff_minSpacing
                    SET_CORNERS_TO_SPACING = FALSE
                    PARALLEL_POINT_PROJECTION = FALSE
                    NON_PARALLEL = TRUE
                    TOUCH = FALSE
                    POINT_TOUCH = FALSE
                } (19 )
            } else {
                EXTERNAL via8  metal9  {
                    COMMENT = "$layer_name Spacing  : minimum spacing = diff_minSpacing um (corner to corner spacing = diff_cornerMinSpacing um)"
                    SPACING < diff_minSpacing
                    CONVEX_TO_CONVEX < diff_cornerMinSpacing
                    NON_PARALLEL = TRUE
                    POINT_TOUCH = TRUE
                    TOUCH = TRUE
                } (19 )
            }
        } else {
            EXTERNAL via8  metal9  {
                COMMENT = "$layer_name Spacing  : minimum spacing = diff_minSpacing um"
                SPACING < diff_minSpacing
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                TOUCH = TRUE
            } (19 )
        }
    }
}
 
/*check enclosure*/
if (diff_minEnclosure > 0) {
    ENCLOSE via8  BY metal9  {
        COMMENT = "$layer_name Enclosure: minimum enclosure ( diff_minEnclosure )"
        SPACING < diff_minEnclosure
	NON_PARALLEL = TRUE
	POINT_TOUCH = TRUE
	TOUCH = TRUE
    } (19 )
    BOOLEAN via8  NOT metal9  {
        COMMENT = "$layer_name Enclosure: minimum enclosure ( diff_minEnclosure )"
    } (19 )
}
 
/*check end_of_line enclosure*/
if (diff_endOfLineEnclosure > 0) {
    if (diff_minEnclosure  == 0) {
       BOOLEAN via8  NOT metal9  {
           COMMENT = "$layer_name EndOfLine: end-of-line minimum enclosure ( diff_endOfLineEnclosure )"
       } (19 )
    }
    if (diff_endOfLineMode == 0) {
        ENCLOSE via8  BY metal9  {
	    SPACING < diff_endOfLineEnclosure
	    SET_CORNERS_TO_SPACING = FALSE
	    PARALLEL_POINT_PROJECTION = FALSE
	    SHADOW_OTHER_LAYER = TRUE  
	    TOUCH = TRUE
	    POINT_TOUCH = FALSE
	    NON_PARALLEL = TRUE
            OUTPUT_EDGES = TRUE
        } TEMP = violation
 
        SELECT_EDGE via8  TOUCHING violation {  } TEMP = edges
        SELECT_VECTOR edges { ANGLE_RANGE = [0, 0] } TEMP = h_edges
        SELECT_VECTOR edges { ANGLE_RANGE = [90, 90] } TEMP = v_edges
        SELECT h_edges INTERACT v_edges { POINT_TOUCH = TRUE } TEMP = h_edges
 
        SELECT via8  ENCLOSING h_edges {
            COMMENT = "$layer_name EndOfLine: end-of-line minimum enclosure ( diff_endOfLineEnclosure )"
        } (19 )
    }
    else {
    }
}
 
/*check stackable*/
if (diff_not_stackable > 0) {
     BOOLEAN via8  AND metal9  {
        COMMENT = "$layer_name Stackable: not stackable"
    } (19 )
}
/*check fat metal via keep-out area*/
if (diff_fatTblViaKeepoutThreshold > 0 && diff_fatTblViaKeepoutMinSize > 0 && diff_fatTblViaKeepoutEnclosure > 0) {
    if (diff_fatTblViaKeepoutThreshold > 0) {
        if ((diff_fatTblViaKeepoutThreshold / 2.0) > 0.0005 ) {
           SIZE metal9  { UNDER_OVER = diff_fatTblViaKeepoutThreshold / 2.0 - 0.0005  } TEMP = fat_candidate
           if (diff_fatTblViaKeepoutNextThreshold > 0) {
              SIZE fat_candidate { UNDER_OVER = diff_fatTblViaKeepoutNextThreshold / 2.0 - 0.0005  } TEMP = fat_next
              BOOLEAN fat_candidate NOT fat_next { } TEMP = fat
              BOOLEAN fat AND metal9  { } TEMP = fat
              SET diff_fatTblViaKeepoutNextThreshold = 0;
           } else {
              BOOLEAN fat_candidate AND metal9  {  } TEMP = fat
           }
        } else {
           COPY metal9  { } TEMP = fat
           COPY metal9  { } TEMP = fat_candidate 
        }
    }
    VERTEX fat_candidate {
       CONVEX = TRUE
       SIZE = 0.001 
    } TEMP = fat_corners
    VERTEX fat {
       CONVEX = TRUE
       SIZE = 0.001 
    } TEMP = wire_corners
    SELECT wire_corners INTERACT fat_corners { } TEMP = wire_corners
    SELECT_EDGE fat INTERACT wire_corners { } TEMP = edge_corners
    SELECT_VECTOR edge_corners {
       LENGTH_RANGE = [0, diff_fatTblViaKeepoutMinSize- 0.0005 ]
    } TEMP = edge_tmp1
    BOOLEAN edge_corners NOT edge_tmp1 { } TEMP = edge_tmp2
    SELECT wire_corners OUTSIDE edge_tmp1 {  } TEMP = real_corners
    BOOLEAN edge_tmp2 AND real_corners { } TEMP = real_edge
    SIZE real_edge {
       VSIZE_HEAD = diff_fatTblViaKeepoutMinSize-2* 0.001 
       VSIZE_TAIL = diff_fatTblViaKeepoutMinSize-2* 0.001 
       VSIZE_INSIDE = diff_fatTblViaKeepoutEnclosure- 0.001 
    } TEMP = forb_corners
    SELECT via8  INSIDE fat { } TEMP = v_fat
    /* Work around: need an accurate via_cluster */
    SELECT via_cluster INSIDE fat { } TEMP = v_fat_cluster
    SELECT v_fat INTERACT forb_corners { } TEMP = bad_vias
    BOOLEAN v_fat NOT bad_vias { } TEMP = good_vias
    SELECT v_fat_cluster OUTSIDE good_vias { } TEMP = bad_v_fat_cluster
    SELECT v_fat INTERACT bad_v_fat_cluster {
       COMMENT = "$layer_name ViaKepOut: fat metal ( diff_fatTblViaKeepoutThreshold um) contact keep-out area ( diff_fatTblViaKeepoutMinSize um, diff_fatTblViaKeepoutEnclosure um) "
    } (19 )
}
 
/* reset variables */



 
SET diff_minSpacing = 0;
SET diff_netMinSpacing = 0;
SET diff_cornerMinSpacing = 0;
SET diff_minEnclosure = 0;
SET diff_endOfLineEnclosure = 0;
SET diff_not_stackable = 0;
SET diff_fatTblViaKeepoutThreshold = 0;
SET diff_fatTblViaKeepoutNextThreshold = 0;
SET diff_fatTblViaKeepoutMinSize = 0;
SET diff_fatTblViaKeepoutEnclosure = 0;
@ 912 "adrc/adrc.ev" 2

    }
}
DISCONNECT


/*Via keep-out area design rules*/

